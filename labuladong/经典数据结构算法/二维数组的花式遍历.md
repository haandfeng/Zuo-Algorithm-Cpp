
# [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

感觉就是数学题
我们可以先将 n x n 矩阵 matrix 按照左上到右下的对角线进行镜像对称：
![](https://labuladong.online/images/algo/2d-array/2.jpeg)


然后再对矩阵的每一行进行反转：
![](https://labuladong.online/images/algo/2d-array/3.jpeg)



发现结果就是 matrix 顺时针旋转 90 度的结果：![](https://labuladong.online/images/algo/2d-array/4.jpeg)
```python
class Solution:
    def rotate(self, matrix):
        # 将二维矩阵原地顺时针旋转 90 度
        n = len(matrix)
        # 先沿对角线镜像对称二维矩阵
        for i in range(n):
            for j in range(i, n):
                # swap(matrix[i][j], matrix[j][i]);
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        # 然后反转二维矩阵的每一行
        for row in matrix:
            self.reverse(row)
    
    # 反转一维数组
    def reverse(self, arr):
        i, j = 0, len(arr) - 1
        while j > i:
            # swap(arr[i], arr[j]);
            arr[i], arr[j] = arr[j], arr[i]
            i += 1
            j -= 1
```
## [151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        return " ".join(s.strip().split()[::-1])
```


## [61.旋转链表](https://leetcode.cn/problems/rotate-list/)

写一个反转K个链表的API
```python
class Solution:
    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        if not head or not head.next or k == 0:
            return head

        # 1. 计算链表长度
        n = 0
        cur = head
        while cur:
            n += 1
            cur = cur.next

        k %= n
        if k == 0:
            return head

        # 2. 反转整个链表
        new_head, _ = self.reverseFirstK(head, n)

        # 3. 反转前 k 个
        first_head, rest = self.reverseFirstK(new_head, k)

        # 4. 反转剩余 n-k 个
        second_head, _ = self.reverseFirstK(rest, n - k)

        # 5. 拼接
        cur = first_head
        while cur.next:
            cur = cur.next
        cur.next = second_head

        return first_head

    # ===== 你要的 API =====
    def reverseFirstK(self, head: ListNode, k: int):
        prev = None
        cur = head
        while k > 0 and cur:
            nxt = cur.next
            cur.next = prev
            prev = cur
            cur = nxt
            k -= 1
        return prev, cur
```

