# 环检测及拓扑排序算法

回答用了DFS，讲了很久，但我觉得这个方法一般，还是用DFS把
##  [207. 课程表](https://leetcode.cn/problems/course-schedule/)


## [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)


# 并查集
https://labuladong.online/zh/algo/data-structure/union-find/
## [323. Number of Connected Components in an Undirected Graph](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/)

直接用模版就好了

```python
class UF:
    # 连通分量个数
    _count: int
    # 存储每个节点的父节点
    parent: List[int]

    # n 为图中节点的个数
    def __init__(self, n: int):
        self._count = n
        self.parent = [i for i in range(n)]

    # 将节点 p 和节点 q 连通
    def union(self, p: int, q: int):
        rootP = self.find(p)
        rootQ = self.find(q)

        if rootP == rootQ:
            return

        self.parent[rootQ] = rootP
        # 两个连通分量合并成一个连通分量
        self._count -= 1

    # 判断节点 p 和节点 q 是否连通
    def connected(self, p: int, q: int) -> bool:
        rootP = self.find(p)
        rootQ = self.find(q)
        return rootP == rootQ

    def find(self, x: int) -> int:
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    # 返回图中的连通分量个数
    def count(self) -> int:
        return self._count
class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        uf = UF(n)
        for p, q in edges:
            uf.union(p,q)
        return uf.count()
        
```



## [130. 被围绕的区域](https://leetcode.cn/problems/surrounded-regions/)


其实这个问题应该归为 岛屿系列问题 使用 DFS 算法解决：先用 for 循环遍历棋盘的四边，用 DFS 算法把那些与边界相连的 O 换成一个特殊字符，比如 \#；然后再遍历整个棋盘，把剩下的 O 换成 X，把 # 恢复成 O。这样就能完成题目的要求，时间复杂度 O(MN)。

但这个问题也可以用 Union-Find 算法解决，虽然实现复杂一些，甚至效率也略低，但这是使用 Union-Find 算法的通用思想，值得一学。

你可以把那些不需要被替换的 O 看成一个拥有独门绝技的门派，它们有一个共同「祖师爷」叫 dummy，这些 O 和 dummy 互相连通，而那些需要被替换的 O 与 dummy 不连通。

![](https://labuladong.online/images/algo/unionfind-in-action/3.jpg)


这就是 Union-Find 的核心思路，明白这个图，就很容易看懂代码了。

首先要解决的是，根据我们的实现，Union-Find 底层用的是一维数组，构造函数需要传入这个数组的大小，而题目给的是一个二维棋盘。

这个很简单，二维坐标 (x,y) 可以转换成 x * n + y 这个数（m 是棋盘的行数，n 是棋盘的列数），敲黑板，这是将二维坐标映射到一维的常用技巧。

其次，我们之前描述的「祖师爷」是虚构的，需要给他老人家留个位置。索引 \[0.. m\*n-1] 都是棋盘内坐标的一维映射，那就让这个虚拟的 dummy 节点占据索引 m * n 好了。



看看代码，最后的UF的思路很简单。UF还是主要用来找联通分量的。这里就构建了多个联通分量。但在边界的岛都放在一个连通分量里
```python
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        if not board:
            return

        m = len(board)
        n = len(board[0])
        # 给 dummy 留一个额外位置
        uf = UF(m * n + 1)
        dummy = m * n
        # 将首列和末列的 O 与 dummy 连通
        for i in range(m):
            if board[i][0] == 'O':
                uf.union(i * n, dummy)
            if board[i][n - 1] == 'O':
                uf.union(i * n + n - 1, dummy)
        # 将首行和末行的 O 与 dummy 连通
        for j in range(n): # <extend up -150>![](/images/algo/unionfind-in-action/3.jpg) #
            if board[0][j] == 'O':
                uf.union(j, dummy)
            if board[m - 1][j] == 'O':
                uf.union(n * (m - 1) + j, dummy)
        # 方向数组 d 是上下左右搜索的常用手法
        d = [[1, 0], [0, 1], [0, -1], [-1, 0]]
        for i in range(1, m - 1):
            for j in range(1, n - 1):
                if board[i][j] == 'O':
                    # 将此 O 与上下左右的 O 连通
                    for k in range(4):
                        x = i + d[k][0]
                        y = j + d[k][1]
                        if board[x][y] == 'O':
                            uf.union(x * n + y, i * n + j)
        # 所有不和 dummy 连通的 O，都要被替换
        for i in range(1, m - 1):
            for j in range(1, n - 1):
                if not uf.connected(dummy, i * n + j):
                    board[i][j] = 'X'

class UF:
    # 记录连通分量个数
    def __init__(self, n: int):
        self.count = n
        # 存储若干棵树
        self.parent = list(range(n))
        # 记录树的“重量”
        self.size = [1] * n

    # 将 p 和 q 连通
    def union(self, p: int, q: int) -> None:
        rootP = self.find(p)
        rootQ = self.find(q)
        if rootP == rootQ:
            return

        # 小树接到大树下面，较平衡
        if self.size[rootP] > self.size[rootQ]:
            self.parent[rootQ] = rootP
            self.size[rootP] += self.size[rootQ]
        else:
            self.parent[rootP] = rootQ
            self.size[rootQ] += self.size[rootP]
        self.count -= 1

    # 判断 p 和 q 是否互相连通
    def connected(self, p: int, q: int) -> bool:
        rootP = self.find(p)
        rootQ = self.find(q)
        # 处于同一棵树上的节点，相互连通
        return rootP == rootQ

    # 返回节点 x 的根节点
    def find(self, x: int) -> int:
        while self.parent[x] != x:
            # 进行路径压缩
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def count(self) -> int:
        return self.count
```



## [990. 等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations/)

这里需要描述两种关系，一种是== 另外一种是 !=



我们前文说过，动态连通性其实就是一种等价关系，具有「自反性」「传递性」和「对称性」，其实 == 关系也是一种等价关系，具有这些性质。所以这个问题用 Union-Find 算法就很自然。



我们可以用 uf描述 == ，因为== 符合联通的所有性质。

然后检查如果xy相互连接的情况下，是否还有！=，有的话判断错误

```python
class Solution:
    # 26 个英文字母
    def equationsPossible(self, equations) -> bool:
        uf = UF(26)
        # 先让相等的字母形成连通分量
        for eq in equations:
            if eq[1] == '=':
                x = ord(eq[0]) - ord('a')
                y = ord(eq[3]) - ord('a')
                uf.union(x, y)
        # 检查不等关系是否打破相等关系的连通性
        for eq in equations:
            if eq[1] == '!':
                x = ord(eq[0]) - ord('a')
                y = ord(eq[3]) - ord('a')
                # 如果相等关系成立，就是逻辑冲突
                if uf.connected(x, y):
                    return False
        return True


class UF:
    # 记录连通分量个数
    def __init__(self, n):
        self.count = n
        # 存储若干棵树
        self.parent = list(range(n))
        # 记录树的“重量”
        self.size = [1] * n

    # 将 p 和 q 连通
    def union(self, p, q):
        rootP = self.find(p)
        rootQ = self.find(q)
        if rootP == rootQ:
            return

        # 小树接到大树下面，较平衡
        if self.size[rootP] > self.size[rootQ]:
            self.parent[rootQ] = rootP
            self.size[rootP] += self.size[rootQ]
        else:
            self.parent[rootP] = rootQ
            self.size[rootQ] += self.size[rootP]
        self.count -= 1

    # 判断 p 和 q 是否互相连通
    def connected(self, p, q):
        rootP = self.find(p)
        rootQ = self.find(q)
        # 处于同一棵树上的节点，相互连通
        return rootP == rootQ

    # 返回节点 x 的根节点
    def find(self, x):
        while self.parent[x] != x:
            # 进行路径压缩
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    def count(self):
        return self.count
```


## [547. 省份数量](https://leetcode.cn/problems/number-of-provinces/)



DFS找路径的数量

UF进行连通分量的统计

注意一下邻接矩阵的便利方法
从行+1 开始遍历列

```python
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        n = len(isConnected)
        uf = UF(n)
        for i in range(n):
            for j in range(i + 1, n):
                # 如果两个城市是相连的，那么它们属于同一个连通分量
                if isConnected[i][j] == 1:
                    uf.union(i, j)
        return uf.get_count()

class UF:
    # 连通分量个数
    def __init__(self, n: int):
        self.count = n
        # 存储每个节点的父节点
        self.parent = list(range(n))

    # n 为图中节点的个数

    # 将节点 p 和节点 q 连通
    def union(self, p: int, q: int):
        rootP = self.find(p)
        rootQ = self.find(q)

        if rootP == rootQ:
            return

        self.parent[rootQ] = rootP
        # 两个连通分量合并成一个连通分量
        self.count -= 1

    # 判断节点 p 和节点 q 是否连通
    def connected(self, p: int, q: int) -> bool:
        rootP = self.find(p)
        rootQ = self.find(q)
        return rootP == rootQ

    def find(self, x: int) -> int:
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    # 返回图中的连通分量个数
    def get_count(self) -> int:
        return self.count
```

## [261. Graph Valid Tree](https://leetcode.com/problems/graph-valid-tree/)


# [1361. 验证二叉树](https://leetcode.cn/problems/validate-binary-tree-nodes/)


DFS的思路：

我们将验证二叉树的过程分为两步：第一步找到二叉树的根节点，第二步从根节点开始对二叉树进行遍历，判断其是否为一颗有效的二叉树。

在第一步中，为了找到根节点，我们需要用数组 indeg 存放所有节点的入度，这是因为只有入度为 0 的点才能是根节点。我们遍历数组 leftChild 和 rightChild，如果数组中的某个元素 x 不为 -1，那么就表示有一条边指向节点 x，节点 x 的入度 indeg[x] 增加 1。在遍历完数组 leftChild 和 rightChild 后，我们在数组 indeg 中找到一个满足 index[root] == 0 的节点 root，即为二叉树的根节点。

如果有多个满足 index[root] == 0 的节点呢？在这种情况下，这 n 个节点一定不是一颗有效的二叉树。我们把这个问题放在第二步来考虑，而在第一步中，我们先不处理这个问题。

在第二步中，我们从根节点开始进行深度优先搜索或广度优先搜索，判定这 n 个节点的连通性，这是因为当这个 n 个节点是一颗有效的二叉树时，所有的节点会恰好被遍历一次。==如果某一个节点被遍历了超过一次（有不止一个父节点）或零次（不连通），那么这 n 个节点都不是一颗有效的二叉树。我们可以使用哈希集合（HashSet）seen 来存放所有被遍历过的节点，如果在搜索时遍历到了 seen 中出现的节点，那么说明该节点被遍历了超过一次。如果在搜索完成后，seen 中的节点个数少于 n，那么说明有些节点没有被遍历过。==

回到第一步中遗留的那个问题，如果有多个满足 index[root] == 0 的节点 r1, r2, ...，那么我们可以任意选择一个节点，例如 r1，作为根节点。在搜索时，由于节点 r2, ... 的入度为 0，因此不可能被遍历到。这样在搜索结束后，seen 中的节点个数一定少于 n。


UF的思路：


# [947. 移除最多的同行或同列石头](https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/)


