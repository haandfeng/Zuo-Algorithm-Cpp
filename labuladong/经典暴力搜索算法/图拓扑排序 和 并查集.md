# 环检测及拓扑排序算法

回答用了DFS，讲了很久，但我觉得这个方法一般，还是用DFS把
##  [207. 课程表](https://leetcode.cn/problems/course-schedule/)


## [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)


# 并查集
https://labuladong.online/zh/algo/data-structure/union-find/
## [323. Number of Connected Components in an Undirected Graph](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/)

直接用模版就好了

```python
class UF:
    # 连通分量个数
    _count: int
    # 存储每个节点的父节点
    parent: List[int]

    # n 为图中节点的个数
    def __init__(self, n: int):
        self._count = n
        self.parent = [i for i in range(n)]

    # 将节点 p 和节点 q 连通
    def union(self, p: int, q: int):
        rootP = self.find(p)
        rootQ = self.find(q)

        if rootP == rootQ:
            return

        self.parent[rootQ] = rootP
        # 两个连通分量合并成一个连通分量
        self._count -= 1

    # 判断节点 p 和节点 q 是否连通
    def connected(self, p: int, q: int) -> bool:
        rootP = self.find(p)
        rootQ = self.find(q)
        return rootP == rootQ

    def find(self, x: int) -> int:
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    # 返回图中的连通分量个数
    def count(self) -> int:
        return self._count
class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        uf = UF(n)
        for p, q in edges:
            uf.union(p,q)
        return uf.count()
        
```



# [130. 被围绕的区域](https://leetcode.cn/problems/surrounded-regions/)