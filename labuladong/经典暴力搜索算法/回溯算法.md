抽象地说，解决一个回溯问题，实际上就是遍历一棵决策树的过程，树的每个叶子节点存放着一个合法答案。你把整棵树遍历一遍，把叶子节点上的答案都收集起来，就能得到所有的合法答案。

站在回溯树的一个节点上，你只需要思考 3 个问题：

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。

```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        路径.add(选择)
        backtrack(路径, 选择列表)
        撤销选择
        将该选择再加入选择列表
```

# [46. 全排列](https://leetcode.cn/problems/permutations/)

```python
class Solution:
    def __init__(self):
        self.res = []

    # 主函数，输入一组不重复的数字，返回它们的全排列
    def permute(self, nums):
        # 记录「路径」
        track = []
        # 「路径」中的元素会被标记为 true，避免重复使用
        used = [False] * len(nums)
        
        self.backtrack(nums, track, used)
        return self.res

    # 路径：记录在 track 中
    # 选择列表：nums 中不存在于 track 的那些元素（used[i] 为 false）
    # 结束条件：nums 中的元素全都在 track 中出现
    def backtrack(self, nums, track, used):
        # 触发结束条件
        if len(track) == len(nums):
            self.res.append(track.copy())
            return

        for i in range(len(nums)):
            # 排除不合法的选择
            if used[i]: # <extend up -200>![](/images/algo/backtracking/6.jpg) #
                # nums[i] 已经在 track 中，跳过
                continue
            # 做选择
            track.append(nums[i])
            used[i] = True
            # 进入下一层决策树
            self.backtrack(nums, track, used)
            # 取消选择
            track.pop()
            used[i] = False
```

#  [37. 解数独](https://leetcode.cn/problems/sudoku-solver/)

我觉得这道题主要有两个难点思路：
1. 学会把二维数组转成一维
2. 怎么写判断条件，其实就是用个set/遍历所有数据，判断准不准就好了
```python
class Solution:
    def __init__(self):
        # 标记是否已经找到可行解
        self.found = False
        # 记录每行已经出现的数字
        # 比如 rows[0] = {1, 2, 3} 表示第 0 行已经出现了数字 1, 2, 3
        self.rows = [set() for _ in range(9)]
        # 记录每列已经出现的数字
        self.cols = [set() for _ in range(9)]
        # 记录每个九宫格已经出现的数字
        self.boxes = [set() for _ in range(9)]


    def solveSudoku(self, board):
        # 将预设数字加入集合
        for i in range(9):
            for j in range(9):
                if board[i][j] != '.':
                    self.rows[i].add(board[i][j])
                    self.cols[j].add(board[i][j])
                    self.boxes[self.getBoxIndex(i, j)].add(board[i][j])

        self.backtrack(board, 0)


    # 路径：board 中小于 index 的位置所填的数字
    # 选择列表：数字 1~9
    # 结束条件：整个 board 都填满数字
    def backtrack(self, board, index):
        if self.found:
            # 已经找到一个可行解，立即结束
            return

        m, n = 9, 9
        i, j = index // n, index % n
        if index == m * n:
            # 找到一个可行解，触发 base case
            self.found = True
            return

        if board[i][j] != '.':
            # 如果有预设数字，不用我们穷举
            self.backtrack(board, index + 1)
            return

        for ch in '123456789':
            # 剪枝：如果遇到不合法的数字，就跳过
            if not self.isValid(board, i, j, ch):
                continue

            # 做选择，把 ch 填入 board[i][j]
            board[i][j] = ch
            self.rows[i].add(ch)
            self.cols[j].add(ch)
            self.boxes[self.getBoxIndex(i, j)].add(ch)

            self.backtrack(board, index + 1)
            if self.found:
                # 如果找到一个可行解，立即结束
                # 不要撤销选择，否则 board[i][j] 会被重置为 '.'
                return

            # 撤销选择，把 board[i][j] 重置为 '.'
            board[i][j] = '.'
            self.rows[i].remove(ch)
            self.cols[j].remove(ch)
            self.boxes[self.getBoxIndex(i, j)].remove(ch)


    # 获取 (r, c) 所在的九宫格索引
    def getBoxIndex(self, r, c):
        return (r // 3) * 3 + c // 3

    # 判断是否可以在 (r, c) 位置放置数字 num
    def isValid(self, board, r, c, num):
        # 现在只需要查询三次哈希表即可
        if num in self.rows[r]:
            return False
        if num in self.cols[c]:
            return False
        if num in self.boxes[self.getBoxIndex(r, c)]:
            return False
        return True
```
# [51. N 皇后](https://leetcode.cn/problems/n-queens/)

一个逻辑

```python
class Solution:
    def __init__(self):
        self.res = []

    # 输入棋盘边长 n，返回所有合法的放置
    def solveNQueens(self, n: int) -> List[List[str]]:
        # '.' 表示空，'Q' 表示皇后，初始化空棋盘。
        board = ["." * n for _ in range(n)]
        self.backtrack(board, 0)
        return self.res

    # 路径：board 中小于 row 的那些行都已经成功放置了皇后
    # 选择列表：第 row 行的所有列都是放置皇后的选择
    # 结束条件：row 超过 board 的最后一行
    def backtrack(self, board: List[str], row: int) -> None:
        # 触发结束条件
        if row == len(board):
            self.res.append(board[:])
            return
        
        n = len(board)
        for col in range(n):
            # 排除不合法选择
            if not self.isValid(board, row, col):
                continue
            # 做选择
            board[row] = board[row][:col] + 'Q' + board[row][col+1:]
            # 进入下一行决策
            self.backtrack(board, row + 1)
            # 撤销选择
            board[row] = board[row][:col] + '.' + board[row][col+1:]

    # 是否可以在 board[row][col] 放置皇后？
    def isValid(self, board: List[str], row: int, col: int) -> bool:
        n = len(board)
        # 检查列是否有皇后互相冲突
        for i in range(row):
            if board[i][col] == 'Q':
                return False
        # 检查右上方是否有皇后互相冲突
        for i, j in zip(range(row - 1, -1, -1), range(col + 1, n)):
            if board[i][j] == 'Q':
                return False
        # 检查左上方是否有皇后互相冲突
        for i, j in zip(range(row - 1, -1, -1), range(col - 1, -1, -1)):
            if board[i][j] == 'Q':
                return False
        return True
```
# [52. N 皇后 II](https://leetcode.cn/problems/n-queens-ii/)

和1一样

```python
class Solution:
    def __init__(self):
        self.res = 0

    # 输入棋盘边长 n，返回所有合法的放置
    def totalNQueens(self, n: int) -> List[List[str]]:
        # '.' 表示空，'Q' 表示皇后，初始化空棋盘。
        board = ["." * n for _ in range(n)]
        self.backtrack(board, 0)
        return self.res

    # 路径：board 中小于 row 的那些行都已经成功放置了皇后
    # 选择列表：第 row 行的所有列都是放置皇后的选择
    # 结束条件：row 超过 board 的最后一行
    def backtrack(self, board: List[str], row: int) -> None:
        # 触发结束条件
        if row == len(board):
            self.res += 1
            return
        
        n = len(board)
        for col in range(n):
            # 排除不合法选择
            if not self.isValid(board, row, col):
                continue
            # 做选择
            board[row] = board[row][:col] + 'Q' + board[row][col+1:]
            # 进入下一行决策
            self.backtrack(board, row + 1)
            # 撤销选择
            board[row] = board[row][:col] + '.' + board[row][col+1:]

    # 是否可以在 board[row][col] 放置皇后？
    def isValid(self, board: List[str], row: int, col: int) -> bool:
        n = len(board)
        # 检查列是否有皇后互相冲突
        for i in range(row):
            if board[i][col] == 'Q':
                return False
        # 检查右上方是否有皇后互相冲突
        for i, j in zip(range(row - 1, -1, -1), range(col + 1, n)):
            if board[i][j] == 'Q':
                return False
        # 检查左上方是否有皇后互相冲突
        for i, j in zip(range(row - 1, -1, -1), range(col - 1, -1, -1)):
            if board[i][j] == 'Q':
                return False
        return True
```


# [78. 子集](https://leetcode.cn/problems/subsets/)

我们通过保证元素之间的相对顺序不变来防止出现重复的子集。
![](https://labuladong.online/images/algo/permutation/5.jpeg)
```python
class Solution:
    
    def __init__(self):
        self.res = []
        # 记录回溯算法的递归路径
        self.track = []

    # 主函数
    def subsets(self, nums: List[int]) -> List[List[int]]:
        self.backtrack(nums, 0)
        return self.res
    
    # 回溯算法核心函数，遍历子集问题的回溯树
    def backtrack(self, nums: List[int], start: int) -> None:
        
        # 前序位置，每个节点的值都是一个子集
        self.res.append(list(self.track))
        
        # 回溯算法标准框架
        for i in range(start, len(nums)):
            # 做选择
            self.track.append(nums[i])
            # 通过 start 参数控制树枝的遍历，避免产生重复的子集
            self.backtrack(nums, i + 1)
            # 撤销选择
            self.track.pop()
```


# [90. 子集 II](https://leetcode.cn/problems/subsets-ii/)

体现在代码上，需要先进行排序，让相同的元素靠在一起，如果发现 nums[i] == nums[i-1]，则跳过：
```python
class Solution:
    def __init__(self):
        self.res = []
        self.track = []
    
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        # 先排序，让相同的元素靠在一起
        nums.sort()
        self.backtrack(nums, 0)
        return self.res
    
    def backtrack(self, nums: List[int], start: int) -> None:
        # 前序位置，每个节点的值都是一个子集
        self.res.append(self.track[:])
        
        for i in range(start, len(nums)):
            # 剪枝逻辑，值相同的相邻树枝，只遍历第一条
            if i > start and nums[i] == nums[i - 1]:
                continue
            self.track.append(nums[i])
            self.backtrack(nums, i + 1)
            self.track.pop()
```



# [77. 组合](https://leetcode.cn/problems/combinations/)


和子集比，就是有了固定的大小
![](https://labuladong.online/images/algo/permutation/6.jpeg)
```python
class Solution:
    def __init__(self):
        self.res = []
        # 记录回溯算法的递归路径
        self.track = []

    # 主函数
    def combine(self, n: int, k: int) -> List[List[int]]:
        self.backtrack(1, n, k)
        return self.res

    def backtrack(self, start: int, n: int, k: int) -> None:
        # base case
        if k == len(self.track):
            # 遍历到了第 k 层，收集当前节点的值
            self.res.append(self.track.copy())
            return
        
        # 回溯算法标准框架
        for i in range(start, n+1):
            # 选择
            self.track.append(i)
            # 通过 start 参数控制树枝的遍历，避免产生重复的子集
            self.backtrack(i + 1, n, k)
            # 撤销选择
            self.track.pop()
```


# [39. 组合总和](https://leetcode.cn/problems/combination-sum/)


# [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

对比子集问题的解法，只要额外用一个 trackSum 变量记录回溯路径上的元素和，然后将 base case 改一改即可解决这道题：


```python
class Solution:
    def __init__(self):
        self.res = []
        # 记录回溯的路径
        self.track = []
        # 记录 track 中的元素之和
        self.trackSum = 0
    
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        if not candidates:
            return self.res
        # 先排序，让相同的元素靠在一起
        candidates.sort()
        self.backtrack(candidates, 0, target)
        return self.res
    
    # 回溯算法主函数
    def backtrack(self, nums: List[int], start: int, target: int):
        # base case，达到目标和，找到符合条件的组合
        if self.trackSum == target:
            self.res.append(self.track[:])
            return
        # base case，超过目标和，直接结束
        if self.trackSum > target:
            return
        
        # 回溯算法标准框架
        for i in range(start, len(nums)):
            # 剪枝逻辑，值相同的树枝，只遍历第一条
            if i > start and nums[i] == nums[i - 1]:
                continue
            # 做选择
            self.track.append(nums[i])
            self.trackSum += nums[i]
            # 递归遍历下一层回溯树
            self.backtrack(nums, i + 1, target)
            # 撤销选择
            self.track.pop()
            self.trackSum -= nums[i]
```
# [216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)


# [46. 全排列](https://leetcode.cn/problems/permutations/)
看之前的

# [LCR 082. 组合总和 II](https://leetcode.cn/problems/4sjJUc/)


# [LCR 084. 全排列 II](https://leetcode.cn/problems/7p8L0Z/)


所以现在的关键在于，如何设计剪枝逻辑，把这种重复去除掉？

答案是，保证相同元素在排列中的相对位置保持不变。

比如说 nums = [1,2,2'] 这个例子，我保持排列中 2 一直在 2' 前面。

这样的话，你从上面 6 个排列中只能挑出 3 个排列符合这个条件：




标准全排列算法之所以出现重复，是因为把相同元素形成的排列序列视为不同的序列，但实际上它们应该是相同的；而如果固定相同元素形成的序列顺序，当然就避免了重复。


// 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置
```c++
if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
    // 如果前面的相邻相等元素没有用过，则跳过
    continue;
}
// 选择 nums[i]
```

当出现重复元素时，比如输入 nums = [1,2,2',2'']，2' 只有在 2 已经被使用的情况下才会被选择，同理，2'' 只有在 2' 已经被使用的情况下才会被选择，这就保证了相同元素在排列中的相对位置保证固定。


这里拓展一下，如果你把上述剪枝逻辑中的 !used[i - 1] 改成 used[i - 1]，其实也可以通过所有测试用例，但效率会有所下降，这是为什么呢？

之所以这样修改不会产生错误，是因为这种写法相当于维护了 2'' -> 2' -> 2 的相对顺序，最终也可以实现去重的效果。

但为什么这样写效率会下降呢？因为这个写法剪掉的树枝不够多。


