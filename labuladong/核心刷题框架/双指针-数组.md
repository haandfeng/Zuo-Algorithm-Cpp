

# [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)


简单解释一下什么是原地修改：
如果不是原地修改的话，我们直接 new一个 int［］ 数组，把去重之后的元素放进这个新数组中，然后返回这个新数组即可。

但是现在题目让你原地删除，不允许 new 新数组，只能在原数组上操作，然后返回一个长度，这样就可以通过返回的长度和原始数组得到我们去重后的元素有哪些了。
由于数组已经排序，所以重复的元素一定连在一起，找出它们并不难。但如果每找到一个重复元素就立即原地删除它，由于数组中删除元素涉及数据搬移，整个时间复杂度是会达到O（N2）。


高效解决这道题就要用到快慢指针技巧：

我们让慢指针 slow 走在后面，快指针 fast 走在前面探路，找到一个不重复的元素就赋值给 slow 并让slow前进一步。

这样，就保证了 nums ［0..slow］ 都是无重复的元素，当 fast 指针遍历完整个数组 nums 后，nums ［0..slow］ 就是整个数组去重之后的结果。

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) == 0:
            return 0
        slow = 0
        fast = 0
        while fast < len(nums):
            if nums[fast] != nums[slow]:
                slow += 1
                # 维护 nums[0..slow] 无重复
                nums[slow] = nums[fast]
            fast += 1
        # 数组长度为索引 + 1
        return slow + 1
```
# [83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

和数组去重是一模一样的，唯一的区别是把数组赋值操作变成操作指针而已，你对照着之前的代码来看：


```python
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if head is None:
            return None
        slow = head
        fast = head
        while fast is not None:
            if fast.val != slow.val:
                # nums[slow] = nums[fast];
                slow.next = fast
                # slow++;
                slow = slow.next
            # fast++
            fast = fast.next
        # 断开与后面重复元素的连接
        slow.next = None
        return head
```
# [27. 移除元素](https://leetcode.cn/problems/remove-element/)

题目要求我们把 nums 中所有值为 val 的元素原地删除，依然需要使用快慢指针技巧：

如果 fast 遇到值为 val 的元素，则直接跳过，否则就赋值给 slow 指针，并让 slow 前进一步。

这和前面说到的数组去重问题解法思路是完全一样的，直接看代码：

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        fast, slow = 0, 0
        while fast < len(nums):
            if nums[fast] != val:
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        return slow
```


注意这里和有序数组去重的解法有一个细节差异，我们这里是先给 nums ［slow］赋值然后再给slowt+，这样可以保证 nums ［Q..slow-1］是不包含值为 val 的元素的，最后的结果数组长度就是 slow。

# [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

比如说给你输入 nums =［0,1,4,0,2]，你的算法没有返回值，但是会把 nums 数组原地修改成［1,4,2，0，0]。
结合之前说到的几个题目，你是否有已经有了答案呢？
稍微修改上一题中的 removeElement 函数就可以完成这道题，或者直接复用 removeElement 函数也可以。
题目让我们将所有0移到最后，其实就相当于移除 nums中的所有 0，然后再把后面的元素都赋值为0：


```python
class Solution:
    def moveZeroes(self, nums):
        # 去除 nums 中的所有 0
        # 返回去除 0 之后的数组长度
        p = self.removeElement(nums, 0)
        # 将 p 之后的所有元素赋值为 0
        for i in range(p, len(nums)):
            nums[i] = 0

    # 双指针技巧，复用 [27. 移除元素] 的解法。
    def removeElement(self, nums, val):
        fast, slow = 0, 0
        while fast < len(nums):
            if nums[fast] != val:
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        return slow
```


# [75. 颜色分类](https://leetcode.cn/problems/sort-colors/)

0[slow，fast]2 



维护一个慢指针，保持慢指针左侧是符合要求的元素，快指针在前面探路，把符合要求的元素交换到慢指针的位置。
而这道题是把数组的元系分为三部分：一部分是 0，一部分是1，一部分是 2。


看到三种元素的分类问题，我首先会想到两端向中心的双指针。
之前的快慢指针场景，是慢指针左侧维护一个索引区间，快指针在前面探路；

那么这道题是不是可以在左右分别用指针 p0，P2 维护0的区间和2的区间，让第三个指针 P 遍历数组，把遇到的元素分类到左右两个区间中，最后中间剩下的也就是元素1了。

这个思路只遍历一次就能得出结果，下面就来实现，具体代码可以有多种写法，我提供一种自认为比较清晰的，详情看代码和注释。

# [167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)


# [344. 反转字符串](https://leetcode.cn/problems/reverse-string/)


# [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)