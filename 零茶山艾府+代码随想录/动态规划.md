#0x3f #动态规划 #DP #树型dp 
状态定义，状态转移方程
当前操作？
子问题？
下一个子问题？
1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

# 动态规划 - 从记忆化搜索到递推

## [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)
[[斐波那契数列]]
1. 确定dp数组以及下标的含义
	dp[i]的定义为：第i个数的斐波那契数值是dp[i]
2. 确定递推公式
	题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2]
3. dp数组如何初始化
	dp[0] = 0    dp[1] = 1
4. 确定遍历顺序
	从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的
5. 举例推导dp数组
	按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：
	0 1 1 2 3 5 8 13 21 34 55

```c++
class Solution {
public:
    int fib(int N) {
        if (N <= 1) return N;
        vector<int> dp(N + 1);
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= N; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[N];
    }
};
```

**题目中把如何初始化也直接给我们了，如下：**

## [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)
[[爬楼梯]]
1. 确定dp数组以及下标的含义
	dp[i]的定义为：第i个台阶可能的方法数量是dp[i]
2. 确定递推公式
	dp[i] = dp[i-1]+dp[i-2]
3. dp数组如何初始化
	dp[1] = 1    dp[2] = 2
4. 确定遍历顺序
	从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的
5. 举例推导dp数组
	按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：
	 1 2 3 5 8 13 21 34 55
```c++
int climbStairs(int n) {  
    if (n == 1) return 1;  
    if (n == 2) return 2;  
    int f1=1,f2=2;  
    for(int i=3;i<=n;i++) {  
        int tmp = f1+f2;  
        f1=f2;  
        f2=tmp;  
    }  
    return f2;  
}
```

## [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)
1. 确定dp数组以及下标的含义
	dp[i]的定义为：爬到第i个台阶需要的最低费用是
2. 确定递推公式
	dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])
3. dp数组如何初始化
	dp[0] = 0    dp[1] = 0
4. 确定遍历顺序
	从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的
5. 举例推导dp数组
	按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]

```c++
  
int minCostClimbingStairs(vector<int>& cost) {  
    vector<int> dp(cost.size()+1, 0);  
    dp[0] = 0, dp[1] = 0;  
    for (int i = 2; i < cost.size()+1; i++) {  
        dp[i] = min(dp[i-1] + cost[i-1], dp[i-2]+cost[i-2]);  
    }  
    return dp[cost.size()];  
}
```
我觉得有点类似于打家劫舍，走哪一步，算上某一步的cost
```python
def minCostClimbingStairs2(self, cost: List[int]) -> int:  
    dp = [0] *(len(cost)+1)  
    for i in range (2,len(cost)+1):  
        dp[i] =  min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])  
    return dp[len(cost)]
```
## [2466. 统计构造好字符串的方案数](https://leetcode.cn/problems/count-ways-to-build-good-strings/)
都是选or不选的问题
和爬楼梯思路差不多，第一不过是之前只能爬1和2，这里是 one 和zero阶梯

```java
class Solution {
    public int countGoodStrings(int low, int high, int zero, int one) {
        final int MOD = 1_000_000_007;
        int ans = 0;
        int[] f = new int[high + 1]; // f[i] 表示构造长为 i 的字符串的方案数
        f[0] = 1; // 构造空串的方案数为 1
        for (int i = 1; i <= high; i++) {
            if (i >= zero) f[i] = f[i - zero];
            if (i >= one)  f[i] = (f[i] + f[i - one]) % MOD;
            if (i >= low)  ans = (ans + f[i]) % MOD;
        }
        return ans;
    }
}
```


```python
class Solution:
    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:
        MOD = 1_000_000_007
        @cache  # 缓存装饰器，避免重复计算 dfs 的结果（记忆化）
        def dfs(i: int) -> int:
            if i < 0:
                return 0
            if i == 0:
                return 1
            # 提前取模，不然结果会是天文数字，没有那么多空间存得下来
            return (dfs(i - zero) + dfs(i - one)) % MOD
        return sum(dfs(i) for i in range(low, high + 1)) % MOD
```
## [2266. 统计打字方案数](https://leetcode.cn/problems/count-number-of-texts/)
本质上是  [[#[70. 爬楼梯](https //leetcode.cn/problems/climbing-stairs/)|爬楼梯]]，每次可以跳 1 到 3 或者 1 到 4 个台阶，计算跳 cnt 个台阶的方案数。其中 cnt 表示连续相同子串的长度。

对于字符不为 7 或 9 的情况，定义一个类似爬楼梯的 DP，即 f[i] 表示长为 i 的只有一种字符的字符串所对应的文字信息种类数，我们可以将末尾的 1 个、2 个或 3 个字符变成一个字母，那么问题变成长为 i−1,i−2,i−3 的只有一种字符的字符串所对应的文字信息种类数，即

f[i]=f[i−1]+f[i−2]+f[i−3]
其中加法是因为三种方案互斥，根据加法原理相加。

对于字符为 7 或 9 的情况，定义 g[i] 表示长为 i 的只有一种字符的字符串对应的文字信息种类数，可以得到类似的转移方程

g[i]=g[i−1]+g[i−2]+g[i−3]+g[i−4]
由于各个组（连续相同子串）的打字方案互相独立，根据乘法原理，把各个组的方案数相乘，即为答案。

```java
class Solution {
    private static final int MOD = 1_000_000_007;
    private static final int MX = 100_001;
    private static final long[] f = new long[MX];
    private static final long[] g = new long[MX];

    static {
        f[0] = g[0] = 1;
        f[1] = g[1] = 1;
        f[2] = g[2] = 2;
        f[3] = g[3] = 4;
        for (int i = 4; i < MX; i++) {
            f[i] = (f[i - 1] + f[i - 2] + f[i - 3]) % MOD;
            g[i] = (g[i - 1] + g[i - 2] + g[i - 3] + g[i - 4]) % MOD;
        }
    }

    public int countTexts(String s) {
        long ans = 1;
        int cnt = 0;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            cnt++;
            if (i == s.length() - 1 || c != s.charAt(i + 1)) {
                ans = ans * (c != '7' && c != '9' ? f[cnt] : g[cnt]) % MOD;
                cnt = 0;
            }
        }
        return (int) ans;
    }
}
```


```python
MOD = 1_000_000_007  
f = [1, 1, 2, 4]  
g = [1, 1, 2, 4]  
for _ in range(10 ** 5 - 3):  # 预处理所有长度的结果  
    f.append((f[-1] + f[-2] + f[-3]) % MOD)  
    g.append((g[-1] + g[-2] + g[-3] + g[-4]) % MOD)  
  
class Solution:  
    def countTexts(self, pressedKeys: str) -> int:  
        ans = 1  
        for ch, s in groupby(pressedKeys):  
            m = len(list(s))  
            ans = ans * (g[m] if ch in "79" else f[m]) % MOD  
        return ans
```

## [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)
[[矩阵中的最小路径和]]
和[[#[62. 不同路径](https //leetcode.cn/problems/unique-paths/)|不同路径]]一样的思路
```java
public int minPathSum(int[][] grid) {  
    int [][] dp = new int[grid.length][grid[0].length];  
    dp[0][0] = grid[0][0];  
    for (int i = 1; i < grid.length; i++) {  
        dp[i][0] = dp[i-1][0] + grid[i][0];  
    }  
    for(int j = 1; j < grid[0].length; j++) {  
        dp[0][j] = dp[0][j-1] + grid[0][j];  
    }  
    for (int i = 1; i < grid.length; i++) {  
        for (int j = 1; j < grid[i].length; j++) {  
            dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];  
        }  
    }  
    return dp[grid.length-1][grid[0].length-1];  
}
```
思考过程：
怎么把一个大问题变成小问题？
![[Pasted image 20250921175132.png|450]]
dfs(i,j)=min(dfs(i,j−1),dfs(i−1,j))+grid\[i]\[j]
注意递归边界的选择
递归边界：
dfs(−1,j)=dfs(i,−1)=∞。用 ∞ 表示不合法（出界）的状态，从而保证 min 不会取到不合法的状态。
dfs(0,0)=grid\[0]\[0]。
递归入口：dfs(m−1,n−1)，这是原问题，也是答案。
```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        @cache  # 缓存装饰器，避免重复计算 dfs 的结果（记忆化）
        def dfs(i: int, j: int) -> int:
            if i < 0 or j < 0:
                return inf
            if i == 0 and j == 0:
                return grid[i][j]
            return min(dfs(i, j - 1), dfs(i - 1, j)) + grid[i][j]
        return dfs(len(grid) - 1, len(grid[0]) - 1)
```
## [62. 不同路径](https://leetcode.cn/problems/unique-paths/)
[[不同路径]]
1. 确定dp数组以及下标的含义
	dp\[i]\[j]的定义为：走到ij的位置需要多少步
2. 确定递推公式
	dp\[i]\[j] = d\[ i-1 ]  \[ j ] + d\[ i  ] \[ j - 1  ]
3. dp数组如何初始化
	横为1，纵向为1
4. 确定遍历顺序
	 两个for循环嵌套，先哪个后哪个都行
5. 举例推导dp数组
	懒了 

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int j = 0; j < n; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```
## [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)
1. 确定dp数组以及下标的含义
	dp\[i]\[j]的定义为：走到ij的位置需要多少步
2. 确定递推公式
	看代码，我写得很复杂
3. dp数组如何初始化
	横为1，纵向为1
4. 确定遍历顺序
	 两个for循环嵌套，先哪个后哪个都行
5. 举例推导dp数组
	懒了 

```c++
class Solution {  
public:  
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {  
        int m = obstacleGrid.size();  
        int n = obstacleGrid[0].size();  
        if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) //如果在起点或终点出现了障碍，直接返回0  
            return 0;  
        vector<vector<int>> dp(m, vector<int>(n, 0)); 
        //一旦遇到障碍就不走了 
        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;  
        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;  
        for (int i = 1; i < m; i++) {  
            for (int j = 1; j < n; j++) {  
                if (obstacleGrid[i][j] == 1) continue;  
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];  
            }  
        }  
        return dp[m - 1][n - 1];  
    }  
};
```
## [343. 整数拆分](https://leetcode.cn/problems/integer-break/)
[[整数拆分]]
1. 确定dp数组（dp table）以及下标的含义
	dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。
2. 确定递推公式
	可以想 dp[i]最大乘积是怎么得到的呢？
	其实可以从1遍历j，然后有两种渠道得到dp[i].
	一个是j * (i - j) 直接相乘。
	一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义
3. 初始化
	只初始化dp[2] = 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是
4. 遍历顺序
	确定遍历顺序，先来看看递归公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
	dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。

```c++
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1);
        dp[2] = 1;
        for (int i = 3; i <= n ; i++) {
            for (int j = 1; j <= i / 2; j++) {
                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
            }
        }
        return dp[n];
    }
};
```
## [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)
[[不同的二叉搜索树]]
1. 确定dp数组（dp table）以及下标的含义
	**dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]**。
2. 递推公式
	在上面的分析中，其实已经看出其递推关系， dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]  
	j相当于是头结点的元素，从1遍历到i为止。
	所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量
3. dp数组如何初始化
	初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。
	从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，这是可以说得通的。
	从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。
	所以初始化dp[0] = 1
4. 遍历顺序
	就那样


```c++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
};
```

# 0-1背包 完全背包 至多/恰好/至少
![[Pasted image 20250228234246.png]]
具体背包逻辑请参考代码随想录[0-1背包理论基础1](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)
[0-1背包理论基础2](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html)
## [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)
把它理解成背包问题，背包容量为整个子集的和/2

判断最终装满背包的物品价值 是否等于 整个子集的和/2就好了

```java
public boolean canPartition(int[] nums) {  
    if(nums == null || nums.length == 0) return false;  
    int n = nums.length;  
    int sum = 0;  
    for(int num : nums) {  
        sum += num;  
    }  
    //总和为奇数，不能平分  
    if(sum % 2 != 0) return false;  
    int target = sum / 2;  
    int[] dp = new int[target + 1];  
    for(int i = 0; i < n; i++) {  
        // j的容量要比nums[i]大  
        for(int j = target; j >= nums[i]; j--) {  
            //物品 i 的重量是 nums[i]，其价值也是 nums[i]            
            dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);  
        }  
  
        //剪枝一下，每一次完成內層的for-loop，立即檢查是否dp[target] == target，優化時間複雜度（26ms -> 20ms）  
        if(dp[target] == target)  
            return true;  
    }  
    return dp[target] == target;  
}
```

01背包，使用python的递归方法
```python
def canPartition(self, nums: List[int]) -> bool:  
    sumNums = sum(nums)  
    if sumNums % 2 == 1:  
        return False  
    target = sumNums // 2  
    @cache  
    def dfs(i: int, j: int) -> bool:  
        if i < 0:  
            return True if j == 0 else False  
        if nums[i] > j:  
            return dfs(i-1,j)  
        return dfs(i-1,j) or dfs(i-1,j-nums[i])  
    return dfs(len(nums)-1,target)
```
## [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)
本题其实是尽量让石头分成重量相同的两堆（尽可能相同），相撞之后剩下的石头就是最小的。

一堆的石头重量是sum，那么我们就尽可能拼成 重量为 sum / 2 的石头堆。 这样剩下的石头堆也是 尽可能接近 sum/2 的重量。 那么此时问题就是有一堆石头，每个石头都有自己的重量，是否可以 装满 最大重量为 sum / 2的背包。

看到这里，大家是否感觉和昨天讲解的[[#[416. 分割等和子集](https //leetcode.cn/problems/partition-equal-subset-sum/)|416. 分割等和子集]] 非常像了，简直就是同一道题。
```java
    public int lastStoneWeightII(int[] stones) {
        if(stones == null || stones.length == 0) return 0;
        int sum = 0;
        for(int stone : stones) {
            sum += stone;
        }
        int tagret = sum / 2;
        int[] dp = new int[tagret + 1];
        Arrays.fill(dp, 0);
        for(int i = 0; i < stones.length; i++) {
            for(int j = tagret; j >= stones[i]; j--) {
                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        return sum-2*dp[tagret];

    }
```


## [494. 目标和](https://leetcode.cn/problems/target-sum/)
加法一个集合p，减法一个集合s-p
p - (s-p) = target
2p = target+s
p = (target+s ) /2

可以定义DP数组为装满容量J的背包有DP[J]中方法


递推公式
以上过程，抽象化如下：
- **不放物品i**：即背包容量为j，里面不放物品i，装满有dp\[i - 1]\[j]中方法。
- **放物品i**： 即：先空出物品i的容量，背包容量为（j - 物品i容量），放满背包有 dp\[i - 1]\[j - 物品i容量] 种方法。
    
本题中，物品i的容量是nums[i]，价值也是nums[i]。

递推公式：dp\[i]\[j] = dp\[i - 1]\[j] + dp\[i - 1]\[j - nums\[i]];

考到这个递推公式，我们应该注意到，`j - nums[i]` 作为数组下标，如果 `j - nums[i]` 小于零呢？

说明背包容量装不下 物品i，所以此时装满背包的方法值 等于 不放物品i的装满背包的方法，即：dp\[i]\[j] = dp\[i - 1]\[j];

所以递推公式：
```c++
if (nums[i] > j) dp[i][j] = dp[i - 1][j]; 
else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];
```


最后代码
```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if (abs(target) > sum) return 0; // 此时没有方案
        if ((target + sum) % 2 == 1) return 0; // 此时没有方案
        int bagSize = (target + sum) / 2;
        vector<int> dp(bagSize + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < nums.size(); i++) {
            for (int j = bagSize; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]]; //选dp[j - nums[i]]把i装进袋子里，dp[j]不把i装进袋子里
            }
        }
        return dp[bagSize];
    }
};
```

记忆化搜索的代码
```python
def findTargetSumWays(self, nums: List[int], target: int) -> int:  
    s = sum(nums) - abs(target)  
    if s < 0 or s % 2:  
        return 0  
  
    @cache  # 缓存装饰器，避免重复计算 dfs 的结果（记忆化）  
    def dfs(i: int, c: int) -> int:  
        if i < 0:  
            return 1 if c == 0 else 0  
        if c < nums[i]:  
            return dfs(i - 1, c)  # 只能不选  
        return dfs(i - 1, c) + dfs(i - 1, c - nums[i])  # 不选 + 选  
  
    m = s // 2  # 背包容量  
    return dfs(len(nums) - 1, m)
```
## [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)

背包容量变成二维的，背包的定义变成是dp\[i]\[j] 的最大子集数量

递推公式就是 等于 装/不装这个物品 = max(dp\[i]\[j] , dp\[i-x]\[j-y]+1)

```c++
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0)); // 默认初始化0
        for (string str : strs) { // 遍历物品
            int oneNum = 0, zeroNum = 0;
            for (char c : str) {
                if (c == '0') zeroNum++;
                else oneNum++;
            }
            for (int i = m; i >= zeroNum; i--) { // 遍历背包容量且从后向前遍历！
                for (int j = n; j >= oneNum; j--) {
                    dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
                }
            }
        }
        return dp[m][n];
    }
};
```


## [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)
最少用多少种物品 
1. 确定dp数组以及下标的含义
	**dp[j]：凑足总额为j所需钱币的最少个数为dp[j]**
2. 确定递推公式
	凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）
	
	所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。
	
	递推公式：dp[j] = min(dp[j - coins[i]] + 1, dp[j]);

3. dp数组如何初始化

	首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0;
	
	其他下标对应的数值呢？
	
	考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。
	
	所以下标非0的元素都是应该是最大值。
4. 确定遍历顺序
5. 
	本题求钱币最小个数，**那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数**。
	
	所以本题并不强调集合是组合还是排列。
	
	**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。
	
	**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。
	
	在动态规划专题我们讲过了求组合数是[动态规划：518.零钱兑换II (opens new window)](https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html)，求排列数是[动态规划：377. 组合总和 Ⅳ (opens new window)](https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html)。
	
	**所以本题的两个for循环的关系是：外层for循环遍历物品，内层for遍历背包或者外层for遍历背包，内层for循环遍历物品都是可以的！**
	
	那么我采用coins放在外循环，target在内循环的方式。
	
	本题钱币数量可以无限使用，那么是完全背包。所以遍历的内循环是正序
	
	综上所述，遍历顺序为：coins（物品）放在外循环，target（背包）在内循环。且内循环正序。

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i < coins.size(); i++) { // 遍历物品
            for (int j = coins[i]; j <= amount; j++) { // 遍历背包
                if (dp[j - coins[i]] != INT_MAX) { // 如果dp[j - coins[i]]是初始值则跳过，因为在那个值里面，没有数量有效
                    dp[j] = min(dp[j - coins[i]] + 1, dp[j]);
                }
            }
        }
        if (dp[amount] == INT_MAX) return -1;
        return dp[amount];
    }
};
```
## [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)
[[组合总和 Ⅳ]]
dp数组含义，dp[i]表示i的值有dp[i]个可能
dp[2]= dp[1] + dp[0
dp[3] =  dp[0] +
.....

每次从 nums 中选一个数，作为往上爬的台阶数，计算爬 target 个台阶有多少种方案。70 那题相当于 nums=[1,2]，因为每次只能爬 1 个或 2 个台阶。

```java
class Solution {  
    public int combinationSum4(int[] nums, int target) {  
        int[] f = new int[target + 1];  
        f[0] = 1;  
        for (int i = 1; i <= target; i++) {  
            for (int x : nums) {  
                if (x <= i) {  
                    f[i] += f[i - x];  
                }  
            }  
        }  
        return f[target];  
    }  
}
```


回溯法
我觉得用回溯法想出来并不好解释。主要是递归边界的解释
```python
def combinationSum4(self, nums: List[int], target: int) -> int:  
    @cache  
    def dfs(i:int)->int:  
        res = 0  
        if i == 0:  
            return 1  
        for num in nums:  
            if num <= i:  
                res+=dfs(i-num)  
        return res  
    return dfs(target)
```
## [57. 爬楼梯_卡码](https://kamacoder.com/problempage.php?pid=1067)

可能有点难
## [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)

可以取无限次，是完全背包

我上面有说过，本题和 [494. 目标和 (opens new window)](https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html)是一样的，唯一区别就是 [494. 目标和 (opens new window)](https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html)是 01背包，本题是完全背包。

在[494. 目标和 (opens new window)](https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html)中详解讲解了装满背包有几种方法，二维DP数组的递推公式： `dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]`

所以本题递推公式：`dp[i][j] = dp[i - 1][j] + dp[i][j - nums[i]]` ，区别依然是 `dp[i - 1][j - nums[i]]` 和 `dp[i][j - nums[i]]`


二维dp数组
以amount为5，coins为：[2,3,5] 为例：

dp数组应该是这样的：
```sh
1 0 1 0 1 0
1 0 1 1 1 1
1 0 1 1 1 2
```
代码：
```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int bagSize = amount;

        vector<vector<uint64_t>> dp(coins.size(), vector<uint64_t>(bagSize + 1, 0));

        // 初始化最上行
        for (int j = 0; j <= bagSize; j++) {
            if (j % coins[0] == 0) dp[0][j] = 1;
        }
        // 初始化最左列
        for (int i = 0; i < coins.size(); i++) {
            dp[i][0] = 1;
        }
        // 以下遍历顺序行列可以颠倒
        for (int i = 1; i < coins.size(); i++) { // 行，遍历物品
            for (int j = 0; j <= bagSize; j++) { // 列，遍历背包
                if (coins[i] > j) dp[i][j] = dp[i - 1][j]; 
                else dp[i][j] = dp[i - 1][j] +  dp[i][j - coins[i]];
            }
        }
        return dp[coins.size() - 1][bagSize];
    }
};
```




```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<uint64_t> dp(amount + 1, 0); // 防止相加数据超int
        dp[0] = 1; // 只有一种方式达到0
        for (int i = 0; i < coins.size(); i++) { // 遍历物品
            for (int j = coins[i]; j <= amount; j++) { // 遍历背包
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount]; // 返回组合数
    }
};
```



### 排列和组合的区别的示例代码

```c++
#include <iostream>  
#include <vector>  
using namespace std;  
  
void combinationDP(int amount, vector<int>& coins) {  
    vector<uint64_t> dp(amount + 1, 0);  
    dp[0] = 1;  
    cout << "\n[组合数写法] 不考虑顺序:\n";  
    for (int i = 0; i < coins.size(); ++i) {  
        for (int j = coins[i]; j <= amount; ++j) {  
            dp[j] += dp[j - coins[i]];  
        }  
        cout <<"组合数";  
        for (int j : dp) {  
            cout << j << " ";  
        }  
        cout << endl;  
    }  
  
  
    cout << "\n[组合数写法] 不考虑顺序:\n";  
    cout << "dp: ";  
    for (int i = 0; i <= amount; ++i) cout << dp[i] << " ";  
    cout << "\nTotal combinations: " << dp[amount] << endl;  
}  
  
void permutationDP(int amount, vector<int>& coins) {  
    vector<uint64_t> dp(amount + 1, 0);  
    dp[0] = 1;  
    for (int j = 1; j <= amount; ++j) {  
        for (int i = 0; i < coins.size(); ++i) {  
            if (j - coins[i] >= 0)  
                dp[j] += dp[j - coins[i]];  
        }  
        cout <<"排列数";  
        for (int j : dp) {  
            cout << j << " ";  
        }  
        cout << endl;  
    }  
  
    cout << "\n[排列数写法] 考虑顺序:\n";  
    cout << "dp: ";  
    for (int i = 0; i <= amount; ++i) cout << dp[i] << " ";  
    cout << "\nTotal permutations: " << dp[amount] << endl;  
}  
  
int main() {  
    int amount, n;  
    cout << "Enter target amount: ";  
    cin >> amount;  
  
    cout << "Enter number of coin types: ";  
    cin >> n;  
  
    vector<int> coins(n);  
    cout << "Enter coin values: ";  
    for (int i = 0; i < n; ++i) cin >> coins[i];  
  
    combinationDP(amount, coins);  
    permutationDP(amount, coins);  
  
    return 0;  
}
```

输出: 
可以看到组合数的方法，是看左边+原来上面的值，相加，得到结果。 例如容量等于3
存在     硬币1: 1+1+1 一种。硬币1和2  1+2 和  1+1+1 一共两种

排列的方法，可以看到，他其实是按列更新的，然后根据列计算结果。例如容量3
会存在3 = 1 +2种情况，分别是
硬币1: 2种 => 1 +1 (原来的2里面的一种)+1，   2(原来的2里面的一种)+1   按照顺序就是 1 1 1 和  2 1
硬币2: 一种 => 2(原来的1的里面一种）+1    按照顺序就是：1 2
```sh
Enter target amount: 3
Enter number of coin types: 2
Enter coin values: 1 2

[组合数写法] 不考虑顺序:
组合数 1 1 1 1  
组合数 1 1 2 2  

[组合数写法] 不考虑顺序:
dp: 1 1 2 2  
Total combinations: 3
排列数,容量0 1 0 0 0 
排列数,容量1 1 1 0 0
排列数,容量2 1 1 2 0  这里的2 11硬币 2硬币
排列数,容量3 1 1 2 3  这里的2是 21=2硬币 12=1硬币  相加

[排列数写法] 考虑顺序:
dp: 1 1 2 3
Total permutations: 3
```
## [2915. 和为目标值的最长子序列的长度](https://leetcode.cn/problems/length-of-the-longest-subsequence-that-sums-to-target/)==
01背包，数组的每一个cell最长的长度
```python
class Solution:
    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:
        f = [0] + [-inf] * target
        for x in nums:
            for j in range(target, x - 1, -1):
                f[j] = max(f[j], f[j - x] + 1)
        return f[-1] if f[-1] > 0 else -1
```
## [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

硬币数量要自己写出来，然后注意初始化方法，和零钱很像
```c++
int numSquares(int n) {  
    vector<int> dp(n+1, INT_MAX);  
    vector<int> nums;  
    dp[0] = 0;  
    int i = 1;  
    while (i*i <= n) {  
        dp[i*i] =1;  
        nums.push_back(i*i);  
        ++i;  
    }  
    for (int i = 0; i < nums.size(); i++) {  
        for (int j = nums[i] +1; j <= n; j++) {  
            if (dp[j - nums[i]] != INT_MAX) {  
                dp[j] = min (dp[j], dp[j - nums[i]] +1);  
            }  
        }  
    }  
    return dp[n];  
}
```

## [139. 单词拆分](https://leetcode.cn/problems/word-break/)
动规五部曲分析如下：

1. 确定dp数组以及下标的含义

	**dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词**。

2. 确定递推公式

	如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j < i ）。
	
	所以递推公式是 if([j, i] 这个区间的子串出现在字典里 && dp[j]是true) 那么 dp[i] = true。

3. dp数组如何初始化

	从递推公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递推的根基，dp[0]一定要为true，否则递推下去后面都都是false了。

	那么dp[0]有没有意义呢？

	dp[0]表示如果字符串为空的话，说明出现在字典里。
	
	但题目中说了“给定一个非空字符串 s” 所以测试数据中不会出现i为0的情况，那么dp[0]初始为true完全就是为了推导公式。
	
	下标非0的dp[i]初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。

4. 确定遍历顺序

	题目中说是拆分为一个或多个在字典中出现的单词，所以这是完全背包。
	
	还要讨论两层for循环的前后顺序。
	
	**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。
	
	**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。
	
	我在这里做一个总结：
	
	求组合数：[动态规划：518.零钱兑换II (opens new window)](https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html)求排列数：[动态规划：377. 组合总和 Ⅳ (opens new window)](https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html)、[动态规划：70. 爬楼梯进阶版（完全背包） (opens new window)](https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html)求最小数：[动态规划：322. 零钱兑换 (opens new window)](https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html)、[动态规划：279.完全平方数(opens new window)](https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html)
	
	而本题其实我们求的是排列数，为什么呢。 拿 s = "applepenapple", wordDict = ["apple", "pen"] 举例。
	
	"apple", "pen" 是物品，那么我们要求 物品的组合一定是 "apple" + "pen" + "apple" 才能组成 "applepenapple"。
	
	"apple" + "apple" + "pen" 或者 "pen" + "apple" + "apple" 是不可以的，那么我们就是强调物品之间顺序。
	
	所以说，本题一定是 先遍历 背包，再遍历物品。
```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for (int i = 1; i <= s.size(); i++) {   // 遍历背包
            for (int j = 0; j < i; j++) {       // 遍历物品
                string word = s.substr(j, i - j); //substr(起始位置，截取的个数)
                if (wordSet.find(word) != wordSet.end() && dp[j]) {
                    dp[i] = true;
                }
            }
        }
        return dp[s.size()];
    }
};
```

# 打家劫舍系列问题

## [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)
[[打家劫舍]] [[打家劫舍系列问题]]
当前操作？ 
	枚举***第*** i个房子选/不选
子问题？ 
	从***前*** i个房子中得到的最大金额和
下一个子问题？
	不选：从前i-1个房子中得到的最大金额和
	选：从前i-2个房子中得到的最大金额和

1. 确定dp数组以及下标的含义
	dp[i]的定义为 偷到第i个房子的最大金额是，不代表一定会偷i
2. 确定递推公式
	dp[i] = max(d[i-1], d[i-2]+x)
3. dp数组如何初始化
	dp[1] = 第一个房子的金额    dp[2] = 第一个和第二个最大的金额
4. 确定遍历顺序
	从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的
5. 举例推导dp数组
	按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]

```c++
int rob(vector<int>& nums) {  
    if (nums.size() == 1) return nums[0];  
    if (nums.size() == 2) return max(nums[0], nums[1]);  
    int f1 = nums[0], f2 = max(nums[1], nums[0]);  
    for (int i = 2; i < nums.size(); i++) {  
        int tmp = max(f1+nums[i], f2);  
        f1 = f2;  
        f2 = tmp;  
    }  
    return f2;  
}
```


## [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)
[[打家劫舍 II]]
分成三个情况讨论
1. 不考虑首尾->线性数组
2. 考虑首，不考虑尾->线性数组
3. 不考虑首，考虑尾->线性数组
2 情况/ 3 情况 已经包含了1情况
```java
class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0)
            return 0;
        int len = nums.length;
        if (len == 1)
            return nums[0];
        return Math.max(robAction(nums, 0, len - 1), robAction(nums, 1, len));
    }

    int robAction(int[] nums, int start, int end) {
        int x = 0, y = 0, z = 0;
        for (int i = start; i < end; i++) {
            y = z;
            z = Math.max(y, x + nums[i]);
            x = y;
        }
        return z;
    }
}
```

分类讨论，考虑是否偷 nums[0]：

- 如果偷 nums[0]，那么 nums[1] 和 nums[n−1] 不能偷，问题变成从 nums[2] 到 nums[n−2] 的非环形版本，调用 198 题的代码解决；
- 如果不偷 nums[0]，那么问题变成从 nums[1] 到 nums[n−1] 的非环形版本，同样调用 198 题的代码解决。
这两种方案覆盖了所有情况（毕竟 nums[0] 只有偷与不偷，没有第三种选择），所以取两种方案的最大值，即为答案。

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        return Math.max(nums[0] + rob1(nums, 2, n - 1), rob1(nums, 1, n));
    }
    
    // 198. 打家劫舍
    private int rob1(int[] nums, int start, int end) { // [start,end) 左闭右开
        int f0 = 0;
        int f1 = 0;
        for (int i = start; i < end; i++) {
            int newF = Math.max(f1, f0 + nums[i]);
            f0 = f1;
            f1 = newF;
        }
        return f1;
    }
}
```



## [337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)

树形dp

这里是对一棵树进行DP，每一个节点有两个状态偷or不偷。 所以会对应起来一个dp数组：所以dp数组（dp table）以及下标的含义：下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱。

因为是递归遍历，每一次递归都会堆栈，所以会保存路径上所有节点的信息

单层处理逻辑
```c++
// 偷cur
int val1 = cur->val + left[0] + right[0];
// 不偷cur
int val2 = max(left[0], left[1]) + max(right[0], right[1]);
return {val2, val1};
```

最终结果代码
```c++
class Solution {
public:
    int rob(TreeNode* root) {
        vector<int> result = robTree(root);
        return max(result[0], result[1]);
    }
    // 长度为2的数组，0：不偷，1：偷
    vector<int> robTree(TreeNode* cur) {
        if (cur == NULL) return vector<int>{0, 0};
        vector<int> left = robTree(cur->left);
        vector<int> right = robTree(cur->right);
        // 偷cur，那么就不能偷左右节点。
        int val1 = cur->val + left[0] + right[0];
        // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况
        int val2 = max(left[0], left[1]) + max(right[0], right[1]);
        return {val2, val1};
    }
};
```

# 状态机 DP - 买卖股票系列 
本质是一系列的状态转换，昨天(step[i-1])的什么状态 通过某个公式 转成今天(step[i])的什么状态
## [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

 可以暴力(On2) or 贪心(On)

动态规划比较通用

二维DP数组，表示第i天持有/不持有这只股票最大金额

 注意理解今天的状态怎么由前一天的状态推出来

主要关注状态转移

注意只能买卖一次，所以，持有股票的的是-price[i]，因为金额从始至终都只有 0 ，只能赚一次
```c++
int maxProfit(vector<int>& prices) {  
    vector<vector<int>> dp(prices.size(), vector<int>(2, 0));  
    // 1 持有股票的最大利润， 0 不持有股票的最大利润  
    dp[0][1] = -prices[0];  
    dp[0][0] = 0;  
    for(int i = 1; i < prices.size(); i++) {  
        // 第i天持有股票，此时最大的利润是 今天买了股票 or 前一天持有股票的值 取最大值  
        dp[i][1] = max (-prices[i], dp[i-1][1]);  
        // 第i天不持有股票，此时的最大利润是,前一天不持有的最大price 和 前一天持有今天买了的最大price 取最大值  
        dp[i][0] = max(dp[i-1][0], prices[i] +dp[i-1][1]);  
    }  
    return max(dp[prices.size()-1][0], dp[prices.size()-1][1]);  
}
```


## [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)
可以买卖多次
主要就是购买的时候，到底算不算不持有股票的时候的钱的对比
```c++
int maxProfit2(vector<int>& prices) {  
    vector<vector<int>> dp(prices.size(), vector<int>(2, 0));  
    // 1 持有股票的最大利润， 0 不持有股票的最大利润  
    dp[0][1] = -prices[0];  
    dp[0][0] = 0;  
    for(int i = 1; i < prices.size(); i++) {  
        // 第i天持有股票，此时最大的利润是 今天买了股票 or 前一天持有股票的值 取最大值  
        dp[i][1] = max (dp[i-1][0]-prices[i], dp[i-1][1]);  
        // 第i天不持有股票，此时的最大利润是,前一天不持有的最大price 和 前一天持有今天买了的最大price 取最大值  
        dp[i][0] = max(dp[i-1][0], prices[i] +dp[i-1][1]);  
    }  
    return max(dp[prices.size()-1][0], dp[prices.size()-1][1]);  
}
```


### 0x3f
每一个i都有两个状态，是否持有股票
如果i<0还持有股票，是不合法的，需要置为0
每个状态的转变可以来自于之后的状态(hold)，然后把这个状态传递给之前的人 。注意这里的先后顺序，这会导致+ - pice不一样

第0天的时候，持有股票是不合法的所以说-∞
但持有股票的利润是0
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        @cache  # 缓存装饰器，避免重复计算 dfs 的结果
        def dfs(i: int, hold: bool) -> int:
            if i < 0:
                return -inf if hold else 0
            if hold:
                return max(dfs(i - 1, True), dfs(i - 1, False) - prices[i])
            return max(dfs(i - 1, False), dfs(i - 1, True) + prices[i])
        return dfs(n - 1, False)
```

转化为递推：
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        f = [[0] * 2 for _ in range(n + 1)]
        f[0][1] = -inf
        for i, p in enumerate(prices):
            f[i + 1][0] = max(f[i][0], f[i][1] + p)
            f[i + 1][1] = max(f[i][1], f[i][0] - p)
        return f[n][0] 
```
## [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)
初始化是一个问题，要知道怎么初始化

初始化好之后，套路不变
```c++
int maxProfit(vector<int>& prices) {  
    // 用一个二维数组 n*4表示，0 表示第一次不持有的最大利润，1表示第一次持有，2表示第二次不持有，3表示第二次持有的最大利润  
    vector<vector<int>> dp(prices.size(), vector<int>(4, 0));  
    dp[0][1] = -prices[0];  
    dp[0][0] = 0;  
    dp[0][2] = 0; // 初始化为0，可以当天买，当天卖，就可以变成第二次不持有了  
    dp[0][3] = -prices[0]; //初始化为-price[0] 读二次持有  
    int run = 1;  
    for(int i = 1; i < prices.size(); i++) {  
        // 第一次不持有的最大利润  
        dp[i][0] = max (prices[i] + dp[i-1][1], dp[i-1][0]);  
        // 第一次持有的最大利润  
        dp[i][1] = max (-prices[i], dp[i-1][1]);  
        // 第二次不持有的最大理由  
        dp[i][2] = max (prices[i] + dp[i-1][3], dp[i-1][2]);  
        // 第二次持有的最大利润 = 第一次不持有后再买，或维持原状的最大值  
        dp[i][3] = max (dp[i-1][0]-prices[i], dp[i-1][3]);  
    }  
    return max(dp[prices.size()-1][0], dp[prices.size()-1][2]);  
}
```

## [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)
同3

```c++
int maxProfit(int k, vector<int>& prices) {  
    vector<vector<int>> dp(prices.size(), vector<int>(2*k,0));  
    for(int i = 1; i < 2*k; i+=2) {  
        dp[0][i] = -prices[0];  
    }  
    for(int i = 1; i < prices.size(); ++i) {  
        for(int j = 0; j < 2*k; ++j) {  
            // 不持有的情况  
            if ( j  % 2 == 0) {  
                dp[i][j] = max (dp[i-1][j],dp[i-1][j+1]+prices[i]);  
            }else {  
                if (j == 1) {  
                    dp[i][j] = max(dp[i-1][j],-prices[i]);  
                }else {  
                    // dp[i][0] 第一次不持有，dp[i][1] 第一次持有，dp[i][2]第二次不持有，dp[i][3]第二次持有，所以要-3  
                    dp[i][j] = max (dp[i-1][j],dp[i-1][j-3]-prices[i]);  
                }  
            }  
        }  
    }  
  
    return dp[prices.size()-1][2*k-2];  
}
```

### 0x3f
这里的j表示可以交易的次数，一次买入+卖出才算做一次交易/所以j-1智慧出现在False/True变换的地方。并且只会出现一处，所以要提前定义好
```python
def maxProfit4(self, k: int, prices: List[int]) -> int:  
    n = len(prices)  
    @cache  # 缓存装饰器，避免重复计算 dfs 的结果（记忆化）  
    def dfs(i: int, j: int, hold: bool) -> int:  
        if j < 0:  
            return -inf  
        if i < 0:  
            return -inf if hold else 0  
        if hold:  
            return max(dfs(i - 1, j, True), dfs(i - 1, j - 1, False) - prices[i])  
        return max(dfs(i - 1, j, False), dfs(i - 1, j, True) + prices[i])  
    return dfs(n - 1, k, False)
```


**翻译成递推公式**
首先要了解，我们需要使用一个三维数组来保存这些环境变量
维度0是第i天，维度1时剩余交易次数，维度2是最大价格
	一共有n天，加上一个违法天有n+1天
	因为在记忆化搜索中，j 的范围是 [−1,k]，这一共有 k+2 个数。1:1 翻译成递推就需要 k+2 的数组大小。
	当k<0的时候，值是-inf->对应到下标就是0
	当i<0的时候，和上面同理，一个是0 一个是-∞
![[Pasted image 20250927140643.png|450]]

```c++
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        n = len(prices)
        f = [[[-inf] * 2 for _ in range(k + 2)] for _ in range(n + 1)]
        for j in range(1, k + 2):
            f[0][j][0] = 0
        for i, p in enumerate(prices):
            for j in range(1, k + 2):
                f[i + 1][j][0] = max(f[i][j][0], f[i][j][1] + p)
                f[i + 1][j][1] = max(f[i][j][1], f[i][j - 1][0] - p)
        return f[-1][-1][0]
```

**空间优化**
这里因为i只需要i和i+1的状态，可以把i维度去掉。又因为会用到之前的结果，所以需要倒序遍历。防止结果覆盖


```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        f = [[-inf] * 2 for _ in range(k + 2)]
        for j in range(1, k + 2):
            f[j][0] = 0
        for p in prices:
            for j in range(k + 1, 0, -1):
                f[j][0] = max(f[j][0], f[j][1] + p)
                f[j][1] = max(f[j][1], f[j - 1][0] - p)
        return f[-1][0]
```

**恰好K次和至少K次**

恰好：递归到 i<0 时，只有 j=0 才是合法的，j>0 是不合法的。
![[Pasted image 20250927222453.png]]
至少：
这个时候k的range只需要[0,k]，一个K+1个状态
![[Pasted image 20250927160216.png|475]]
## [309. 买卖股票的最佳时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
我的思路有点问题，dp 缺少表达前一天卖了的状态，不能指导哪一天能买，哪一天不能卖。应该定义成这样
所以对于每一天i，都有可能是三种状态：
0.不持股且当天没卖出,定义其最大收益dp\[i]\[0];
1.持股,定义其最大收益dp\[i]\[1]；
2.不持股且当天卖出了，定义其最大收益dp\[i]\[2]；
	一开始：
	多了一个中间状态冷冻
	dp[0] 不持有，不冷冻
	dp[1] 不持有，冷冻
	dp[2] 持有
	
	dp[2] = max(前一天持有股票，前一天不持有，不冷冻-price[i]) 
	dp[1] = max(前一天持有变不持有->前一天持有+price[i-1])
	
	dp[0] = max(前一天不持有，不冷冻，前一天不持有)
一、第i天不持股且没卖出的状态dp[i][0]，也就是我没有股票，而且还不是因为我卖了它才没有的，那换句话说是从i-1天到第i天转移时，它压根就没给我股票！所以i-1天一定也是不持有，那就是不持有的两种可能：i-1天不持股且当天没有卖出dp\[i-1]\[0]；i-1天不持股但是当天卖出去了dp\[i-1]\[2]；
所以： dp[i][0]=max(dp[i-1][0],dp[i-1][2])

二、第i天持股dp[i][1]，今天我持股，来自两种可能：
1、要么是昨天我就持股，今天继承昨天的，也就是dp\[i-1]\[1]，这种可能很好理解；
2、要么：是昨天我不持股，今天我买入的，但前提是昨天我一定没卖！因为如果昨天我卖了，那么今天我不能交易！也就是题目中所谓“冷冻期”的含义，只有昨天是“不持股且当天没卖出”这个状态，我今天才能买入！所以是dp\[i-1]\[0]-p[i]
所以： dp\[i]\[1]=max(dp\[i-1]\[1],dp\[i-1]\[0]-p[i])

三、i天不持股且当天卖出了，这种就简单了，那就是说昨天我一定是持股的，要不然我今天拿什么卖啊，而持股只有一种状态，昨天持股的收益加上今天卖出得到的新收益，就是dp\[i-1]\[1]+p[i]啦
所以：dp\[i]\[2]=dp\[i-1]\[1]+p[i]




----
0x3f

在 [[#[122. 买卖股票的最佳时机 II](https //leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)|买卖股票的最佳时机 II]] 的基础上，只需修改**一处**：在计算持有股票的状态时，把 dfs(i−1,0) 改成 dfs(i−2,0)。道理和在 [[#买卖股票的最佳时机 II 的基础上，只需修改一处：在计算持有股票的状态时，把 dfs(i−1,0) 改成 dfs(i−2,0)。道理和  [[#[198. 打家劫舍](https //leetcode.cn/problems/house-robber/)|打家劫舍]] 是一样的，因为第 i 天买股票的话第 i−1 天不能卖，只能从第 i−2 天没有股票的状态转移过来。注意 dfs(i−2,0) 并不意味着第 i−2 天一定卖了股票，而是在没有股票下的最优状态。

-----
代码随想录，比较易懂

状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）
不持有股票状态，这里就有两种卖出股票状态
状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）
状态三：今天卖出股票
状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if (n == 0) return 0;
        vector<vector<int>> dp(n, vector<int>(4, 0));
        dp[0][0] -= prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]));
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2] = dp[i - 1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        }
        return max(dp[n - 1][3], max(dp[n - 1][1], dp[n - 1][2]));
    }
};
```

空间优化，走的是0x3f的套路
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        f0 = 0
        prev = 0
        f1 = -inf
        for i, p in enumerate(prices):
            temp = max(f0,f1+p)
            f1 = max(f1, prev-p)
            prev = f0
            f0 = temp
        return f0
```
## [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)
同买卖股票2
```c++
int maxProfit6(vector<int>& prices, int fee) {  
    vector<vector<int>> dp(prices.size(), vector<int>(2, 0));  
    // 1 持有股票的最大利润， 0 不持有股票的最大利润  
    dp[0][1] = -prices[0];  
    dp[0][0] = 0;  
    for(int i = 1; i < prices.size(); i++) {  
        // 第i天持有股票，此时最大的利润是 今天买了股票 or 前一天持有股票的值 取最大值  
        dp[i][1] = max (dp[i-1][0]-prices[i], dp[i-1][1]);  
        // 第i天不持有股票，此时的最大利润是,前一天不持有的最大price 和 前一天持有今天买了的最大price 取最大值  
        dp[i][0] = max(dp[i-1][0], prices[i] +dp[i-1][1]-fee);  
    }  
    return max(dp[prices.size()-1][0], dp[prices.size()-1][1]);        
}
```


## [2826. 将三个组排序](https://leetcode.cn/problems/sorting-three-groups/)
见下面一样的题目

## [2786. 访问数组中的位置使分数最大](https://leetcode.cn/problems/visit-array-positions-to-maximize-score/)

其实转移只跟“上一个位置的奇偶性最优值”有关，不需要枚举所有 j：

```python
from typing import List

class Solution:
    def maxScore(self, nums: List[int], x: int) -> int:
        NEG = float('-inf')
        # best_even: 目前为止、以偶数结尾的最大分
        # best_odd : 目前为止、以奇数结尾的最大分
        if nums[0] % 2 == 0:
            best_even, best_odd = nums[0], NEG
        else:
            best_even, best_odd = NEG, nums[0]

        ans = nums[0]

        for v in nums[1:]:
            if v % 2 == 0:
                # 同偶：用 best_even；不同（奇->偶）：用 best_odd - x
                take = max(best_even, best_odd - x)
                best_even = max(best_even, take + v)
                ans = max(ans, best_even)
            else:
                # 同奇：用 best_odd；不同（偶->奇）：用 best_even - x
                take = max(best_odd, best_even - x)
                best_odd = max(best_odd, take + v)
                ans = max(ans, best_odd)

        return ans
```
# 最长公共子序列LCS
## [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)
元素之间可以不连续，可以对比[[#[718. 最长重复子数组](https //leetcode.cn/problems/maximum-length-of-repeated-subarray/)|最长重复子数组]]

因为可以不连续，递推的时候，不只是要和当前的比较
```c++
int longestCommonSubsequence(string text1, string text2) {  
    vector<vector<int>> dp(text1.size()+1, vector<int>(text2.size()+1, 0));  
    int maxRs = 0;  
    for(int i = 1; i < text1.size()+1; i++) {  
        for(int j = 1; j < text2.size()+1; j++) {  
            // 如果他们的结尾一样，则+1，匹配上了  
            if(text1[i-1] == text2[j-1]) {  
                dp[i][j] = dp[i-1][j-1]+1;  
                maxRs = max(maxRs, dp[i][j]);  
            }else {  
                //如果不匹配，以他们为结尾的的最长公共子序列（不重复）的最大长度，就要看之前的了  
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);  
            }  
        }  
    }  
    return maxRs;  
}
```


0x3f思想
只能够都选和都不选看看 
![[Pasted image 20250923165635.png]]
但在一些问题里可以忽略一些条件，还可以转一些一维数组

![[Pasted image 20250923165747.png]]

根据他的思路很容易能够写出回溯的函数/利用回溯转换成递推dp

有两个空间优化的思路
### 空间优化：两个数组（滚动数组）
因为数据其实只需要左上角的数据，所以可以用两个数组解决
```python
class Solution:
    def longestCommonSubsequence(self, s: str, t: str) -> int:
        n, m = len(s), len(t)
        f = [[0] * (m + 1) for _ in range(2)]
        for i, x in enumerate(s):
            for j, y in enumerate(t):
                f[(i + 1) % 2][j + 1] = f[i % 2][j] + 1 if x == y else \
                                        max(f[i % 2][j + 1], f[(i + 1) % 2][j])
        return f[n % 2][m]
```

###  四、空间优化：一个数组

答疑
问：为什么 j 不能倒序循环？

答：本题 f\[i+1][j+1] 需要从 f\[i+1][j] 转移过来，这只能正序枚举 j。倒序枚举的话，f\[i+1][j] 还没有计算出来。

需要一个pre来保存左上角的数据
```python
class Solution:
    def longestCommonSubsequence(self, s: str, t: str) -> int:
        f = [0] * (len(t) + 1)
        for x in s:
            pre = 0  # f[0]
            for j, y in enumerate(t):
                tmp = f[j + 1]
                f[j + 1] = pre + 1 if x == y else max(f[j + 1], f[j])
                pre = tmp
        return f[-1]
```
## [392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)

用一个二维数组，就可以表示所有的字符串是否相等的情况

删除某一个数，就某一个数字回退1


```python 
def isSubsequence(self, s: str, t: str) -> bool:  
    dp = [[0] * (len(t)+1) for _ in range(len(s)+1)]  
    for i in range(1, len(s)+1):  
        for j in range(1, len(t)+1):  
            if s[i-1] == t[j-1]:  
                dp[i][j] = dp[i-1][j-1] + 1  
            else:  
                dp[i][j] = dp[i][j-1]  
    if dp[-1][-1] == len(s):  
        return True  
    return False
```
## [115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)

参考这张图
![[Pasted image 20250920083302.png]]

看注释
```python
def numDistinct(self, s: str, t: str) -> int:  
    dp = [[0] * (len(t)+1) for _ in range(len(s)+1)]  
    for i in range(len(s)):  
        dp[i][0] = 1  
    for j in range(1, len(t)):  
        dp[0][j] = 0  
    for i in range(1, len(s)+1):  
        for j in range(1, len(t)+1):  
            if s[i-1] == t[j-1]:  
                # 当结尾字符相等的时候，需要考虑，从两个字符串的前面都取数字/s可以删除自己的字符，这个时候，如何加上还匹配的数字  
                dp[i][j] = dp[i-1][j-1] + dp[i-1][j]  
            else:  
                # 不相等的时候，s删掉自身  
                dp[i][j] = dp[i-1][j]  
    return dp[-1][-1]
```

## [583. 两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/)
==把每个字符都堪称单纯的字符看，一步一步递推== 
2. 确定递推公式
- 当word1[i - 1] 与 word2[j - 1]相同的时候
- 当word1[i - 1] 与 word2[j - 1]不相同的时候
当word1[i - 1] 与 word2[j - 1]相同的时候，dp\[i][j] = dp\[i - 1][j - 1];
当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：

情况一：删word1\[i - 1]，最少操作次数为dp\[i - 1][j] + 1
情况二：删word2\[j - 1]，最少操作次数为dp\[i][j - 1] + 1
情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp\[i - 1][j - 1] + 2

那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：dp\[i][j] = min({dp\[i - 1][j - 1] + 2, dp\[i - 1][j] + 1, dp\[i][j - 1] + 1});

因为 dp\[i][j - 1] + 1 = dp\[i - 1][j - 1] + 2，所以递推公式可简化为：dp\[i][j] = min(dp\[i - 1][j] + 1, dp\[i][j - 1] + 1);

这里可能不少录友有点迷糊，从字面上理解 就是 当 同时删word1[i - 1]和word2[j - 1]，dp\[i][j-1] 本来就不考虑 word2[j - 1]了，那么我在删 word1[i - 1]，是不是就达到两个元素都删除的效果，即 dp\[i][j-1] + 1。

3. dp数组如何初始化

从递推公式中，可以看出来，dp\[i][0] 和 dp\[0][j]是一定要初始化的。

dp\[i][0]：word2为空字符串，以i-1为结尾的字符串word1要删除多少个元素，才能和word2相同呢，很明显dp\[i][0] = i。

dp\[0][j]的话同理，所以代码如下：
![[Pasted image 20250920084830.png]]

## [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

在确定递推公式的时候，首先要考虑清楚编辑的几种操作，整理如下：

```
if (word1[i - 1] == word2[j - 1])
    不操作
if (word1[i - 1] != word2[j - 1])
    增
    删
    换
```


`if (word1[i - 1] == word2[j - 1])` 那么说明不用任何编辑，`dp[i][j]` 就应该是 `dp[i - 1][j - 1]`，即`dp[i][j] = dp[i - 1][j - 1];`


`if (word1[i - 1] != word2[j - 1])`，此时就需要编辑了，如何编辑呢？
- 操作一：word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 再加上一个操作。
	即 `dp[i][j] = dp[i - 1][j] + 1;`
- 操作二：word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上一个操作。
	即 `dp[i][j] = dp[i][j - 1] + 1;`
这里有同学发现了，怎么都是删除元素，添加元素去哪了。
**word2添加一个元素，相当于word1删除一个元素**，例如 `word1 = "ad" ，word2 = "a"`，`word1`删除元素`'d'` 和 `word2`添加一个元素`'d'`，变成`word1="a", word2="ad"`， 最终的操作数是一样！ 

- 操作三：替换元素，`word1`替换`word1[i - 1]`，使其与`word2[j - 1]`相同，此时不用增删加元素。
	可以回顾一下，`if (word1[i - 1] == word2[j - 1])`的时候我们的操作 是 `dp[i][j] = dp[i - 1][j - 1]` 对吧。
	那么只需要一次替换的操作，就可以让 word1[i - 1] 和 word2[j - 1] 相同。
	所以 `dp[i][j] = dp[i - 1][j - 1] + 1;`
	综上，当 `if (word1[i - 1] != word2[j - 1])` 时取最小的，即：`dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;`

```python
def minDistance(self, word1: str, word2: str) -> int:  
    dp = [[0] * (len(word2) + 1) for _ in range(len(word1) + 1)]  
    for i in range(len(word1) + 1):  
        dp[i][0] = i  
    for j in range(len(word2) + 1):  
        dp[0][j] = j  
    for i in range(1, len(word1) + 1):  
        for j in range(1, len(word2) + 1):  
            if word1[i - 1] == word2[j - 1]:  
                dp[i][j] = dp[i - 1][j - 1]  
            else:  
                dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1  
    return dp[-1][-1]
```

### 0x3f
递归
```python
class Solution:
    def minDistance(self, s: str, t: str) -> int:
        n, m = len(s), len(t)
        @cache  # 缓存装饰器，避免重复计算 dfs 的结果（记忆化）
        def dfs(i: int, j: int) -> int:
            if i < 0:
                return j + 1
            if j < 0:
                return i + 1
            if s[i] == t[j]:
                return dfs(i - 1, j - 1)
            return min(dfs(i - 1, j), dfs(i, j - 1), dfs(i - 1, j - 1)) + 1
        return dfs(n - 1, m - 1)
```
改成递推
```python
class Solution:
    def minDistance(self, s: str, t: str) -> int:
        n, m = len(s), len(t)
        f = [[0] * (m + 1) for _ in range(n + 1)]
        f[0] = list(range(m + 1))
        for i, x in enumerate(s):
            f[i + 1][0] = i + 1
            for j, y in enumerate(t):
                f[i + 1][j + 1] = f[i][j] if x == y else \
                        min(f[i][j + 1], f[i + 1][j], f[i][j]) + 1
        return f[n][m]
```

## [97. 交错字符串](https://leetcode.cn/problems/interleaving-string/)

一个匹配就一个退，两个都匹配不上就删掉
```python
class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
        n, m = len(s1), len(s2)
        if n + m != len(s3):
            return False

        @cache  # 缓存装饰器，避免重复计算 dfs 的结果（一行代码实现记忆化）
        def dfs(i: int, j: int) -> bool:
            if i < 0 and j < 0:
                return True
            return i >= 0 and s1[i] == s3[i + j + 1] and dfs(i - 1, j) or \
                   j >= 0 and s2[j] == s3[i + j + 1] and dfs(i, j - 1)

        return dfs(n - 1, m - 1)
```
## [1092. 最短公共超序列](https://leetcode.cn/problems/shortest-common-supersequence/)
找两个字符串的super sequence 
首先第一步思路是
	对于 s=abac 和 t=cab，考虑从后往前构造答案（最短公共超序列）。想一想，答案的最后一个字母是什么？
	要么是 s 的最后一个字母 c，要么是 t 的最后一个字母 b。其它字母是没有意义的，假设答案为 cabaca，最后一个字母是 a，你完全可以把 a 去掉，不会影响 s 和 t 作为答案的子序列。

有了这个递归思路之后，就需要分类讨论
如果 s 和 t 的最后一个字母相同
	那么这个字母就是答案的最后一个字母。例如 s=aba 和 t=ca，那么答案的最后一个字母为 a，问题变成构造 ab 和 c 的答案。
如果 s 和 t 的最后一个字母不同
	两个字符串的最后一个字符都选一次，分别递归，找到他们构造的字符串结果。哪一个更短就选哪一个
边界
	如果 s 是空串，则答案为 t。
	如果 t 是空串，则答案为 s

得到的python代码
```python
# 会超时的递归代码
class Solution:
    def shortestCommonSupersequence(self, s: str, t: str) -> str:
        if s == "": return t  # s 是空串，返回剩余的 t
        if t == "": return s  # t 是空串，返回剩余的 s
        if s[-1] == t[-1]:  # 最短公共超序列一定包含 s[-1]
            return self.shortestCommonSupersequence(s[:-1], t[:-1]) + s[-1]
        ans1 = self.shortestCommonSupersequence(s[:-1], t)
        ans2 = self.shortestCommonSupersequence(s, t[:-1])
        if len(ans1) < len(ans2):  # 取 ans1 和 ans2 中更短的组成答案
            return ans1 + s[-1]
        return ans2 + t[-1]
```

举个例子，对于 s=ab 和 t=cd 来说，「先去掉 s 中的 b，再去掉 t 中的 d」和「先去掉 t 中的 d，再去掉 s 中的 b」，都会递归到 s=a 和 t=c 的情况。

一叶知秋，整个递归中有大量重复递归调用（递归入参相同）。由于递归函数没有副作用，同样的入参无论计算多少次，算出来的结果都是一样的，因此可以用记忆化搜索来优化：

由于 s 和 t 都是字符串，为了减少空间，也为了方便使用数组记录，可以改成下标 i 和 j，其中 i 表示 s 的前 i 个字母，j 表示 t 的前 j 个字母。
如果一个状态（递归入参）是第一次遇到，那么可以在返回前，把状态及其结果记到一个 memo 数组（或哈希表）中。
如果一个状态不是第一次遇到，那么直接返回 memo 中保存的结果。


```python
# 能通过的测试数据更多，但仍然超时（超内存），还需要进一步优化
class Solution:
    def shortestCommonSupersequence(self, s: str, t: str) -> str:
        # dfs(i,j) 返回 s 的前 i 个字母和 t 的前 j 个字母的最短公共超序列
        @cache  # 缓存装饰器，避免重复计算 dfs 的结果
        def dfs(i: int, j: int) -> str:
            if i < 0: return t[:j + 1]  # s 是空串，返回剩余的 t
            if j < 0: return s[:i + 1]  # t 是空串，返回剩余的 s
            if s[i] == t[j]:  # 最短公共超序列一定包含 s[i]
                return dfs(i - 1, j - 1) + s[i]
            ans1 = dfs(i - 1, j)
            ans2 = dfs(i, j - 1)
            if len(ans1) < len(ans2):  # 取 ans1 和 ans2 中更短的组成答案
                return ans1 + s[i]
            return ans2 + t[j]
        return dfs(len(s) - 1, len(t) - 1)
```

接下来我们要优化，不要在每次递归里面都保存一个字符串，这样会爆内存
![[Pasted image 20250925133048.png]]

```python
class Solution:
    def shortestCommonSupersequence(self, s: str, t: str) -> str:
        # dfs(i,j) 返回 s 的前 i 个字母和 t 的前 j 个字母的最短公共超序列的长度
        @cache  # 缓存装饰器，避免重复计算 dfs 的结果
        def dfs(i: int, j: int) -> int:
            if i < 0: return j + 1  # s 是空串，返回剩余的 t 的长度
            if j < 0: return i + 1  # t 是空串，返回剩余的 s 的长度
            if s[i] == t[j]:  # 最短公共超序列一定包含 s[i]
                return dfs(i - 1, j - 1) + 1
            return min(dfs(i - 1, j), dfs(i, j - 1)) + 1

        # make_ans(i,j) 返回 s 的前 i 个字母和 t 的前 j 个字母的最短公共超序列
        # 看上去和 dfs 没啥区别，但是末尾的递归是 if-else
        # make_ans(i-1,j) 和 make_ans(i,j-1) 不会都调用
        # 所以 make_ans 的递归树仅仅是一条链
        def make_ans(i: int, j: int) -> str:
            if i < 0: return t[:j + 1]  # s 是空串，返回剩余的 t
            if j < 0: return s[:i + 1]  # t 是空串，返回剩余的 s
            if s[i] == t[j]:  # 公共超序列一定包含 s[i]
                return make_ans(i - 1, j - 1) + s[i]
            # 如果下面 if 成立，说明上面 dfs 中的 min 取的是 dfs(i - 1, j)
            # 说明 dfs(i - 1, j) 对应的公共超序列更短
            # 那么就在 make_ans(i - 1, j) 的结果后面加上 s[i]
            # 否则说明 dfs(i, j - 1) 对应的公共超序列更短
            # 那么就在 make_ans(i, j - 1) 的结果后面加上 t[j]
            if dfs(i, j) == dfs(i - 1, j) + 1:
                return make_ans(i - 1, j) + s[i]
            return make_ans(i, j - 1) + t[j]

        return make_ans(len(s) - 1, len(t) - 1)
```

接下来这一步就是把代码从递归改成递推了
```python
class Solution:
    def shortestCommonSupersequence(self, s: str, t: str) -> str:
        n, m = len(s), len(t)
        # f[i+1][j+1] 表示 s 的前 i 个字母和 t 的前 j 个字母的最短公共超序列的长度
        f = [[0] * (m + 1) for _ in range(n + 1)]
        f[0] = list(range(m + 1))  # 递归边界 f[0][j] = j
        for i in range(1, n + 1):
            f[i][0] = i  # 递归边界
        for i, x in enumerate(s):
            for j, y in enumerate(t):
                if x == y:  # 最短公共超序列一定包含 s[i]
                    f[i + 1][j + 1] = f[i][j] + 1
                else:  # 取更短的组成答案
                    f[i + 1][j + 1] = min(f[i][j + 1], f[i + 1][j]) + 1

        ans = []
        i, j = n - 1, m - 1
        while i >= 0 and j >= 0:
            if s[i] == t[j]:  # 公共超序列一定包含 s[i]
                ans.append(s[i])
                i -= 1
                j -= 1  # 相当于继续递归 make_ans(i - 1, j - 1)
            elif f[i + 1][j + 1] == f[i][j + 1] + 1:
                ans.append(s[i])
                i -= 1  # 相当于继续递归 make_ans(i - 1, j)
            else:
                ans.append(t[j])
                j -= 1  # 相当于继续递归 make_ans(i, j - 1)

        # 补上前面的递归边界
        # reversed(ans) 也可以写成 ans[::-1]
        return s[:i + 1] + t[:j + 1] + ''.join(reversed(ans))
```

# 最长递增子序列LIS

## [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

已nums[i] 为结尾的最长递增子序列的长度
为什么一定表示 “以nums[i]结尾的最长递增子序” ，因为我们在 做 递增比较的时候，如果比较 nums[j] 和 nums[i] 的大小，那么两个递增子序列一定分别以nums[j]为结尾 和 nums[i]为结尾， 要不然这个比较就没有意义了，不是尾部元素的比较那么 如何算递增呢。
感觉是一个过得很惨的同性恋
递推公式：遍历前面的尾巴，如果dp[i]>dp[j]更新

```c++
int lengthOfLIS(vector<int>& nums) {  
    // dp数组，以i为结尾的  
    vector<int> dp(nums.size(), 1);  
    int maxRs = 1;  
    for(int i = 1; i < nums.size(); i++) {  
        for(int j = 0; j < i; j++) {  
            // 如果大于就+1，一直取最大值  
            if(nums[i] > nums[j]) {  
                dp[i] = max(dp[i], dp[j]+1);  
            }  
        }  
        maxRs = max(maxRs, dp[i]);  
    }  
    return maxRs;  
}
```

### 0x3f
python的思路和代码随想录差不多。都是已一个数字为轴，找比他的小的数字组合在一起
```python
class Solution:  
    def lengthOfLIS(self, nums: List[int]) -> int:  
        @cache  
        def dfs(i: int) -> int:  
            res = 0  
            for j in range(i):  
                if nums[j] < nums[i]:  
                    res = max(res, dfs(j))  
            return res + 1  # 加一提到循环外面  
  
        return max(dfs(i) for i in range(len(nums)))
```

### 贪心+二分
优化时间复杂度，传统dp的时间复杂度是O(n^2)
记录最长递增子序列的长度为i的时候，他的末尾元素的最小值
记录长度为i的时候，上升子序列的末尾元素的最小值，通过这种单调栈的思路，遍历所有元素，找到最可能的最长子序列

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        g = []
        for x in nums:
            j = bisect_left(g, x)
            if j == len(g):  # >=x 的 g[j] 不存在
                g.append(x)
            else:
                g[j] = x
        return len(g)
```

可以继续优化空间到O1
直接把 g 填入 nums 中。
```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        ng = 0  # g 的长度
        for x in nums:
            j = bisect_left(nums, x, 0, ng)
            nums[j] = x
            if j == ng:  # >=x 的 g[j] 不存在
                ng += 1 
        return ng
```



## [2826. 将三个组排序](https://leetcode.cn/problems/sorting-three-groups/)

题都没读懂，似乎是和最长递增子序列一个意思
```python
class Solution:
    def minimumOperations(self, nums: List[int]) -> int:
        g = []
        for x in nums:
            j = bisect_right(g, x)
            if j == len(g):
                g.append(x)
            else:
                g[j] = x
        return len(nums) - len(g)
```

## [1671. 得到山形数组的最少删除次数](https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array/)

山形子序列可以看成一个严格递增子序列，拼接一个严格递减子序列：

定义 pre[i] 表示子序列最后一个数是 nums[i] 的最长严格递增子序列的长度。
定义 suf[i] 表示子序列第一个数是 nums[i] 的最长严格递减子序列的长度

如何计算 pre 和 suf 呢？以 suf 为例，从右往左遍历 nums，就相当于是在求最长严格递增子序列，可以使用 O(nlogn) 的做法解决。当我们遍历到 nums[i] 时，二分下标加一就是此时 suf[i] 的值。

代码实现时，计算 pre 的过程可以和计算答案最大值的过程合并，这样只需要用一个变量表示 pre。

最后用数组长度减去山形子序列的最长长度，即为答案。


计算递增子序列的长度的代码是主要的函数
```python
class Solution:
    def minimumMountainRemovals(self, nums: List[int]) -> int:
        n = len(nums)
        suf = [0] * n
        g = []
        for i in range(n - 1, 0, -1):
            x = nums[i]
            j = bisect_left(g, x)
            if j == len(g):
                g.append(x)
            else:
                g[j] = x
            suf[i] = j + 1  # 从 nums[i] 开始的最长严格递减子序列的长度

        mx = 0  # 最长山形子序列的长度
        g = []
        for i, x in enumerate(nums):
            j = bisect_left(g, x)
            if j == len(g):
                g.append(x)
            else:
                g[j] = x
            pre = j + 1  # 在 nums[i] 结束的最长严格递增子序列的长度
            if pre >= 2 and suf[i] >= 2:
                mx = max(mx, pre + suf[i] - 1)  # 减去重复的 nums[i]
        return n - mx
```


更简洁的写法
```python
class Solution:
    def minimumMountainRemovals(self, nums: List[int]) -> int:
        n = len(nums)
        def lis(nums: List[int]) -> List[int]:
            res = [0] * n
            g = []
            for i, x in enumerate(nums):
                j = bisect_left(g, x)
                if j == len(g):
                    g.append(x)
                else:
                    g[j] = x
                res[i] = j + 1
            return res
        pre = lis(nums)
        suf = lis(nums[::-1])[::-1]
        return n - max(p + s for p, s in zip(pre, suf) if p >= 2 and s >= 2) + 1  # -1 提到外面
```

## [354. 俄罗斯套娃信封问题](https://leetcode.cn/problems/russian-doll-envelopes/)
我的思路先根据左边的数据排序，然后再使用最长递增子序列就好了
需要注意，宽度要升序，高度要降书序，这样才可以保证，同一个宽度的
![[Pasted image 20250925135613.png|400]]


```python
class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        # 双关键字排序：宽度升序，高度降序
        envelopes.sort(key=lambda e: (e[0], -e[1]))

        # 300. 最长递增子序列
        g = []
        for _, h in envelopes:
            j = bisect_left(g, h)
            if j < len(g):
                g[j] = h
            else:
                g.append(h)
        return len(g)
```
## [1626. 无矛盾的最佳球队](https://leetcode.cn/problems/best-team-with-no-conflicts/)


```python
class Solution:
    def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:
        a = sorted(zip(scores, ages))
        f = [0] * len(a)
        for i, (score, age) in enumerate(a):
            for j in range(i):
                if a[j][1] <= age:
                    f[i] = max(f[i], f[j])
            f[i] += score
        return max(f)
```

## [1187. 使数组严格递增](https://leetcode.cn/problems/make-array-strictly-increasing/)

问题等价于从 a 中找到一个最长严格递增子序列 lis，把不在 lis 中的元素替换成 b 中的元素后，a 是严格递增的，求不在 lis 中的元素个数的最小值。



## [674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

已nums[i] 为结尾的最长连续递增子序列的长度

递推公式：只看前面的，是不是比他大，是的话+1，不是的话重置为1

和上面一个对比
```c++
int findLengthOfLCIS(vector<int>& nums) {
    vector<int> dp(nums.size(), 1);
    int maxRs = 1;
    for(int i = 1; i < nums.size(); i++) {
        if(nums[i] > nums[i-1]) {
            dp[i] = max(dp[i], dp[i-1]+1);
        }
        maxRs = max(maxRs, dp[i]);
    }
    return maxRs;
}
```
## [718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

即是连续子序列
用二维数组，表示两个数组的状态
dp\[i]\[j] = 以i-1为结尾，j-1为尾的最长重复子数组的长度

注意dp数组的定义，以i-1为结尾，j-1为尾的最长重复子数组的长度，根据定义，递推公式仅为nums1[i-1] == nums2[j-1] 的时候，即此时两数组在以该位置结尾的值相等，此时因为要连续，所以新值会等于 以 nums1[i-2] 和   nums2[j-2] 结尾的重复子数组长度+1
例如 1 2 3  1 2 3
发现 2 = 2
前面 1 = 1 长度事1
2 =2 更新长度 = 2

请和[[#[1143. 最长公共子序列](https //leetcode.cn/problems/longest-common-subsequence/)]] 不连续做递推公式的对比
```c++
int findLength(vector<int>& nums1, vector<int>& nums2) {  
    // dp[i][j] 表示nums[i-1][nums][j-1]结尾的最长公共子序列长度  
    vector<vector<int>> dp(nums1.size()+1, vector<int>(nums2.size()+1, 0));  
    int maxRs = 0;  
    for(int i = 1; i < nums1.size()+1; i++) {  
        for(int j = 1; j < nums2.size()+1; j++) {  
            if (nums1[i-1] == nums2[j-1]) {  
                dp[i][j] = dp[i-1][j-1]+1;  
                maxRs = max(maxRs, dp[i][j]);  
            }  
        }  
    }  
    return maxRs;  
}
```


## [53. 最大子序和](https://leetcode.cn/problems/maximum-subarray/)
相同的数组套路，dp数组定义为以nums[i]结尾的dp[i]的最大值。这样子就可以通过上一个状态，转移到下一个状态->选或不选以上一个为结尾的数组
```c++
class Solution:  
    def maxSubArray(self, nums: List[int]) -> int:  
        dp = [0 for _ in range(len(nums))]  
        dp[0]  = nums[0]  
        maxV = nums[0]  
        for index in range(1,len(nums)):  
            dp[index] = max(dp[index-1]+nums[index],nums[index])  
            maxV = max(maxV,dp[index])  
        return maxV
```




# 区间DP

## [647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)

代码随想录的更加简洁，所以用代码随想录的。重点有2
1. dp数组的定义，定义为dp [i]  [j] 表示为从i到j的子字符串是不是回文的。通过这种方式向下一个状态转换
2. 递推公式，注意边界条件，只有一个字母和只有两个字母的情况。有了1和2，才可以通过+2递推所有数字
```python
class Solution:  
    def countSubstrings(self, s: str) -> int:  
        dp = [[False] * len(s) for _ in range(len(s))]  
        result = 0  
        for i in range(len(s)-1, -1, -1): #注意遍历顺序  
            for j in range(i, len(s)):  
                if s[i] == s[j]:  
                    if j - i <= 1: #情况一 和 情况二  
                        result += 1  
                        dp[i][j] = True  
                    elif dp[i+1][j-1]: #情况三  
                        result += 1  
                        dp[i][j] = True  
        return result
```
## [516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

dp的定义方式和回文字串的意义

```python
def longestPalindromeSubseq(self, s: str) -> int:  
    n = len(s)  
    dp = [[0]*n for _ in range(n)]  
    for i in range(n-1,-1,-1):  
        for j in range(i,n):  
            if s[i] == s[j]:  
                if j-i <= 1:  
                    dp[i][j] = j - i + 1  
                else:  
                    dp[i][j] = dp[i+1][j-1] + 2  
            else:  
                dp[i][j] = max(dp[i+1][j],dp[i][j-1])  
    return dp[0][n-1]
```

### 0x3f
递归的思路是选或不选，从两侧向内收缩，缩小问题规模
```python
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        @cache  # 缓存装饰器，避免重复计算 dfs 的结果（记忆化）
        def dfs(i: int, j: int) -> int:
            if i > j:
                return 0  # 空串
            if i == j:
                return 1  # 只有一个字母
            if s[i] == s[j]:
                return dfs(i + 1, j - 1) + 2  # 都选
            return max(dfs(i + 1, j), dfs(i, j - 1))  # 枚举哪个不选
        return dfs(0, len(s) - 1)
```


专成递推的时候需要注意，数据是从哪个方向得到的，

![[Pasted image 20250927225945.png|575]]

```python
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        n = len(s)
        f = [[0] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            f[i][i] = 1
            for j in range(i + 1, n):
                if s[i] == s[j]:
                    f[i][j] = f[i + 1][j - 1] + 2
                else:
                    f[i][j] = max(f[i + 1][j], f[i][j - 1])
        return f[0][-1]
```
## [1039. 多边形三角剖分的最低得分](https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/)
把问题先拆成一个三角形和其他多边形。然后递归解决。这里的递归函数应该选的是min
其实感觉就很暴力的解决问题
![[Pasted image 20250927230834.png|425]]

递归
```python
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        n = len(s)
        f = [[0] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            f[i][i] = 1
            for j in range(i + 1, n):
                if s[i] == s[j]:
                    f[i][j] = f[i + 1][j - 1] + 2
                else:
                    f[i][j] = max(f[i + 1][j], f[i][j - 1])
        return f[0][-1]
```

转成递推
i+2 和 n-3 这两个边界正是为了保证子多边形至少有 3 个顶点、才能形成一个三角形。

- 固定 i 后，j 必须从 **i+2** 开始，因为要保证 j - i ≥ 2，才能构成至少一个三角形。
- 如果 j = i+1，那只有两个顶点，没有三角形，得分没意义。
- 所以 j 不能小于 i+2，这就是起始点是 i+2 的原因。

j从i+2开始，为了不越界/形成三角形，i要从n-3开始
```python
class Solution:
    def minScoreTriangulation(self, v: List[int]) -> int:
        n = len(v)
        f = [[0] * n for _ in range(n)]
        for i in range(n - 3, -1, -1):
            for j in range(i + 2, n):
                f[i][j] = min(f[i][k] + f[k][j] + v[i] * v[j] * v[k]
                              for k in range(i + 1, j))
        return f[0][-1]
```
## [3040. 相同分数的最大操作数目 II](https://leetcode.cn/problems/maximum-number-of-operations-with-the-same-score-ii/)

直接翻译题目条件
```python
def maxOperations(self, nums: List[int]) -> int:  
    @cache  
    def dfs(i: int, j: int, target: int):  
        ii = 0  
        ij = 0  
        jj = 0  
        if i >= j or j - i <1:  
            return 0  
        if target == -1:  
            return max(dfs(i+1,j-1,nums[i]+nums[j]),dfs(i+2,j,nums[i]+nums[i+1]),dfs(i,j-2,nums[j]+nums[j-1])) + 1  
        else:  
            if nums[i]+nums[j] == target:  
                ij = dfs(i+1,j-1,nums[i]+nums[j]) + 1  
            if nums[i]+nums[i+1] == target:  
                ii = dfs(i+2,j,nums[i]+nums[i+1]) + 1  
            if nums[j]+nums[j-1] == target:  
                jj = dfs(i,j-2,nums[j]+nums[j-1]) + 1  
        return  max(ij,ii,jj)  
    return dfs(0,len(nums)-1,-1)
```


0x3f递推
不同的taregt分成多个二次数组来解决

和 dfs(i,j) 一样，定义 f[i][j] 表示当前剩余元素从 nums[i] 到 nums[j]，此时最多可以执行的操作次数。转移来源同方法一。

为避免出现 j=−1 的状态，需要把 f[i][j] 中的 j 加一（相当于在最左边插入一列），即 f[i][j+1] 表示当前剩余元素从 nums[i] 到 nums[j]，此时最多可以执行的操作次数。

如果记忆化搜索中的三个 `if` 都不成立，就不会继续递归，但递推需要计算所有状态。在随机数据下，**本题递推效率不如记忆化搜索**。
```python
class Solution:
    def maxOperations(self, nums: List[int]) -> int:
        def helper(start: int, end: int, target: int) -> int:
            max = lambda a, b: b if b > a else a  # 手写 max
            f = [[0] * (n + 1) for _ in range(n + 1)]
            for i in range(end - 1, start - 1, -1):
                for j in range(i + 1, end + 1):
                    res = 0
                    if nums[i] + nums[i + 1] == target:  # 删除前两个数
                        res = max(res, f[i + 2][j + 1] + 1)
                    if nums[j - 1] + nums[j] == target:  # 删除后两个数
                        res = max(res, f[i][j - 1] + 1)
                    if nums[i] + nums[j] == target:  # 删除第一个和最后一个数
                        res = max(res, f[i + 1][j] + 1)
                    f[i][j + 1] = res
            return f[start][end + 1]

        n = len(nums)
        res1 = helper(2, n - 1, nums[0] + nums[1])  # 删除前两个数
        res2 = helper(0, n - 3, nums[-2] + nums[-1])  # 删除后两个数
        res3 = helper(1, n - 2, nums[0] + nums[-1])  # 删除第一个和最后一个数
        return max(res1, res2, res3) + 1  # 加上第一次操作
```
## [1547. 切棍子的最小成本](https://leetcode.cn/problems/minimum-cost-to-cut-a-stick/)

0x3f的递推
```python
class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        cuts.sort()
        cuts = [0] + cuts + [n]

        @cache  # 缓存装饰器，避免重复计算 dfs 的结果（记忆化）
        def dfs(i: int, j: int) -> int:
            if i + 1 == j:  # 无需切割
                return 0
            # 枚举切割位置 cuts[k]
            return min(dfs(i, k) + dfs(k, j) for k in range(i + 1, j)) + cuts[j] - cuts[i]

        return dfs(0, len(cuts) - 1)
```

我的翻译成递归
![[Pasted image 20250928224128.png]]

顺序和之前同理
i从len(cuts)-3开始和j从i+2开始同三角形的理。 j = i+1是边界情况，不需要砍。最少也需要三个数字，所以j从i+2开始
```python
def minCost(self, n: int, cuts: List[int]) -> int:  
    cuts.sort()  
    cuts = [0] + cuts + [n]  
    dp = [[0] * len(cuts) for _ in range(len(cuts))]  
    for i in range(len(cuts)-3, -1, -1):  
        for j in range(i+2,len(cuts)):  
            dp[i][j] = min(dp[i][k]+dp[k][j] for k in range(i+1,j)) + cuts[j] - cuts[i]  
    return dp[0][len(cuts)-1]
```


## [1771. 由子序列构造的最长回文串的长度](https://leetcode.cn/problems/maximize-palindrome-length-from-subsequences/)


相比于[[#[516. 最长回文子序列](https //leetcode.cn/problems/longest-palindromic-subsequence/)]]
主要的问题是，word1和word2不能为空，不然直接拼起来，求最长回文串长度就好了。所以要保证得到的答案在两个word里面。


```python
class Solution:
    def longestPalindrome(self, word1: str, word2: str) -> int:
        s = word1 + word2
        ans, n = 0, len(s)
        f = [[0] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            f[i][i] = 1
            for j in range(i + 1, n):
                if s[i] == s[j]:
                    # 这里的 2 是 s[i] 和 s[j]，所以 f[i][j] 一定包含 s[i] 和 s[j]
                    f[i][j] = f[i + 1][j - 1] + 2
                    if i < len(word1) <= j:
                        ans = max(ans, f[i][j])
                else:
                    f[i][j] = max(f[i + 1][j], f[i][j - 1])
        return ans
```
## ==[1000. 合并石头的最低成本](https://leetcode.cn/problems/minimum-cost-to-merge-stones/)

自己看题解吧
```python
class Solution:
    def mergeStones(self, stones: List[int], k: int) -> int:
        n = len(stones)
        if (n - 1) % (k - 1):  # 无法合并成一堆
            return -1
        s = list(accumulate(stones, initial=0))  # 前缀和
        @cache  # 缓存装饰器，避免重复计算 dfs 的结果
        def dfs(i: int, j: int, p: int) -> int:
            if p == 1:  # 合并成一堆
                return 0 if i == j else dfs(i, j, k) + s[j + 1] - s[i]
            return min(dfs(i, m, 1) + dfs(m + 1, j, p - 1) for m in range(i, j, k - 1))
        return dfs(0, n - 1, 1)
```
# 树形DP-直径系列

## [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。



链：从子树中的叶子节点到当前节点的路径。把最长链的长度，作为 dfs 的返回值。根据这一定义，空节点的链长是 −1，叶子节点的链长是 0。
     
直径：等价于由两条（或者一条）链拼成的路径。我们枚举每个 node，假设直径在这里「拐弯」，也就是计算由左右两条从下面的叶子节点到 node 的链的节点值之和，去更新答案的最大值。
⚠注意：直径可能在下面的某个节点拐弯，不一定经过树根 root。

⚠注意：dfs 返回的是链的长度，不是直径的长度。如果返回直径，那么上面与其他的链继续拼接，得到的就不是直径了。

⚠注意：dfs 返回的是当前子树的最大链长（也可以理解为子树的高度），不包含当前节点和其父节点的这条边。

```python
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        ans = 0
        def dfs(node: Optional[TreeNode]) -> int:
            if node is None:
                return -1  # 对于叶子来说，链长就是 -1+1=0
            l_len = dfs(node.left) + 1  # 左子树最大链长+1
            r_len = dfs(node.right) + 1  # 右子树最大链长+1
            nonlocal ans
            ans = max(ans, l_len + r_len)  # 两条链拼成路径
            return max(l_len, r_len)  # 当前子树最大链长
        dfs(root)
        return ans
```

## [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

和上题一样，需要注意的就是子节点为负数可以不选
```python
def maxPathSum(self, root: Optional[TreeNode]) -> int:  
    self.res = 0  
    def dfs( root: Optional[TreeNode]) -> int:  
        if root == None:  
            return 0  
        left = dfs(root.left)  
        right = dfs(root.right)  
        self.res = max(self.res,left+right+root.val)  
        return max(0, root.val+right, root.val+left)  
    dfs(root)  
    return  self.res
```
## [2246. 相邻字符不同的最长路径](https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/)

需要注意，这里是求一个树而不是求一个二叉树。所以要找的是第一大和第二大的len。

问：如何理解代码中的 maxLen+len？为什么这一定可以遇到最大值+次大值的组合？

答：分类讨论。如果我们先遍历到最大值，再遍历到次大值，那么当 len 是次大值的时候，maxLen+len 就是最大值+次大值；如果我们先遍历到次大值，再遍历到最大值，那么当 len 是最大值的时候，maxLen 是次大值，maxLen+len 就是次大值+最大值。所以无论谁先谁后，一定可以遇到最大值+次大值的组合。

![[Pasted image 20250929221123.png]]

```python
class Solution:
    def longestPath(self, parent: List[int], s: str) -> int:
        n = len(parent)
        g = [[] for _ in range(n)]
        for i in range(1, n):
            g[parent[i]].append(i)

        ans = 0
        def dfs(x: int) -> int:
            nonlocal ans
            max_len = 0
            for y in g[x]:
                len = dfs(y) + 1
                if s[y] != s[x]:
                    ans = max(ans, max_len + len)
                    max_len = max(max_len, len)
            return max_len
        dfs(0)
        return ans + 1
```

## [1245. Tree Diameter](https://leetcode.com/problems/tree-diameter/)
一道会员题，树的直径。我在国际站有会员，0x3f说和[[#[2246. 相邻字符不同的最长路径](https //leetcode.cn/problems/longest-path-with-different-adjacent-characters/)]]很像，于是做一下

需要注意这道题没有给定根节点，所以要判断是否重复访问，且要双向都加入。并且这个是
```python
from typing import List

class Solution:
    def treeDiameter(self, edges: List[List[int]]) -> int:
        if not edges:
            return 0  # 只有一个点，直径为 0

        # 更稳妥：按标签算节点数（避免坏输入）
        n = max(max(a, b) for a, b in edges) + 1

        g = [[] for _ in range(n)]
        for a, b in edges:
            g[a].append(b)
            g[b].append(a)

        self.ans = 0

        def dfs(u: int, p: int) -> int:
            # 返回从 u 往下的最长链长
            top1 = 0  # 第一长的向下链
            top2 = 0  # 第二长的向下链
            for v in g[u]:
                if v == p:  # 避免回到父亲
                    continue
                d = dfs(v, u) + 1
                if d > top1:
                    top2 = top1
                    top1 = d
                elif d > top2:
                    top2 = d
            # 经过 u 的最长路径 = top1 + top2
            self.ans = max(self.ans, top1 + top2)
            return top1

        dfs(0, -1)
        return self.ans
```


## [687. 最长同值路径](https://leetcode.cn/problems/longest-univalue-path/)
做了前面的题，这道题就没有难度了
```python
class Solution:  
    def longestUnivaluePath(self, root: Optional[TreeNode]) -> int:  
        self.ans = 0  
        def dfs(root: Optional[TreeNode]) -> int:  
            if root == None:  
                return -1  
            left = dfs(root.left)+1  
            right = dfs(root.right)+1  
            maxLen = 0  
            ans_dfs = 0  
            if root.left and root.left.val == root.val:  
                maxLen = left  
                ans_dfs+=left  
            if root.right and root.right.val == root.val:  
                maxLen = max(maxLen,right)  
                ans_dfs+=right  
            self.ans = max(ans_dfs,self.ans)  
            return maxLen  
        dfs(root)  
        return self.ans
```

## [3203. 合并两棵树后的最小直径](https://leetcode.cn/problems/find-minimum-diameter-after-merging-two-trees/)

设 $d_1, d_2$ 分别为两棵树的直径长度。答案有三种情况：
1. **第一棵树的直径特别长**  
   那么连边后，新树的直径仍然为第一棵树的直径，答案为 $d_1$。
2. **第二棵树的直径特别长**  
   那么连边后，新树的直径仍然为第二棵树的直径，答案为 $d_2$。
3. **新树的直径经过添加的边**  
   假设我们连接了第一棵树的节点 $x_1$ 与第二棵树的节点 $x_2$，那么新树的直径相当于以下三部分之和：  
   - $x_1$ 到第一棵树最远点的距离。由直径的定义可知，选 $x_1$ 为第一棵树的直径中点，可以让该距离最小。  
   - $x_2$ 到第二棵树最远点的距离。由直径的定义可知，选 $x_2$ 为第二棵树的直径中点，可以让该距离最小。  
   - $x_1x_2$ 这条边的长度，即 1。  
   三部分之和即为新树的直径候选值。  

---
## 树的直径定义

树的直径是 **树中任意两点间的最大距离**。  
- 直径的两个端点是一对最远点。  
- 可通过“两次 BFS/DFS”快速求得：  
  1. 任意点出发找到最远点 A；  
  2. 从 A 出发找到最远点 B；  
  3. A 到 B 的距离就是直径。
---
## 为什么直径可能不变

- 当一棵树的直径特别长时，新直径有三种候选：  
  1. 保持为第一棵树的直径；  
  2. 保持为第二棵树的直径；  
  3. 跨树路径（= 两端到各自最远点的距离 + 1）。  
- 如果 $d_1$ 已经比跨树路径更长，那么不论如何连接，跨树路径的长度都不足以超过 $d_1$。  
- 因此新树的直径依然保持为第一棵树的直径。  

  

### 举例说明

- 树 A 的直径 $d_1 = 100$，树 B 的直径 $d_2 = 5$。  

- 跨树路径长度大约为 $\lceil d_1/2 \rceil + 1 + \lceil d_2/2 \rceil \approx 54$，明显小于 100。  

- 所以新树的直径仍为 100。  
---

可以看灵神的题解，还有对应的视频
```python
class Solution:
    def diameter(self, edges: List[List[int]]) -> int:
        g = [[] for _ in range(len(edges) + 1)]
        for x, y in edges:
            g[x].append(y)
            g[y].append(x)

        res = 0
        def dfs(x: int, fa: int) -> int:
            nonlocal res
            max_len = 0
            for y in g[x]:
                if y != fa:
                    sub_len = dfs(y, x) + 1
                    res = max(res, max_len + sub_len)
                    max_len = max(max_len, sub_len)
            return max_len
        dfs(0, -1)
        return res

    def minimumDiameterAfterMerge(self, edges1: List[List[int]], edges2: List[List[int]]) -> int:
        d1 = self.diameter(edges1)
        d2 = self.diameter(edges2)
        return max(d1, d2, (d1 + 1) // 2 + (d2 + 1) // 2 + 1)
```
## [1617. 统计子树中城市之间最大距离](https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/)

本题结合了 78 题和 1245 题：枚举城市的子集（子树），求这棵子树的直径。

需要注意的是，枚举的子集不一定是一棵树，可能是森林（多棵树，多个连通块）。我们可以在计算树形 DP 的同时去统计访问过的点，看看是否与子集相等，只有相等才是一棵树。

回溯套树的直径，时间复杂度较高

```python
class Solution:
    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:
        # 建立无向图（树的邻接表），节点编号改为从 0 开始
        g = [[] for _ in range(n)]
        for x, y in edges:
            g[x - 1].append(y - 1)
            g[y - 1].append(x - 1)

        # ans[i] 表示直径为 i+1 的子树数量
        ans = [0] * (n - 1)
        # in_set[i] = True 表示节点 i 被选入当前子集
        in_set = [False] * n

        # 回溯函数，枚举所有节点子集
        def f(i: int) -> None:
            if i == n:  # 所有节点都考虑完毕
                vis = [False] * n   # 标记访问情况
                diameter = 0        # 当前子树的直径

                # 找到子集中的第一个点，作为 DFS 的起点
                for v, b in enumerate(in_set):
                    if not b:
                        continue

                    # 在子集内 DFS，计算直径
                    def dfs(x: int) -> int:
                        nonlocal diameter
                        vis[x] = True
                        max_len = 0  # 从当前点往下的最长链长度

                        for y in g[x]:
                            # 只遍历还没访问过且在子集内的邻居
                            if not vis[y] and in_set[y]:
                                ml = dfs(y) + 1
                                # 更新直径：来自两个不同子树路径的拼接
                                diameter = max(diameter, max_len + ml)
                                # 更新当前节点的最大链长度
                                max_len = max(max_len, ml)
                        return max_len

                    dfs(v)  # 从 v 出发跑 DFS
                    break   # 只需要跑一次（因为如果是树的话能覆盖整个连通块）

                # 判断子集是否是一棵树
                # 条件：
                # 1. diameter > 0 （至少有一条边）
                # 2. vis == in_set （所有选入的节点都被访问到，保证连通）
                if diameter and vis == in_set:
                    ans[diameter - 1] += 1
                return
            
            # 回溯：两种情况
            # 1. 不选节点 i
            f(i + 1)

            # 2. 选节点 i
            in_set[i] = True
            f(i + 1)
            in_set[i] = False  # 恢复状态（回溯）
        
        # 从第 0 个节点开始枚举
        f(0)
        return ans
```

O(n\*2^n)


可以优化到O(n^3)

## [2538. 最大价值和与最小价值和的差值](https://leetcode.cn/problems/difference-between-maximum-and-minimum-price-sum/)

两条线路拼起来，一条是带上端点的线路，一条是没带上端点的线路

```python
class Solution:
    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:
        g = [[] for _ in range(n)]
        for x, y in edges:
            g[x].append(y)
            g[y].append(x)  # 建树

        ans = 0
        def dfs(x: int, fa: int) -> (int, int):
            nonlocal ans
            max_s1 = p = price[x]
            max_s2 = 0
            for y in g[x]:
                if y == fa: continue
                s1, s2 = dfs(y, x)
                # 前面最大带叶子的路径和 + 当前不带叶子的路径和
                # 前面最大不带叶子的路径和 + 当前带叶子的路径和
                ans = max(ans, max_s1 + s2, max_s2 + s1)
                max_s1 = max(max_s1, s1 + p)
                max_s2 = max(max_s2, s2 + p)  # 这里加上 p 是因为 x 必然不是叶子
            return max_s1, max_s2
        dfs(0, -1)
        return ans
```
# 树形DP-最大独立集
## [337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)
[[#[337. 打家劫舍 III](https //leetcode.cn/problems/house-robber-iii/)]]


返回两个值，一个是选一个是不选

```python
class Solution:
    def rob(self, root: Optional[TreeNode]) -> int:
        def dfs(node: Optional[TreeNode]) -> Tuple[int, int]:
            if node is None:  # 递归边界
                return 0, 0  # 没有节点，怎么选都是 0
            l_rob, l_not_rob = dfs(node.left)  # 递归左子树
            r_rob, r_not_rob = dfs(node.right)  # 递归右子树
            rob = l_not_rob + r_not_rob + node.val  # 选
            not_rob = max(l_rob, l_not_rob) + max(r_rob, r_not_rob)  # 不选
            return rob, not_rob
        return max(dfs(root))  # 根节点选或不选的最大值
```
## [1377. T 秒后青蛙的位置](https://leetcode.cn/problems/frog-position-after-t-seconds/)

注意一下edge case，一开始的点root没有父节点的情况
```python
class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        # 构建邻接表表示无向图（节点编号从 0 开始）
        self.g = [[] for _ in range(n)]
        for p, c in edges:
            # 因为题目节点编号从 1 开始，这里要减 1
            self.g[p - 1].append(c - 1)
            self.g[c - 1].append(p - 1)

        # 深度优先搜索函数
        # root 当前节点
        # p    父节点（避免回到父节点）
        # t    剩余时间（跳跃次数）
        def dfs(root: int, p: int, t: int) -> float:
            if t < 0:
                # 时间用完还没到目标，返回 0 概率
                return 0
            
            # 如果当前节点就是目标节点
            # ❗此处错误：应当只在时间耗尽或该节点无法再跳时返回 1
            if root + 1 == target:
                return 1

            # 遍历当前节点的所有相邻节点
            for i in self.g[root]:
                if i == p:
                    # 跳过父节点，避免死循环
                    continue

                # 向下递归
                ret = dfs(i, root, t - 1)

                if ret != 0:
                    # 返回时乘以概率
                    # ❗这里错误：根节点时不能减 1，因为没有父节点
                    return ret * 1 / (len(self.g[root]) - 1)
            
            # 所有分支都不通，返回 0
            return 0

        # 从节点 0（即编号 1）开始，父节点设为 -1，初始时间 t
        return dfs(0, -1, t)
```

## [2646. 最小化旅行的价格总和](https://leetcode.cn/problems/minimize-the-total-price-of-the-trips/)

**方法一：暴力 DFS 每条路径**
==这是一棵树，从start到end有且只有一条路径==
对每个 trips[i] 都 DFS 一次这棵树，在 DFS 的过程中，把从 start 到 end 的路径上的每个点 x 的经过次数 cnt[x] 都加一。

既然知道了每个节点会经过多少次，把 price[i] 更新成 price[i] * cnt[i]，问题就转换成计算减半后的 price[i] 之和的最小值。

注意 cnt[i] = 0 时 price[i] 会被更新成 0，我们无需考虑没有经过的节点。

我们随便选一个节点出发 DFS（比如节点 0）。在 DFS 的过程中，对于节点 x 及其儿子 y，分类讨论：

- 如果 price[x] 不变，那么 price[y] 可以减半，也可以不变，取这两种情况的最小值；
    
- 如果 price[x] 减半，那么 price[y] 只能不变。
  

因此子树 x 需要返回两个值：

- price[x] 不变时的子树 x 的最小价值总和；
    
- price[x] 减半时的子树 x 的最小价值总和。
  

答案就是根节点不变/减半的最小值。


答疑
问：代码实现时，如何找到从 start 到 end 的路径？

答：以 start 为树根 DFS，找到 end 时，end 及其祖先节点就恰好组成了从 start 到 end 的路径。据此可以在递归的「归」当中去更新 cnt。


```python
class Solution:
    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:
        g = [[] for _ in range(n)]
        for x, y in edges:
            g[x].append(y)
            g[y].append(x)

        cnt = [0] * n
        for start, end in trips:
            def dfs(x: int, fa: int) -> bool:
                if x == end:
                    cnt[x] += 1
                    return True  # 找到 end
                for y in g[x]:
                    if y != fa and dfs(y, x):
                        cnt[x] += 1  # x 是 end 的祖先节点，也就在路径上
                        return True
                return False  # 未找到 end
            dfs(start, -1)

        # 类似 337. 打家劫舍 III
        def dfs(x: int, fa: int) -> (int, int):
            not_halve = price[x] * cnt[x]  # x 不变
            halve = not_halve // 2  # x 减半
            for y in g[x]:
                if y != fa:
                    nh, h = dfs(y, x)  # 计算 y 不变/减半的最小价值总和
                    not_halve += min(nh, h)  # x 不变，那么 y 可以不变或者减半，取这两种情况的最小值
                    halve += nh  # x 减半，那么 y 只能不变
            return not_halve, halve
        return min(dfs(0, -1))
```
# 树形 DP - 最小支配集
## [968. 监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/)

![[Pasted image 20251004235157.png]]

一共有三种状态：
1. 自己监控自己
2. 被儿子监控自己
3. 被父亲监控自己
分别计算这三种情况下，遍历到当前节点，需要的监控数量。
比如choose的情况，儿子的三种可能都有，所以要都min。但通过灵神的数学计算，可以忽略一些情况

这个式子说明，红色一定大于等于黄色
![[Pasted image 20251004235110.png]]
```python
class Solution:
    def minCameraCover(self, root: Optional[TreeNode]) -> int:
        def dfs(node):
            if node is None:
                return inf, 0, 0  # 空节点不能安装摄像头，也无需被监控到
            l_choose, l_by_fa, l_by_children = dfs(node.left)
            r_choose, r_by_fa, r_by_children = dfs(node.right)
            choose = min(l_choose, l_by_fa) + min(r_choose, r_by_fa) + 1
            by_fa = min(l_choose, l_by_children) + min(r_choose, r_by_children)
            by_children = min(l_choose + r_by_children, l_by_children + r_choose, l_choose + r_choose)
            return choose, by_fa, by_children
        choose, _, by_children = dfs(root)  # 根节点没有父节点
        return min(choose, by_children)
```





# 左链接
[[动态规划的模型总结]]
[[在动态规划中, 贪心是个什么地位]]
