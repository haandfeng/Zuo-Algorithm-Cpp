#0x3f #动态规划 #DP #树型dp 
状态定义，状态转移方程
当前操作？
子问题？
下一个子问题？
1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

# 动态规划 - 从记忆化搜索到递推

## [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)
[[斐波那契数列]]
1. 确定dp数组以及下标的含义
	dp[i]的定义为：第i个数的斐波那契数值是dp[i]
2. 确定递推公式
	题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2]
3. dp数组如何初始化
	dp[0] = 0    dp[1] = 1
4. 确定遍历顺序
	从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的
5. 举例推导dp数组
	按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：
	0 1 1 2 3 5 8 13 21 34 55

```c++
class Solution {
public:
    int fib(int N) {
        if (N <= 1) return N;
        vector<int> dp(N + 1);
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= N; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[N];
    }
};
```

**题目中把如何初始化也直接给我们了，如下：**

## [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)
[[爬楼梯]]
1. 确定dp数组以及下标的含义
	dp[i]的定义为：第i个台阶可能的方法数量是dp[i]
2. 确定递推公式
	dp[i] = dp[i-1]+dp[i-2]
3. dp数组如何初始化
	dp[1] = 1    dp[2] = 2
4. 确定遍历顺序
	从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的
5. 举例推导dp数组
	按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：
	 1 2 3 5 8 13 21 34 55
```c++
int climbStairs(int n) {  
    if (n == 1) return 1;  
    if (n == 2) return 2;  
    int f1=1,f2=2;  
    for(int i=3;i<=n;i++) {  
        int tmp = f1+f2;  
        f1=f2;  
        f2=tmp;  
    }  
    return f2;  
}
```

## [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)
1. 确定dp数组以及下标的含义
	dp[i]的定义为：爬到第i个台阶需要的最低费用是
2. 确定递推公式
	dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])
3. dp数组如何初始化
	dp[0] = 0    dp[1] = 0
4. 确定遍历顺序
	从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的
5. 举例推导dp数组
	按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]

```c++
  
int minCostClimbingStairs(vector<int>& cost) {  
    vector<int> dp(cost.size()+1, 0);  
    dp[0] = 0, dp[1] = 0;  
    for (int i = 2; i < cost.size()+1; i++) {  
        dp[i] = min(dp[i-1] + cost[i-1], dp[i-2]+cost[i-2]);  
    }  
    return dp[cost.size()];  
}
```
我觉得有点类似于打家劫舍，走哪一步，算上某一步的cost
```python
def minCostClimbingStairs2(self, cost: List[int]) -> int:  
    dp = [0] *(len(cost)+1)  
    for i in range (2,len(cost)+1):  
        dp[i] =  min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])  
    return dp[len(cost)]
```
## [2466. 统计构造好字符串的方案数](https://leetcode.cn/problems/count-ways-to-build-good-strings/)
都是选or不选的问题
和爬楼梯思路差不多，第一不过是之前只能爬1和2，这里是 one 和zero阶梯

```java
class Solution {
    public int countGoodStrings(int low, int high, int zero, int one) {
        final int MOD = 1_000_000_007;
        int ans = 0;
        int[] f = new int[high + 1]; // f[i] 表示构造长为 i 的字符串的方案数
        f[0] = 1; // 构造空串的方案数为 1
        for (int i = 1; i <= high; i++) {
            if (i >= zero) f[i] = f[i - zero];
            if (i >= one)  f[i] = (f[i] + f[i - one]) % MOD;
            if (i >= low)  ans = (ans + f[i]) % MOD;
        }
        return ans;
    }
}
```


```python
class Solution:
    def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:
        MOD = 1_000_000_007
        @cache  # 缓存装饰器，避免重复计算 dfs 的结果（记忆化）
        def dfs(i: int) -> int:
            if i < 0:
                return 0
            if i == 0:
                return 1
            # 提前取模，不然结果会是天文数字，没有那么多空间存得下来
            return (dfs(i - zero) + dfs(i - one)) % MOD
        return sum(dfs(i) for i in range(low, high + 1)) % MOD
```
## [2266. 统计打字方案数](https://leetcode.cn/problems/count-number-of-texts/)
本质上是  [[#[70. 爬楼梯](https //leetcode.cn/problems/climbing-stairs/)|爬楼梯]]，每次可以跳 1 到 3 或者 1 到 4 个台阶，计算跳 cnt 个台阶的方案数。其中 cnt 表示连续相同子串的长度。

对于字符不为 7 或 9 的情况，定义一个类似爬楼梯的 DP，即 f[i] 表示长为 i 的只有一种字符的字符串所对应的文字信息种类数，我们可以将末尾的 1 个、2 个或 3 个字符变成一个字母，那么问题变成长为 i−1,i−2,i−3 的只有一种字符的字符串所对应的文字信息种类数，即

f[i]=f[i−1]+f[i−2]+f[i−3]
其中加法是因为三种方案互斥，根据加法原理相加。

对于字符为 7 或 9 的情况，定义 g[i] 表示长为 i 的只有一种字符的字符串对应的文字信息种类数，可以得到类似的转移方程

g[i]=g[i−1]+g[i−2]+g[i−3]+g[i−4]
由于各个组（连续相同子串）的打字方案互相独立，根据乘法原理，把各个组的方案数相乘，即为答案。

```java
class Solution {
    private static final int MOD = 1_000_000_007;
    private static final int MX = 100_001;
    private static final long[] f = new long[MX];
    private static final long[] g = new long[MX];

    static {
        f[0] = g[0] = 1;
        f[1] = g[1] = 1;
        f[2] = g[2] = 2;
        f[3] = g[3] = 4;
        for (int i = 4; i < MX; i++) {
            f[i] = (f[i - 1] + f[i - 2] + f[i - 3]) % MOD;
            g[i] = (g[i - 1] + g[i - 2] + g[i - 3] + g[i - 4]) % MOD;
        }
    }

    public int countTexts(String s) {
        long ans = 1;
        int cnt = 0;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            cnt++;
            if (i == s.length() - 1 || c != s.charAt(i + 1)) {
                ans = ans * (c != '7' && c != '9' ? f[cnt] : g[cnt]) % MOD;
                cnt = 0;
            }
        }
        return (int) ans;
    }
}
```


```python
MOD = 1_000_000_007  
f = [1, 1, 2, 4]  
g = [1, 1, 2, 4]  
for _ in range(10 ** 5 - 3):  # 预处理所有长度的结果  
    f.append((f[-1] + f[-2] + f[-3]) % MOD)  
    g.append((g[-1] + g[-2] + g[-3] + g[-4]) % MOD)  
  
class Solution:  
    def countTexts(self, pressedKeys: str) -> int:  
        ans = 1  
        for ch, s in groupby(pressedKeys):  
            m = len(list(s))  
            ans = ans * (g[m] if ch in "79" else f[m]) % MOD  
        return ans
```

## [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)
[[矩阵中的最小路径和]]
和[[#[62. 不同路径](https //leetcode.cn/problems/unique-paths/)|不同路径]]一样的思路
```java
public int minPathSum(int[][] grid) {  
    int [][] dp = new int[grid.length][grid[0].length];  
    dp[0][0] = grid[0][0];  
    for (int i = 1; i < grid.length; i++) {  
        dp[i][0] = dp[i-1][0] + grid[i][0];  
    }  
    for(int j = 1; j < grid[0].length; j++) {  
        dp[0][j] = dp[0][j-1] + grid[0][j];  
    }  
    for (int i = 1; i < grid.length; i++) {  
        for (int j = 1; j < grid[i].length; j++) {  
            dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];  
        }  
    }  
    return dp[grid.length-1][grid[0].length-1];  
}
```
思考过程：
怎么把一个大问题变成小问题？
![[Pasted image 20250921175132.png|450]]
dfs(i,j)=min(dfs(i,j−1),dfs(i−1,j))+grid\[i]\[j]
注意递归边界的选择
递归边界：
dfs(−1,j)=dfs(i,−1)=∞。用 ∞ 表示不合法（出界）的状态，从而保证 min 不会取到不合法的状态。
dfs(0,0)=grid\[0]\[0]。
递归入口：dfs(m−1,n−1)，这是原问题，也是答案。
```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        @cache  # 缓存装饰器，避免重复计算 dfs 的结果（记忆化）
        def dfs(i: int, j: int) -> int:
            if i < 0 or j < 0:
                return inf
            if i == 0 and j == 0:
                return grid[i][j]
            return min(dfs(i, j - 1), dfs(i - 1, j)) + grid[i][j]
        return dfs(len(grid) - 1, len(grid[0]) - 1)
```
## [62. 不同路径](https://leetcode.cn/problems/unique-paths/)
[[不同路径]]
1. 确定dp数组以及下标的含义
	dp\[i]\[j]的定义为：走到ij的位置需要多少步
2. 确定递推公式
	dp\[i]\[j] = d\[ i-1 ]  \[ j ] + d\[ i  ] \[ j - 1  ]
3. dp数组如何初始化
	横为1，纵向为1
4. 确定遍历顺序
	 两个for循环嵌套，先哪个后哪个都行
5. 举例推导dp数组
	懒了 

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int j = 0; j < n; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```
## [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)
1. 确定dp数组以及下标的含义
	dp\[i]\[j]的定义为：走到ij的位置需要多少步
2. 确定递推公式
	看代码，我写得很复杂
3. dp数组如何初始化
	横为1，纵向为1
4. 确定遍历顺序
	 两个for循环嵌套，先哪个后哪个都行
5. 举例推导dp数组
	懒了 

```c++
class Solution {  
public:  
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {  
        int m = obstacleGrid.size();  
        int n = obstacleGrid[0].size();  
        if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) //如果在起点或终点出现了障碍，直接返回0  
            return 0;  
        vector<vector<int>> dp(m, vector<int>(n, 0)); 
        //一旦遇到障碍就不走了 
        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;  
        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;  
        for (int i = 1; i < m; i++) {  
            for (int j = 1; j < n; j++) {  
                if (obstacleGrid[i][j] == 1) continue;  
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];  
            }  
        }  
        return dp[m - 1][n - 1];  
    }  
};
```
## [343. 整数拆分](https://leetcode.cn/problems/integer-break/)
[[整数拆分]]
1. 确定dp数组（dp table）以及下标的含义
	dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。
2. 确定递推公式
	可以想 dp[i]最大乘积是怎么得到的呢？
	其实可以从1遍历j，然后有两种渠道得到dp[i].
	一个是j * (i - j) 直接相乘。
	一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义
3. 初始化
	只初始化dp[2] = 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是
4. 遍历顺序
	确定遍历顺序，先来看看递归公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
	dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。

```c++
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1);
        dp[2] = 1;
        for (int i = 3; i <= n ; i++) {
            for (int j = 1; j <= i / 2; j++) {
                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
            }
        }
        return dp[n];
    }
};
```
## [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)
[[不同的二叉搜索树]]
1. 确定dp数组（dp table）以及下标的含义
	**dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]**。
2. 递推公式
	在上面的分析中，其实已经看出其递推关系， dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]  
	j相当于是头结点的元素，从1遍历到i为止。
	所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量
3. dp数组如何初始化
	初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。
	从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，这是可以说得通的。
	从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。
	所以初始化dp[0] = 1
4. 遍历顺序
	就那样


```c++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
};
```

# 0-1背包 完全背包 至多/恰好/至少
![[Pasted image 20250228234246.png]]
具体背包逻辑请参考代码随想录[0-1背包理论基础1](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)
[0-1背包理论基础2](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html)
## [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)
把它理解成背包问题，背包容量为整个子集的和/2

判断最终装满背包的物品价值 是否等于 整个子集的和/2就好了

```java
public boolean canPartition(int[] nums) {  
    if(nums == null || nums.length == 0) return false;  
    int n = nums.length;  
    int sum = 0;  
    for(int num : nums) {  
        sum += num;  
    }  
    //总和为奇数，不能平分  
    if(sum % 2 != 0) return false;  
    int target = sum / 2;  
    int[] dp = new int[target + 1];  
    for(int i = 0; i < n; i++) {  
        // j的容量要比nums[i]大  
        for(int j = target; j >= nums[i]; j--) {  
            //物品 i 的重量是 nums[i]，其价值也是 nums[i]            
            dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);  
        }  
  
        //剪枝一下，每一次完成內層的for-loop，立即檢查是否dp[target] == target，優化時間複雜度（26ms -> 20ms）  
        if(dp[target] == target)  
            return true;  
    }  
    return dp[target] == target;  
}
```
## [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)
本题其实是尽量让石头分成重量相同的两堆（尽可能相同），相撞之后剩下的石头就是最小的。

一堆的石头重量是sum，那么我们就尽可能拼成 重量为 sum / 2 的石头堆。 这样剩下的石头堆也是 尽可能接近 sum/2 的重量。 那么此时问题就是有一堆石头，每个石头都有自己的重量，是否可以 装满 最大重量为 sum / 2的背包。

看到这里，大家是否感觉和昨天讲解的[[#[416. 分割等和子集](https //leetcode.cn/problems/partition-equal-subset-sum/)|416. 分割等和子集]] 非常像了，简直就是同一道题。
```java
    public int lastStoneWeightII(int[] stones) {
        if(stones == null || stones.length == 0) return 0;
        int sum = 0;
        for(int stone : stones) {
            sum += stone;
        }
        int tagret = sum / 2;
        int[] dp = new int[tagret + 1];
        Arrays.fill(dp, 0);
        for(int i = 0; i < stones.length; i++) {
            for(int j = tagret; j >= stones[i]; j--) {
                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        return sum-2*dp[tagret];

    }
```


## [494. 目标和](https://leetcode.cn/problems/target-sum/)
加法一个集合p，减法一个集合s-p
p - (s-p) = target
2p = target+s
p = (target+s ) /2

可以定义DP数组为装满容量J的背包有DP[J]中方法


递推公式
以上过程，抽象化如下：
- **不放物品i**：即背包容量为j，里面不放物品i，装满有dp\[i - 1]\[j]中方法。
- **放物品i**： 即：先空出物品i的容量，背包容量为（j - 物品i容量），放满背包有 dp\[i - 1]\[j - 物品i容量] 种方法。
    
本题中，物品i的容量是nums[i]，价值也是nums[i]。

递推公式：dp\[i]\[j] = dp\[i - 1]\[j] + dp\[i - 1]\[j - nums\[i]];

考到这个递推公式，我们应该注意到，`j - nums[i]` 作为数组下标，如果 `j - nums[i]` 小于零呢？

说明背包容量装不下 物品i，所以此时装满背包的方法值 等于 不放物品i的装满背包的方法，即：dp\[i]\[j] = dp\[i - 1]\[j];

所以递推公式：
```c++
if (nums[i] > j) dp[i][j] = dp[i - 1][j]; 
else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];
```


最后代码
```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if (abs(target) > sum) return 0; // 此时没有方案
        if ((target + sum) % 2 == 1) return 0; // 此时没有方案
        int bagSize = (target + sum) / 2;
        vector<int> dp(bagSize + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < nums.size(); i++) {
            for (int j = bagSize; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]]; //选dp[j - nums[i]]把i装进袋子里，dp[j]不把i装进袋子里
            }
        }
        return dp[bagSize];
    }
};
```
## [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)

背包容量变成二维的，背包的定义变成是dp\[i]\[j] 的最大子集数量

递推公式就是 等于 装/不装这个物品 = max(dp\[i]\[j] , dp\[i-x]\[j-y]+1)

```c++
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0)); // 默认初始化0
        for (string str : strs) { // 遍历物品
            int oneNum = 0, zeroNum = 0;
            for (char c : str) {
                if (c == '0') zeroNum++;
                else oneNum++;
            }
            for (int i = m; i >= zeroNum; i--) { // 遍历背包容量且从后向前遍历！
                for (int j = n; j >= oneNum; j--) {
                    dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
                }
            }
        }
        return dp[m][n];
    }
};
```


## [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)
最少用多少种物品 
1. 确定dp数组以及下标的含义
	**dp[j]：凑足总额为j所需钱币的最少个数为dp[j]**
2. 确定递推公式
	凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）
	
	所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。
	
	递推公式：dp[j] = min(dp[j - coins[i]] + 1, dp[j]);

3. dp数组如何初始化

	首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0;
	
	其他下标对应的数值呢？
	
	考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。
	
	所以下标非0的元素都是应该是最大值。
1. 确定遍历顺序
2. 
	本题求钱币最小个数，**那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数**。
	
	所以本题并不强调集合是组合还是排列。
	
	**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。
	
	**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。
	
	在动态规划专题我们讲过了求组合数是[动态规划：518.零钱兑换II (opens new window)](https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html)，求排列数是[动态规划：377. 组合总和 Ⅳ (opens new window)](https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html)。
	
	**所以本题的两个for循环的关系是：外层for循环遍历物品，内层for遍历背包或者外层for遍历背包，内层for循环遍历物品都是可以的！**
	
	那么我采用coins放在外循环，target在内循环的方式。
	
	本题钱币数量可以无限使用，那么是完全背包。所以遍历的内循环是正序
	
	综上所述，遍历顺序为：coins（物品）放在外循环，target（背包）在内循环。且内循环正序。

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i < coins.size(); i++) { // 遍历物品
            for (int j = coins[i]; j <= amount; j++) { // 遍历背包
                if (dp[j - coins[i]] != INT_MAX) { // 如果dp[j - coins[i]]是初始值则跳过，因为在那个值里面，没有数量有效
                    dp[j] = min(dp[j - coins[i]] + 1, dp[j]);
                }
            }
        }
        if (dp[amount] == INT_MAX) return -1;
        return dp[amount];
    }
};
```
## [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)
[[组合总和 Ⅳ]]
dp数组含义，dp[i]表示i的值有dp[i]个可能
dp[2]= dp[1] + dp[0
dp[3] =  dp[0] +
.....

每次从 nums 中选一个数，作为往上爬的台阶数，计算爬 target 个台阶有多少种方案。70 那题相当于 nums=[1,2]，因为每次只能爬 1 个或 2 个台阶。

```java
class Solution {  
    public int combinationSum4(int[] nums, int target) {  
        int[] f = new int[target + 1];  
        f[0] = 1;  
        for (int i = 1; i <= target; i++) {  
            for (int x : nums) {  
                if (x <= i) {  
                    f[i] += f[i - x];  
                }  
            }  
        }  
        return f[target];  
    }  
}
```


回溯法
我觉得用回溯法想出来并不好解释。主要是递归边界的解释
```python
def combinationSum4(self, nums: List[int], target: int) -> int:  
    @cache  
    def dfs(i:int)->int:  
        res = 0  
        if i == 0:  
            return 1  
        for num in nums:  
            if num <= i:  
                res+=dfs(i-num)  
        return res  
    return dfs(target)
```
## [57. 爬楼梯_卡码](https://kamacoder.com/problempage.php?pid=1067)

可能有点难
## [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)

可以取无限次，是完全背包

我上面有说过，本题和 [494. 目标和 (opens new window)](https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html)是一样的，唯一区别就是 [494. 目标和 (opens new window)](https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html)是 01背包，本题是完全背包。

在[494. 目标和 (opens new window)](https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html)中详解讲解了装满背包有几种方法，二维DP数组的递推公式： `dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]`

所以本题递推公式：`dp[i][j] = dp[i - 1][j] + dp[i][j - nums[i]]` ，区别依然是 `dp[i - 1][j - nums[i]]` 和 `dp[i][j - nums[i]]`


二维dp数组
以amount为5，coins为：[2,3,5] 为例：

dp数组应该是这样的：
```sh
1 0 1 0 1 0
1 0 1 1 1 1
1 0 1 1 1 2
```
代码：
```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int bagSize = amount;

        vector<vector<uint64_t>> dp(coins.size(), vector<uint64_t>(bagSize + 1, 0));

        // 初始化最上行
        for (int j = 0; j <= bagSize; j++) {
            if (j % coins[0] == 0) dp[0][j] = 1;
        }
        // 初始化最左列
        for (int i = 0; i < coins.size(); i++) {
            dp[i][0] = 1;
        }
        // 以下遍历顺序行列可以颠倒
        for (int i = 1; i < coins.size(); i++) { // 行，遍历物品
            for (int j = 0; j <= bagSize; j++) { // 列，遍历背包
                if (coins[i] > j) dp[i][j] = dp[i - 1][j]; 
                else dp[i][j] = dp[i - 1][j] +  dp[i][j - coins[i]];
            }
        }
        return dp[coins.size() - 1][bagSize];
    }
};
```




```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<uint64_t> dp(amount + 1, 0); // 防止相加数据超int
        dp[0] = 1; // 只有一种方式达到0
        for (int i = 0; i < coins.size(); i++) { // 遍历物品
            for (int j = coins[i]; j <= amount; j++) { // 遍历背包
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount]; // 返回组合数
    }
};
```



### 排列和组合的区别的示例代码

```c++
#include <iostream>  
#include <vector>  
using namespace std;  
  
void combinationDP(int amount, vector<int>& coins) {  
    vector<uint64_t> dp(amount + 1, 0);  
    dp[0] = 1;  
    cout << "\n[组合数写法] 不考虑顺序:\n";  
    for (int i = 0; i < coins.size(); ++i) {  
        for (int j = coins[i]; j <= amount; ++j) {  
            dp[j] += dp[j - coins[i]];  
        }  
        cout <<"组合数";  
        for (int j : dp) {  
            cout << j << " ";  
        }  
        cout << endl;  
    }  
  
  
    cout << "\n[组合数写法] 不考虑顺序:\n";  
    cout << "dp: ";  
    for (int i = 0; i <= amount; ++i) cout << dp[i] << " ";  
    cout << "\nTotal combinations: " << dp[amount] << endl;  
}  
  
void permutationDP(int amount, vector<int>& coins) {  
    vector<uint64_t> dp(amount + 1, 0);  
    dp[0] = 1;  
    for (int j = 1; j <= amount; ++j) {  
        for (int i = 0; i < coins.size(); ++i) {  
            if (j - coins[i] >= 0)  
                dp[j] += dp[j - coins[i]];  
        }  
        cout <<"排列数";  
        for (int j : dp) {  
            cout << j << " ";  
        }  
        cout << endl;  
    }  
  
    cout << "\n[排列数写法] 考虑顺序:\n";  
    cout << "dp: ";  
    for (int i = 0; i <= amount; ++i) cout << dp[i] << " ";  
    cout << "\nTotal permutations: " << dp[amount] << endl;  
}  
  
int main() {  
    int amount, n;  
    cout << "Enter target amount: ";  
    cin >> amount;  
  
    cout << "Enter number of coin types: ";  
    cin >> n;  
  
    vector<int> coins(n);  
    cout << "Enter coin values: ";  
    for (int i = 0; i < n; ++i) cin >> coins[i];  
  
    combinationDP(amount, coins);  
    permutationDP(amount, coins);  
  
    return 0;  
}
```

输出: 
可以看到组合数的方法，是看左边+原来上面的值，相加，得到结果。 例如容量等于3
存在     硬币1: 1+1+1 一种。硬币1和2  1+2 和  1+1+1 一共两种

排列的方法，可以看到，他其实是按列更新的，然后根据列计算结果。例如容量3
会存在3 = 1 +2种情况，分别是
硬币1: 2种 => 1 +1 (原来的2里面的一种)+1，   2(原来的2里面的一种)+1   按照顺序就是 1 1 1 和  2 1
硬币2: 一种 => 2(原来的1的里面一种）+1    按照顺序就是：1 2
```sh
Enter target amount: 4
Enter number of coin types: 2
Enter coin values: 1 2

[组合数写法] 不考虑顺序:
组合数1 1 1 1 1 
组合数1 1 2 2 3 

[组合数写法] 不考虑顺序:
dp: 1 1 2 2 3 
Total combinations: 3
排列数1 1 0 0 0 
排列数1 1 2 0 0 
排列数1 1 2 3 0 
排列数1 1 2 3 5 

[排列数写法] 考虑顺序:
dp: 1 1 2 3 5 
Total permutations: 5
```
## ==[2915. 和为目标值的最长子序列的长度](https://leetcode.cn/problems/length-of-the-longest-subsequence-that-sums-to-target/)==

## [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

硬币数量要自己写出来，然后注意初始化方法，和零钱很像
```c++
int numSquares(int n) {  
    vector<int> dp(n+1, INT_MAX);  
    vector<int> nums;  
    dp[0] = 0;  
    int i = 1;  
    while (i*i <= n) {  
        dp[i*i] =1;  
        nums.push_back(i*i);  
        ++i;  
    }  
    for (int i = 0; i < nums.size(); i++) {  
        for (int j = nums[i] +1; j <= n; j++) {  
            if (dp[j - nums[i]] != INT_MAX) {  
                dp[j] = min (dp[j], dp[j - nums[i]] +1);  
            }  
        }  
    }  
    return dp[n];  
}
```

## [139. 单词拆分](https://leetcode.cn/problems/word-break/)
动规五部曲分析如下：

1. 确定dp数组以及下标的含义

	**dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词**。

2. 确定递推公式

	如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j < i ）。
	
	所以递推公式是 if([j, i] 这个区间的子串出现在字典里 && dp[j]是true) 那么 dp[i] = true。

3. dp数组如何初始化

	从递推公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递推的根基，dp[0]一定要为true，否则递推下去后面都都是false了。

	那么dp[0]有没有意义呢？

	dp[0]表示如果字符串为空的话，说明出现在字典里。
	
	但题目中说了“给定一个非空字符串 s” 所以测试数据中不会出现i为0的情况，那么dp[0]初始为true完全就是为了推导公式。
	
	下标非0的dp[i]初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。

4. 确定遍历顺序

	题目中说是拆分为一个或多个在字典中出现的单词，所以这是完全背包。
	
	还要讨论两层for循环的前后顺序。
	
	**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。
	
	**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。
	
	我在这里做一个总结：
	
	求组合数：[动态规划：518.零钱兑换II (opens new window)](https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html)求排列数：[动态规划：377. 组合总和 Ⅳ (opens new window)](https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html)、[动态规划：70. 爬楼梯进阶版（完全背包） (opens new window)](https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html)求最小数：[动态规划：322. 零钱兑换 (opens new window)](https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html)、[动态规划：279.完全平方数(opens new window)](https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html)
	
	而本题其实我们求的是排列数，为什么呢。 拿 s = "applepenapple", wordDict = ["apple", "pen"] 举例。
	
	"apple", "pen" 是物品，那么我们要求 物品的组合一定是 "apple" + "pen" + "apple" 才能组成 "applepenapple"。
	
	"apple" + "apple" + "pen" 或者 "pen" + "apple" + "apple" 是不可以的，那么我们就是强调物品之间顺序。
	
	所以说，本题一定是 先遍历 背包，再遍历物品。
```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for (int i = 1; i <= s.size(); i++) {   // 遍历背包
            for (int j = 0; j < i; j++) {       // 遍历物品
                string word = s.substr(j, i - j); //substr(起始位置，截取的个数)
                if (wordSet.find(word) != wordSet.end() && dp[j]) {
                    dp[i] = true;
                }
            }
        }
        return dp[s.size()];
    }
};
```

# 打家劫舍系列问题

## [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)
[[打家劫舍]] [[打家劫舍系列问题]]
当前操作？ 
	枚举***第*** i个房子选/不选
子问题？ 
	从***前*** i个房子中得到的最大金额和
下一个子问题？
	不选：从前i-1个房子中得到的最大金额和
	选：从前i-2个房子中得到的最大金额和

1. 确定dp数组以及下标的含义
	dp[i]的定义为 偷到第i个房子的最大金额是，不代表一定会偷i
2. 确定递推公式
	dp[i] = max(d[i-1], d[i-2]+x)
3. dp数组如何初始化
	dp[1] = 第一个房子的金额    dp[2] = 第一个和第二个最大的金额
4. 确定遍历顺序
	从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的
5. 举例推导dp数组
	按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]

```c++
int rob(vector<int>& nums) {  
    if (nums.size() == 1) return nums[0];  
    if (nums.size() == 2) return max(nums[0], nums[1]);  
    int f1 = nums[0], f2 = max(nums[1], nums[0]);  
    for (int i = 2; i < nums.size(); i++) {  
        int tmp = max(f1+nums[i], f2);  
        f1 = f2;  
        f2 = tmp;  
    }  
    return f2;  
}
```


## [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)
[[打家劫舍 II]]
分成三个情况讨论
1. 不考虑首尾->线性数组
2. 考虑首，不考虑尾->线性数组
3. 不考虑首，考虑尾->线性数组
2 情况/ 3 情况 已经包含了1情况
```java
class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0)
            return 0;
        int len = nums.length;
        if (len == 1)
            return nums[0];
        return Math.max(robAction(nums, 0, len - 1), robAction(nums, 1, len));
    }

    int robAction(int[] nums, int start, int end) {
        int x = 0, y = 0, z = 0;
        for (int i = start; i < end; i++) {
            y = z;
            z = Math.max(y, x + nums[i]);
            x = y;
        }
        return z;
    }
}
```

分类讨论，考虑是否偷 nums[0]：

- 如果偷 nums[0]，那么 nums[1] 和 nums[n−1] 不能偷，问题变成从 nums[2] 到 nums[n−2] 的非环形版本，调用 198 题的代码解决；
- 如果不偷 nums[0]，那么问题变成从 nums[1] 到 nums[n−1] 的非环形版本，同样调用 198 题的代码解决。
这两种方案覆盖了所有情况（毕竟 nums[0] 只有偷与不偷，没有第三种选择），所以取两种方案的最大值，即为答案。

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        return Math.max(nums[0] + rob1(nums, 2, n - 1), rob1(nums, 1, n));
    }
    
    // 198. 打家劫舍
    private int rob1(int[] nums, int start, int end) { // [start,end) 左闭右开
        int f0 = 0;
        int f1 = 0;
        for (int i = start; i < end; i++) {
            int newF = Math.max(f1, f0 + nums[i]);
            f0 = f1;
            f1 = newF;
        }
        return f1;
    }
}
```



## [337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)

树形dp

这里是对一棵树进行DP，每一个节点有两个状态偷or不偷。 所以会对应起来一个dp数组：所以dp数组（dp table）以及下标的含义：下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱。

因为是递归遍历，每一次递归都会堆栈，所以会保存路径上所有节点的信息

单层处理逻辑
```c++
// 偷cur
int val1 = cur->val + left[0] + right[0];
// 不偷cur
int val2 = max(left[0], left[1]) + max(right[0], right[1]);
return {val2, val1};
```

最终结果代码
```c++
class Solution {
public:
    int rob(TreeNode* root) {
        vector<int> result = robTree(root);
        return max(result[0], result[1]);
    }
    // 长度为2的数组，0：不偷，1：偷
    vector<int> robTree(TreeNode* cur) {
        if (cur == NULL) return vector<int>{0, 0};
        vector<int> left = robTree(cur->left);
        vector<int> right = robTree(cur->right);
        // 偷cur，那么就不能偷左右节点。
        int val1 = cur->val + left[0] + right[0];
        // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况
        int val2 = max(left[0], left[1]) + max(right[0], right[1]);
        return {val2, val1};
    }
};
```

# 状态机 DP - 买卖股票系列 
本质是一系列的状态转换，昨天(step[i-1])的什么状态 通过某个公式 转成今天(step[i])的什么状态
## [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

 可以暴力(On2) or 贪心(On)

动态规划比较通用

二维DP数组，表示第i天持有/不持有这只股票最大金额

 注意理解今天的状态怎么由前一天的状态推出来

主要关注状态转移

注意只能买卖一次，所以，持有股票的的是-price[i]，因为金额从始至终都只有 0 ，只能赚一次
```c++
int maxProfit(vector<int>& prices) {  
    vector<vector<int>> dp(prices.size(), vector<int>(2, 0));  
    // 1 持有股票的最大利润， 0 不持有股票的最大利润  
    dp[0][1] = -prices[0];  
    dp[0][0] = 0;  
    for(int i = 1; i < prices.size(); i++) {  
        // 第i天持有股票，此时最大的利润是 今天买了股票 or 前一天持有股票的值 取最大值  
        dp[i][1] = max (-prices[i], dp[i-1][1]);  
        // 第i天不持有股票，此时的最大利润是,前一天不持有的最大price 和 前一天持有今天买了的最大price 取最大值  
        dp[i][0] = max(dp[i-1][0], prices[i] +dp[i-1][1]);  
    }  
    return max(dp[prices.size()-1][0], dp[prices.size()-1][1]);  
}
```


## [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)
可以买卖多次
主要就是购买的时候，到底算不算不持有股票的时候的钱的对比
```c++
int maxProfit2(vector<int>& prices) {  
    vector<vector<int>> dp(prices.size(), vector<int>(2, 0));  
    // 1 持有股票的最大利润， 0 不持有股票的最大利润  
    dp[0][1] = -prices[0];  
    dp[0][0] = 0;  
    for(int i = 1; i < prices.size(); i++) {  
        // 第i天持有股票，此时最大的利润是 今天买了股票 or 前一天持有股票的值 取最大值  
        dp[i][1] = max (dp[i-1][0]-prices[i], dp[i-1][1]);  
        // 第i天不持有股票，此时的最大利润是,前一天不持有的最大price 和 前一天持有今天买了的最大price 取最大值  
        dp[i][0] = max(dp[i-1][0], prices[i] +dp[i-1][1]);  
    }  
    return max(dp[prices.size()-1][0], dp[prices.size()-1][1]);  
}
```
## [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)
初始化是一个问题，要知道怎么初始化

初始化好之后，套路不变
```c++
int maxProfit(vector<int>& prices) {  
    // 用一个二维数组 n*4表示，0 表示第一次不持有的最大利润，1表示第一次持有，2表示第二次不持有，3表示第二次持有的最大利润  
    vector<vector<int>> dp(prices.size(), vector<int>(4, 0));  
    dp[0][1] = -prices[0];  
    dp[0][0] = 0;  
    dp[0][2] = 0; // 初始化为0，可以当天买，当天卖，就可以变成第二次不持有了  
    dp[0][3] = -prices[0]; //初始化为-price[0] 读二次持有  
    int run = 1;  
    for(int i = 1; i < prices.size(); i++) {  
        // 第一次不持有的最大利润  
        dp[i][0] = max (prices[i] + dp[i-1][1], dp[i-1][0]);  
        // 第一次持有的最大利润  
        dp[i][1] = max (-prices[i], dp[i-1][1]);  
        // 第二次不持有的最大理由  
        dp[i][2] = max (prices[i] + dp[i-1][3], dp[i-1][2]);  
        // 第二次持有的最大利润 = 第一次不持有后再买，或维持原状的最大值  
        dp[i][3] = max (dp[i-1][0]-prices[i], dp[i-1][3]);  
    }  
    return max(dp[prices.size()-1][0], dp[prices.size()-1][2]);  
}
```

## [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)
同3

```c++
int maxProfit(int k, vector<int>& prices) {  
    vector<vector<int>> dp(prices.size(), vector<int>(2*k,0));  
    for(int i = 1; i < 2*k; i+=2) {  
        dp[0][i] = -prices[0];  
    }  
    for(int i = 1; i < prices.size(); ++i) {  
        for(int j = 0; j < 2*k; ++j) {  
            // 不持有的情况  
            if ( j  % 2 == 0) {  
                dp[i][j] = max (dp[i-1][j],dp[i-1][j+1]+prices[i]);  
            }else {  
                if (j == 1) {  
                    dp[i][j] = max(dp[i-1][j],-prices[i]);  
                }else {  
                    // dp[i][0] 第一次不持有，dp[i][1] 第一次持有，dp[i][2]第二次不持有，dp[i][3]第二次持有，所以要-3  
                    dp[i][j] = max (dp[i-1][j],dp[i-1][j-3]-prices[i]);  
                }  
            }  
        }  
    }  
  
    return dp[prices.size()-1][2*k-2];  
}
```


## [309. 买卖股票的最佳时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
我的思路有点问题，dp 缺少表达前一天卖了的状态，不能指导哪一天能买，哪一天不能卖。应该定义成这样
所以对于每一天i，都有可能是三种状态：
0.不持股且当天没卖出,定义其最大收益dp\[i]\[0];
1.持股,定义其最大收益dp\[i]\[1]；
2.不持股且当天卖出了，定义其最大收益dp\[i]\[2]；
	一开始：
	多了一个中间状态冷冻
	dp[0] 不持有，不冷冻
	dp[1] 不持有，冷冻
	dp[2] 持有
	
	dp[2] = max(前一天持有股票，前一天不持有，不冷冻-price[i]) 
	dp[1] = max(前一天持有变不持有->前一天持有+price[i-1])
	
	dp[0] = max(前一天不持有，不冷冻，前一天不持有)
一、第i天不持股且没卖出的状态dp[i][0]，也就是我没有股票，而且还不是因为我卖了它才没有的，那换句话说是从i-1天到第i天转移时，它压根就没给我股票！所以i-1天一定也是不持有，那就是不持有的两种可能：i-1天不持股且当天没有卖出dp\[i-1]\[0]；i-1天不持股但是当天卖出去了dp\[i-1]\[2]；
所以： dp[i][0]=max(dp[i-1][0],dp[i-1][2])

二、第i天持股dp[i][1]，今天我持股，来自两种可能：
1、要么是昨天我就持股，今天继承昨天的，也就是dp\[i-1]\[1]，这种可能很好理解；
2、要么：是昨天我不持股，今天我买入的，但前提是昨天我一定没卖！因为如果昨天我卖了，那么今天我不能交易！也就是题目中所谓“冷冻期”的含义，只有昨天是“不持股且当天没卖出”这个状态，我今天才能买入！所以是dp\[i-1]\[0]-p[i]
所以： dp\[i]\[1]=max(dp\[i-1]\[1],dp\[i-1]\[0]-p[i])

三、i天不持股且当天卖出了，这种就简单了，那就是说昨天我一定是持股的，要不然我今天拿什么卖啊，而持股只有一种状态，昨天持股的收益加上今天卖出得到的新收益，就是dp\[i-1]\[1]+p[i]啦
所以：dp\[i]\[2]=dp\[i-1]\[1]+p[i]




----
0x3f

在 [[#[122. 买卖股票的最佳时机 II](https //leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)|买卖股票的最佳时机 II]] 的基础上，只需修改**一处**：在计算持有股票的状态时，把 dfs(i−1,0) 改成 dfs(i−2,0)。道理和在 [[#买卖股票的最佳时机 II 的基础上，只需修改一处：在计算持有股票的状态时，把 dfs(i−1,0) 改成 dfs(i−2,0)。道理和  [[#[198. 打家劫舍](https //leetcode.cn/problems/house-robber/)|打家劫舍]] 是一样的，因为第 i 天买股票的话第 i−1 天不能卖，只能从第 i−2 天没有股票的状态转移过来。注意 dfs(i−2,0) 并不意味着第 i−2 天一定卖了股票，而是在没有股票下的最优状态。

-----
代码随想录，比较易懂

状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）
不持有股票状态，这里就有两种卖出股票状态
状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）
状态三：今天卖出股票
状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if (n == 0) return 0;
        vector<vector<int>> dp(n, vector<int>(4, 0));
        dp[0][0] -= prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]));
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2] = dp[i - 1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        }
        return max(dp[n - 1][3], max(dp[n - 1][1], dp[n - 1][2]));
    }
};
```
## [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)
同买卖股票2
```c++
int maxProfit6(vector<int>& prices, int fee) {  
    vector<vector<int>> dp(prices.size(), vector<int>(2, 0));  
    // 1 持有股票的最大利润， 0 不持有股票的最大利润  
    dp[0][1] = -prices[0];  
    dp[0][0] = 0;  
    for(int i = 1; i < prices.size(); i++) {  
        // 第i天持有股票，此时最大的利润是 今天买了股票 or 前一天持有股票的值 取最大值  
        dp[i][1] = max (dp[i-1][0]-prices[i], dp[i-1][1]);  
        // 第i天不持有股票，此时的最大利润是,前一天不持有的最大price 和 前一天持有今天买了的最大price 取最大值  
        dp[i][0] = max(dp[i-1][0], prices[i] +dp[i-1][1]-fee);  
    }  
    return max(dp[prices.size()-1][0], dp[prices.size()-1][1]);        
}
```


## [2826. 将三个组排序](https://leetcode.cn/problems/sorting-three-groups/)


## [2786. 访问数组中的位置使分数最大](https://leetcode.cn/problems/visit-array-positions-to-maximize-score/)



# 最长公共子序列LCS

## [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)
元素之间可以不连续，可以对比[[#[718. 最长重复子数组](https //leetcode.cn/problems/maximum-length-of-repeated-subarray/)|最长重复子数组]]

因为可以不连续，递推的时候，不只是要和当前的比较
```c++
int longestCommonSubsequence(string text1, string text2) {  
    vector<vector<int>> dp(text1.size()+1, vector<int>(text2.size()+1, 0));  
    int maxRs = 0;  
    for(int i = 1; i < text1.size()+1; i++) {  
        for(int j = 1; j < text2.size()+1; j++) {  
            // 如果他们的结尾一样，则+1，匹配上了  
            if(text1[i-1] == text2[j-1]) {  
                dp[i][j] = dp[i-1][j-1]+1;  
                maxRs = max(maxRs, dp[i][j]);  
            }else {  
                //如果不匹配，以他们为结尾的的最长公共子序列（不重复）的最大长度，就要看之前的了  
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);  
            }  
        }  
    }  
    return maxRs;  
}
```

## [392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)

用一个二维数组，就可以表示所有的字符串是否相等的情况

删除某一个数，就某一个数字回退1


```python 
def isSubsequence(self, s: str, t: str) -> bool:  
    dp = [[0] * (len(t)+1) for _ in range(len(s)+1)]  
    for i in range(1, len(s)+1):  
        for j in range(1, len(t)+1):  
            if s[i-1] == t[j-1]:  
                dp[i][j] = dp[i-1][j-1] + 1  
            else:  
                dp[i][j] = dp[i][j-1]  
    if dp[-1][-1] == len(s):  
        return True  
    return False
```
## [115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)

参考这张图
![[Pasted image 20250920083302.png]]

看注释
```python
def numDistinct(self, s: str, t: str) -> int:  
    dp = [[0] * (len(t)+1) for _ in range(len(s)+1)]  
    for i in range(len(s)):  
        dp[i][0] = 1  
    for j in range(1, len(t)):  
        dp[0][j] = 0  
    for i in range(1, len(s)+1):  
        for j in range(1, len(t)+1):  
            if s[i-1] == t[j-1]:  
                # 当结尾字符相等的时候，需要考虑，从两个字符串的前面都取数字/s可以删除自己的字符，这个时候，如何加上还匹配的数字  
                dp[i][j] = dp[i-1][j-1] + dp[i-1][j]  
            else:  
                # 不相等的时候，s删掉自身  
                dp[i][j] = dp[i-1][j]  
    return dp[-1][-1]
```

## [583. 两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/)
==把每个字符都堪称单纯的字符看，一步一步递推== 
2. 确定递推公式
- 当word1[i - 1] 与 word2[j - 1]相同的时候
- 当word1[i - 1] 与 word2[j - 1]不相同的时候
当word1[i - 1] 与 word2[j - 1]相同的时候，dp\[i][j] = dp\[i - 1][j - 1];
当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：

情况一：删word1\[i - 1]，最少操作次数为dp\[i - 1][j] + 1
情况二：删word2\[j - 1]，最少操作次数为dp\[i][j - 1] + 1
情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp\[i - 1][j - 1] + 2

那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：dp\[i][j] = min({dp\[i - 1][j - 1] + 2, dp\[i - 1][j] + 1, dp\[i][j - 1] + 1});

因为 dp\[i][j - 1] + 1 = dp\[i - 1][j - 1] + 2，所以递推公式可简化为：dp\[i][j] = min(dp\[i - 1][j] + 1, dp\[i][j - 1] + 1);

这里可能不少录友有点迷糊，从字面上理解 就是 当 同时删word1[i - 1]和word2[j - 1]，dp\[i][j-1] 本来就不考虑 word2[j - 1]了，那么我在删 word1[i - 1]，是不是就达到两个元素都删除的效果，即 dp\[i][j-1] + 1。

3. dp数组如何初始化

从递推公式中，可以看出来，dp\[i][0] 和 dp\[0][j]是一定要初始化的。

dp\[i][0]：word2为空字符串，以i-1为结尾的字符串word1要删除多少个元素，才能和word2相同呢，很明显dp\[i][0] = i。

dp\[0][j]的话同理，所以代码如下：
![[Pasted image 20250920084830.png]]

## [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

在确定递推公式的时候，首先要考虑清楚编辑的几种操作，整理如下：

```
if (word1[i - 1] == word2[j - 1])
    不操作
if (word1[i - 1] != word2[j - 1])
    增
    删
    换
```


`if (word1[i - 1] == word2[j - 1])` 那么说明不用任何编辑，`dp[i][j]` 就应该是 `dp[i - 1][j - 1]`，即`dp[i][j] = dp[i - 1][j - 1];`


`if (word1[i - 1] != word2[j - 1])`，此时就需要编辑了，如何编辑呢？
- 操作一：word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 再加上一个操作。
	即 `dp[i][j] = dp[i - 1][j] + 1;`
- 操作二：word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上一个操作。
	即 `dp[i][j] = dp[i][j - 1] + 1;`
这里有同学发现了，怎么都是删除元素，添加元素去哪了。
**word2添加一个元素，相当于word1删除一个元素**，例如 `word1 = "ad" ，word2 = "a"`，`word1`删除元素`'d'` 和 `word2`添加一个元素`'d'`，变成`word1="a", word2="ad"`， 最终的操作数是一样！ 

- 操作三：替换元素，`word1`替换`word1[i - 1]`，使其与`word2[j - 1]`相同，此时不用增删加元素。
	可以回顾一下，`if (word1[i - 1] == word2[j - 1])`的时候我们的操作 是 `dp[i][j] = dp[i - 1][j - 1]` 对吧。
	那么只需要一次替换的操作，就可以让 word1[i - 1] 和 word2[j - 1] 相同。
	所以 `dp[i][j] = dp[i - 1][j - 1] + 1;`
	综上，当 `if (word1[i - 1] != word2[j - 1])` 时取最小的，即：`dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;`

```python
def minDistance(self, word1: str, word2: str) -> int:  
    dp = [[0] * (len(word2) + 1) for _ in range(len(word1) + 1)]  
    for i in range(len(word1) + 1):  
        dp[i][0] = i  
    for j in range(len(word2) + 1):  
        dp[0][j] = j  
    for i in range(1, len(word1) + 1):  
        for j in range(1, len(word2) + 1):  
            if word1[i - 1] == word2[j - 1]:  
                dp[i][j] = dp[i - 1][j - 1]  
            else:  
                dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1  
    return dp[-1][-1]
```

# 最长递增子序列LIS

## [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

已nums[i] 为结尾的最长递增子序列的长度
为什么一定表示 “以nums[i]结尾的最长递增子序” ，因为我们在 做 递增比较的时候，如果比较 nums[j] 和 nums[i] 的大小，那么两个递增子序列一定分别以nums[j]为结尾 和 nums[i]为结尾， 要不然这个比较就没有意义了，不是尾部元素的比较那么 如何算递增呢。
感觉是一个过得很惨的同性恋
递推公式：遍历前面的尾巴，如果dp[i]>dp[j]更新

```c++
int lengthOfLIS(vector<int>& nums) {  
    // dp数组，以i为结尾的  
    vector<int> dp(nums.size(), 1);  
    int maxRs = 1;  
    for(int i = 1; i < nums.size(); i++) {  
        for(int j = 0; j < i; j++) {  
            // 如果大于就+1，一直取最大值  
            if(nums[i] > nums[j]) {  
                dp[i] = max(dp[i], dp[j]+1);  
            }  
        }  
        maxRs = max(maxRs, dp[i]);  
    }  
    return maxRs;  
}
```
## [674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

已nums[i] 为结尾的最长连续递增子序列的长度

递推公式：只看前面的，是不是比他大，是的话+1，不是的话重置为1

和上面一个对比
```c++
int findLengthOfLCIS(vector<int>& nums) {
    vector<int> dp(nums.size(), 1);
    int maxRs = 1;
    for(int i = 1; i < nums.size(); i++) {
        if(nums[i] > nums[i-1]) {
            dp[i] = max(dp[i], dp[i-1]+1);
        }
        maxRs = max(maxRs, dp[i]);
    }
    return maxRs;
}
```
## [718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

即是连续子序列
用二维数组，表示两个数组的状态
dp\[i]\[j] = 以i-1为结尾，j-1为尾的最长重复子数组的长度

注意dp数组的定义，以i-1为结尾，j-1为尾的最长重复子数组的长度，根据定义，递推公式仅为nums1[i-1] == nums2[j-1] 的时候，即此时两数组在以该位置结尾的值相等，此时因为要连续，所以新值会等于 以 nums1[i-2] 和   nums2[j-2] 结尾的重复子数组长度+1
例如 1 2 3  1 2 3
发现 2 = 2
前面 1 = 1 长度事1
2 =2 更新长度 = 2

请和[[#[1143. 最长公共子序列](https //leetcode.cn/problems/longest-common-subsequence/)]] 不连续做递推公式的对比
```c++
int findLength(vector<int>& nums1, vector<int>& nums2) {  
    // dp[i][j] 表示nums[i-1][nums][j-1]结尾的最长公共子序列长度  
    vector<vector<int>> dp(nums1.size()+1, vector<int>(nums2.size()+1, 0));  
    int maxRs = 0;  
    for(int i = 1; i < nums1.size()+1; i++) {  
        for(int j = 1; j < nums2.size()+1; j++) {  
            if (nums1[i-1] == nums2[j-1]) {  
                dp[i][j] = dp[i-1][j-1]+1;  
                maxRs = max(maxRs, dp[i][j]);  
            }  
        }  
    }  
    return maxRs;  
}
```

## [1671. 得到山形数组的最少删除次数](https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array/)
## [53. 最大子序和](https://leetcode.cn/problems/maximum-subarray/)
相同的数组套路，dp数组定义为以nums[i]结尾的dp[i]的最大值。这样子就可以通过上一个状态，转移到下一个状态->选或不选以上一个为结尾的数组
```c++
class Solution:  
    def maxSubArray(self, nums: List[int]) -> int:  
        dp = [0 for _ in range(len(nums))]  
        dp[0]  = nums[0]  
        maxV = nums[0]  
        for index in range(1,len(nums)):  
            dp[index] = max(dp[index-1]+nums[index],nums[index])  
            maxV = max(maxV,dp[index])  
        return maxV
```


## [1626. 无矛盾的最佳球队](https://leetcode.cn/problems/best-team-with-no-conflicts/)

# 区间DP

## [647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)

代码随想录的更加简洁，所以用代码随想录的。重点有2
1. dp数组的定义，定义为dp [i]  [j] 表示为从i到j的子字符串是不是回文的。通过这种方式向下一个状态转换
2. 递推公式，注意边界条件，只有一个字母和只有两个字母的情况。有了1和2，才可以通过+2递推所有数字
```python
class Solution:  
    def countSubstrings(self, s: str) -> int:  
        dp = [[False] * len(s) for _ in range(len(s))]  
        result = 0  
        for i in range(len(s)-1, -1, -1): #注意遍历顺序  
            for j in range(i, len(s)):  
                if s[i] == s[j]:  
                    if j - i <= 1: #情况一 和 情况二  
                        result += 1  
                        dp[i][j] = True  
                    elif dp[i+1][j-1]: #情况三  
                        result += 1  
                        dp[i][j] = True  
        return result
```
## [516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

dp的定义方式和回文字串的意义

```python
def longestPalindromeSubseq(self, s: str) -> int:  
    n = len(s)  
    dp = [[0]*n for _ in range(n)]  
    for i in range(n-1,-1,-1):  
        for j in range(i,n):  
            if s[i] == s[j]:  
                if j-i <= 1:  
                    dp[i][j] = j - i + 1  
                else:  
                    dp[i][j] = dp[i+1][j-1] + 2  
            else:  
                dp[i][j] = max(dp[i+1][j],dp[i][j-1])  
    return dp[0][n-1]
```
## [1039. 多边形三角剖分的最低得分](https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/)

## [3040. 相同分数的最大操作数目 II](https://leetcode.cn/problems/maximum-number-of-operations-with-the-same-score-ii/)

## [1547. 切棍子的最小成本](https://leetcode.cn/problems/minimum-cost-to-cut-a-stick/)

## [1771. 由子序列构造的最长回文串的长度](https://leetcode.cn/problems/maximize-palindrome-length-from-subsequences/)

## [1000. 合并石头的最低成本](https://leetcode.cn/problems/minimum-cost-to-merge-stones/)


# 树形DP-直径系列

## [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

## [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

## [2246. 相邻字符不同的最长路径](https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/)

## [687. 最长同值路径](https://leetcode.cn/problems/longest-univalue-path/)

## [3203. 合并两棵树后的最小直径](https://leetcode.cn/problems/find-minimum-diameter-after-merging-two-trees/)

## [1617. 统计子树中城市之间最大距离](https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/)

## [2538. 最大价值和与最小价值和的差值](https://leetcode.cn/problems/difference-between-maximum-and-minimum-price-sum/)



# 树形DP-最大独立集
## [337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)
[[#[337. 打家劫舍 III](https //leetcode.cn/problems/house-robber-iii/)]]

## [1377. T 秒后青蛙的位置](https://leetcode.cn/problems/frog-position-after-t-seconds/)

## [2646. 最小化旅行的价格总和](https://leetcode.cn/problems/minimize-the-total-price-of-the-trips/)


# 树形 DP - 最小支配集
## [968. 监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/)










# 左链接
[[动态规划的模型总结]]
[[在动态规划中, 贪心是个什么地位]]
