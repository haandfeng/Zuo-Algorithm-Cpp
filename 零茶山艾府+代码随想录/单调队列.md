#0x3f  #单调队列 

# [LCR 184. 设计自助结算系统](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/)

用两个队列，一个队列实现先进先出。一个队列实现优先级队列
```python
import queue

class Checkout:
    def __init__(self):
        self.queue = queue.Queue()
        self.deque = queue.deque()

    def get_max(self) -> int:
        return self.deque[0] if self.deque else -1

    def add(self, value: int) -> None:
        self.queue.put(value)
        while self.deque and self.deque[-1] < value:
            self.deque.pop()
        self.deque.append(value)

    def remove(self) -> int:
        if self.queue.empty(): return -1
        val = self.queue.get()
        if val == self.deque[0]:
            self.deque.popleft()
        return val
```
# [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)


维护单调队列的经典题目
```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        queue = deque()
        ans = []
        for i in range(k):
            while queue and nums[i] > nums[queue[-1]]:
                queue.pop()
            queue.append(i)
        ans.append(nums[queue[0]])
        for i in range(k, len(nums)):
            if i - queue[0] >=k:
                queue.popleft()
            while queue and nums[i] > nums[queue[-1]]:
                queue.pop()
            queue.append(i)
            ans.append(nums[queue[0]])
        return ans
```


# [2398. 预算内的最多机器人数目](https://leetcode.cn/problems/maximum-number-of-robots-within-budget/) 

题目要求机器人连续运行，看成一个连续子数组，题目要求计算最长子数组长度。

枚举子数组右端点 right，我们需要知道此时左端点 left 的最小值，这样子数组尽量长。

由于有 budget 的限制，所以 right 越大，left 也越大，有单调性，可以用滑动窗口解决。

本题的一种做法是二分答案，这样就转换成了固定长度的 239 题。

但实际上不用二分，在 239 题的基础上，把定长滑窗改为不定长滑窗，套路如下：

入：chargeTimes[right] 进入窗口时，弹出队尾的 ≤chargeTimes[right] 的元素。
出：如果总开销超过 budget，则不断移出左端点，直到总开销不超过 budget。特别地，如果左端点恰好等于队首，则弹出队首。
更新答案：用窗口长度 right−left+1 更新答案的最大值。


傻逼了，不知道为什么想岔了
```python
class Solution:
    def maximumRobots(self, chargeTimes: List[int], runningCosts: List[int], budget: int) -> int:
        ans = s = left = 0
        q = deque()
        for right, (t, c) in enumerate(zip(chargeTimes, runningCosts)):
            # 1. 入
            while q and t >= chargeTimes[q[-1]]:
                q.pop()
            q.append(right)
            s += c  # 维护 sum(runningCosts)

            # 2. 出
            while q and chargeTimes[q[0]] + (right - left + 1) * s > budget:
                if q[0] == left:
                    q.popleft()
                s -= runningCosts[left]  # 维护 sum(runningCosts)
                left += 1

            # 3. 更新答案
            ans = max(ans, right - left + 1)
        return ans
```


# [862. 和至少为 K 的最短子数组](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/)

[[Hot100#[560. 和为 K 的子数组](https //leetcode.cn/problems/subarray-sum-equals-k/)]]
和这道题对比一下，都是和为k，并且不能用滑动窗口解决

求出 nums 的前缀和 s 后，我们可以写一个暴力算法，枚举所有满足 i>j 且 s[i]−s[j]≥k 的子数组 [j,i)，取其中最小的 i−j 作为答案。

但这个暴力算法是 O(n ^ 2) 的，如何优化呢？

我们可以遍历 s，同时用某个合适的数据结构来维护遍历过的 s[i]，并及时移除无用的 s[i]。




![862-1-2.png](https://pic.leetcode.cn/1666668814-ikkWBN-862-1-2.png)



![862-2-3.png](https://pic.leetcode.cn/1666669250-KypIVI-862-2-3.png)


做完这两个优化后，再把 s[i] 加到这个数据结构中。

由于优化二保证了数据结构中的 s[i] 会形成一个递增的序列，因此优化一移除的是序列最左侧的若干元素，优化二移除的是序列最右侧的若干元素。我们需要一个数据结构，它支持移除最左端的元素和最右端的元素，以及在最右端添加元素，故选用双端队列。

==我觉得先考虑优化二，在考虑优化一比较好==

```python
class Solution:
    def shortestSubarray(self, nums: List[int], k: int) -> int:
        ans = inf
        s = list(accumulate(nums, initial=0))  # 计算前缀和
        q = deque()
        for i, cur_s in enumerate(s):
            while q and cur_s - s[q[0]] >= k:
                ans = min(ans, i - q.popleft())  # 优化一
            while q and s[q[-1]] >= cur_s:
                q.pop()  # 优化二
            q.append(i)
        return ans if ans < inf else -1
```

# [1499. 满足不等式的最大值](https://leetcode.cn/problems/max-value-of-equation/)

![[Pasted image 20251015203953.png]]

难度不高，但单调队列的模版和滑动窗口的模版弄混了。导致没想出来
```python
class Solution:
    def findMaxValueOfEquation(self, points: List[List[int]], k: int) -> int:
        ans = -inf
        q = deque()
        for x, y in points:
            while q and q[0][0] < x - k:  # 队首超出范围
                q.popleft()  # 弹它！
            if q:
                ans = max(ans, x + y + q[0][1])  # 加上最大的 yi-xi
            while q and q[-1][1] <= y - x:  # 队尾不如新来的强
                q.pop()  # 弹它！
            q.append((x, y - x))
        return ans
```

# [1438. 绝对差不超过限制的最长连续子数组](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/)


记录从left到i，这个区间的最大值和最小值，用单调队列记录。这样子可以找到一定范围内的最大值和最小值。并且范围变更后，还可以快速的找到一个范围里的最大和最小值
```python
class Solution:
    def longestSubarray(self, nums: List[int], limit: int) -> int:
        min_q = deque()
        max_q = deque()
        ans = left = 0

        for i, x in enumerate(nums):
            # 1. 右边入
            while min_q and x <= nums[min_q[-1]]:
                min_q.pop()
            min_q.append(i)

            while max_q and x >= nums[max_q[-1]]:
                max_q.pop()
            max_q.append(i)

            # 2. 左边出
            while nums[max_q[0]] - nums[min_q[0]] > limit:
                left += 1
                if min_q[0] < left:  # 队首不在窗口中
                    min_q.popleft()
                if max_q[0] < left:  # 队首不在窗口中
                    max_q.popleft()

            # 3. 更新答案
            ans = max(ans, i - left + 1)

        return ans
```
# [1696. 跳跃游戏 VI](https://leetcode.cn/problems/jump-game-vi/)
常数级空间，又不修改nums的方法。还提高了时间复杂度
贪心不确定对不对的时候，还是用动态规划吧
```python
class Solution:
    def maxResult(self, nums: List[int], k: int) -> int:
            dq = deque()                 # 保存 (idx, f[idx])，按 f 递减
            dq.append((0, nums[0]))
            best = nums[0]
            for i in range(1, len(nums)):
                # 1) 出：移除窗口外的
                while dq and dq[0][0] < i - k:
                    dq.popleft()
                # 2) 转移：用队首最大 f 计算当前 f[i]
                best = nums[i] + dq[0][1]
                # 3) 入：维护单调性
                while dq and dq[-1][1] <= best:
                    dq.pop()
                dq.append((i, best))
            return best
```
# [2944. 购买水果需要的最少金币数](https://leetcode.cn/problems/minimum-number-of-coins-for-fruits/)

我是用dp做的，没想到这么个单调队列优化了。感觉灵神的太复杂了，没看懂，不看了
```python
class Solution:
    def minimumCoins(self, prices: List[int]) -> int:
        inf = float('inf')
        dp = [[inf, inf] for _ in range(len(prices))]
        dp[0][1] = prices[0]
        for i in range (1, len(prices)):
            minValue = inf
            for j in range(i-1,-1,-1):
                if j + 1 + j + 1 < i + 1:
                    break
                minValue = min(minValue, dp[j][1])
            dp[i][0] = minValue
            dp[i][1] = min(dp[i-1][0],dp[i-1][1]) + prices[i]
        return min(dp[-1][0],dp[-1][1])
```


让gpt写的带滑动窗口的优化版本
![[Pasted image 20251013220202.png]]
```python
from collections import deque
from typing import List

class Solution:
    def minimumCoins(self, prices: List[int]) -> int:
        n = len(prices)
        INF = float('inf')

        # dp0[i] = 状态0在i天的最小花费
        # dp1[i] = 状态1在i天的最小花费
        dp0_prev = INF
        dp1_prev = prices[0]

        # 维护窗口 [i//2, i-1] 上 dp1[j] 的单调递增队列 (idx, value)
        dq = deque()
        dq.append((0, dp1_prev))

        for i in range(1, n):
            # 将新候选 j = i-1 加入队列（保持值单调递增）
            new_idx, new_val = i - 1, dp1_prev
            while dq and dq[-1][1] >= new_val:
                dq.pop()
            dq.append((new_idx, new_val))

            # 计算窗口左端 L = i//2，弹出过期元素
            L = i // 2
            while dq and dq[0][0] < L:
                dq.popleft()

            # 此时队首就是区间最小值 => dp0[i]
            dp0_curr = dq[0][1]

            # 常规转移：dp1[i] = min(dp0[i-1], dp1[i-1]) + prices[i]
            dp1_curr = min(dp0_prev, dp1_prev) + prices[i]

            # 滚动数组前移
            dp0_prev, dp1_prev = dp0_curr, dp1_curr

        return min(dp0_prev, dp1_prev)
```