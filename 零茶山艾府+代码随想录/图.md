
# [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)


dfs很简单，主要是这道题的解题思路：
怎么找到一座新的岛屿呢？只有那个数字是1，并且没被visited过，就说明是新的岛屿。这个时候就需要对这个岛屿进行dfs，把它的所有相邻的陆地visited
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid or not grid[0]:
            return 0
        m, n = len(grid), len(grid[0])
        visited = [[False] * n for _ in range(m)]
        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        def dfs(i: int, j: int) -> None:
            # 先判越界
            if i < 0 or i >= m or j < 0 or j >= n:
                return
            # 不是陆地或已访问，返回
            if grid[i][j] != '1' or visited[i][j]:
                return

            visited[i][j] = True
            for dr, dc in dirs:
                dfs(i + dr, j + dc)

        cnt = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1' and not visited[i][j]:
                    cnt += 1
                    dfs(i, j)
        return cnt
```

# [695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)
和上一题差不多

```python
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        if not grid or not grid[0]:
            return 0
        m, n = len(grid), len(grid[0])
        visited = [[False] * n for _ in range(m)]
        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        self.area = 0
        res = 0
        def dfs(i:int, j:int) -> None:
            if i<0 or i>=m or j<0 or j>=n:
                return
            if grid[i][j] != '1' or visited[i][j]:
                return
            self.area+=1
            visited[i][j] = True
            for row,col in dirs:
                dfs(i+row,j+col)

        for i in range(m):
            for j in range(n):
                if not visited[i][j] and grid[i][j]=='1':
                    self.area=0
                    dfs(i,j)
                    res = max(self.area,res)
        return res

```
# [卡码网：101. 孤岛的总面积](https://kamacoder.com/problempage.php?pid=1173)
反向思考，不是孤岛更好解决：
1.从border出发的岛都不是孤岛
2.从飞其他地方出发的岛就是孤岛
把不是孤岛染色成2。染完后找1就好了


# [卡码网：102. 沉没孤岛](https://kamacoder.com/problempage.php?pid=1174)
一样的思路

# [卡码网：103. 水流问题](https://kamacoder.com/problempage.php?pid=1175)


# [827. 最大人工岛](https://leetcode.cn/problems/making-a-large-island/)

主要思路就是先把每一个岛标号色，这样就不需要重复计算岛的面积，只要看相邻的有哪些岛就好了，这样就可以连起来了
```python
class Solution:
    def largestIsland(self, grid: List[List[int]]) -> int:
        n = len(grid)
        def dfs(i: int, j: int) -> int:
            size = 1
            grid[i][j] = len(area) + 2  # 记录 (i,j) 属于哪个岛
            for x, y in (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1):
                if 0 <= x < n and 0 <= y < n and grid[x][y] == 1:
                    size += dfs(x, y)
            return size

        # DFS 每个岛，统计各个岛的面积，记录到 area 列表中
        area = []
        for i, row in enumerate(grid):
            for j, x in enumerate(row):
                if x == 1:
                    area.append(dfs(i, j))

        # 加上这个特判，可以快很多
        if not area:  # 没有岛
            return 1

        ans = 0
        for i, row in enumerate(grid):
            for j, x in enumerate(row):
                if x: continue
                s = set()
                for x, y in (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1):
                    if 0 <= x < n and 0 <= y < n and grid[x][y]:
                        s.add(grid[x][y])  # 记录上下左右格子所属岛屿编号
                ans = max(ans, sum(area[idx - 2] for idx in s) + 1)  # 累加面积

        # 如果最后 ans 仍然为 0，说明所有格子都是 1，返回 n^2
        return ans if ans else n * n
```


# [463. 岛屿的周长](https://leetcode.cn/problems/island-perimeter/)

算周长只需要统计有几个岛屿就好了


```python
class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        ans = 0
        for i, row in enumerate(grid):
            for j, x in enumerate(row):
                if x == 0:
                    continue
                if i == 0 or grid[i - 1][j] == 0:  # 上：出界或者是水
                    ans += 1
                if i == m - 1 or grid[i + 1][j] == 0:  # 下：出界或者是水
                    ans += 1
                if j == 0 or row[j - 1] == 0:  # 左：出界或者是水
                    ans += 1
                if j == n - 1 or row[j + 1] == 0:  # 右：出界或者是水
                    ans += 1
        return ans
```


# [207. 课程表](https://leetcode.cn/problems/course-schedule/)
拓扑排序经典题目，主要是要考虑两个点
1. 如何存图->用邻接表/邻接矩阵
2. 如果管理依赖关系->通过出度入度处理依赖关系
```python
from typing import List          # 支持函数参数类型标注 List[List[int]]from collections import defaultdict, deque  # 用到 defaultdict 和 dequeclass Solution: 
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:  
        graph = defaultdict(list)  
        degree = [0] * numCourses  
        queue = deque()  
        result = []  
        for course, pre in prerequisites:  
            graph[pre].append(course)  
            degree[course] += 1  
        for index, value in enumerate(degree):  
            if value == 0:  
                queue.append(index)  
        while len(queue) != 0:  
            index = queue.popleft()  
            for value in graph[index]:  
                degree[value] -= 1  
                if degree[value] == 0:  
                    queue.append(value)  
            result.append(index)  
        if len(result) == numCourses:  
            return True  
        else:  
            return False
```

# [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)
和上一题一样

```python
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        graph = defaultdict(list)
        degree = [0] * numCourses
        queue = deque()
        result = []
        for course, pre in prerequisites:
            graph[pre].append(course)
            degree[course] += 1
        for index, value in enumerate(degree):
            if value == 0:
                queue.append(index)
        while len(queue) != 0:
            index = queue.popleft()
            for value in graph[index]:
                degree[value] -= 1
                if degree[value] == 0:
                    queue.append(value)
            result.append(index)
        if len(result) == numCourses:
            return result
        else:
            return []

```


# 并查集

下面的是并查集的问题


# [1971. 寻找图中是否存在路径](https://leetcode.cn/problems/find-if-path-exists-in-graph/)
就是实现一遍并查集，然后放在一起就好了
```python
class UnionFind:
    def __init__(self, n: int):
        # 初始化时每个元素的父节点都是自己
        self.father = [i for i in range(n)]

    def find(self, u: int) -> int:
        # 路径压缩版本的 find
        if self.father[u] != u:
            self.father[u] = self.find(self.father[u])
        return self.father[u]

    def isSame(self, u: int, v: int) -> bool:
        # 判断两个点是否在同一集合
        return self.find(u) == self.find(v)

    def join(self, u: int, v: int):
        # 合并两个集合（把 v 的根挂到 u 的根上）
        u = self.find(u)
        v = self.find(v)
        if u == v:
            return
        self.father[v] = u
class Solution:
    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:
        uf = UnionFind(n)

        # 把所有边都连起来
        for u, v in edges:
            uf.join(u, v)

        # 判断 source 和 destination 是否在同一个连通块里
        return uf.isSame(source, destination)
```
# [684. 冗余连接](https://leetcode.cn/problems/redundant-connection/)

如果他们的两个节点的parent相同，那么他们就是冗余的链接。
```python
class UnionFind:
    def __init__(self, n: int):
        # 初始化时每个元素的父节点都是自己
        self.father = [i for i in range(n)]

    def find(self, u: int) -> int:
        # 路径压缩版本的 find
        if self.father[u] != u:
            self.father[u] = self.find(self.father[u])
        return self.father[u]

    def isSame(self, u: int, v: int) -> bool:
        # 判断两个点是否在同一集合
        return self.find(u) == self.find(v)

    def join(self, u: int, v: int):
        # 合并两个集合（把 v 的根挂到 u 的根上）
        u = self.find(u)
        v = self.find(v)
        if u == v:
            return
        self.father[v] = u


class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        uf = UnionFind(len(edges)+1)
        for u, v in edges:
            if uf.isSame(u,v):
                return [u,v]
            else:
                uf.join(u,v)
```
# [685. 冗余连接 II](https://leetcode.cn/problems/redundant-connection-ii/)

还有 若有多个答案，返回最后出现在给定二维数组的答案。这说明在两条边都可以删除的情况下，要删顺序靠后的！

那么有如下三种情况，前两种情况是出现入度为 2 的点，如图：


情况1: 只能删除特定的边
情况2: 可以删除随意一条边
![685.冗余连接II1.png](https://pic.leetcode-cn.com/1600316277-YhGBBy-685.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II1.png)
且只有一个节点入度为 2，为什么不看出度呢，出度没有意义，一颗树中随便一个父节点就有多个出度。

第三种情况是没有入度为 2 的点，那么图中一定出现了***有向环（注意这里强调是有向环！）***


![685.冗余连接II2.png](https://pic.leetcode-cn.com/1600316290-fCDJSg-685.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II2.png)

对于情况1和2: 统计每一个点的入度，注意要从后往前统计，因为优先返回最后出现在二维数组中的答案，如果有入度为2的节点，那么一定是两条边里删一个，看删哪个可以构成树
对于情况3:用并查集判断有无还、


```python
from typing import List

class UnionFind:
    def __init__(self, n: int):
        # 初始化时每个元素的父节点都是自己
        self.father = [i for i in range(n)]

    def find(self, u: int) -> int:
        # 路径压缩版本的 find
        if self.father[u] != u:
            self.father[u] = self.find(self.father[u])
        return self.father[u]

    def isSame(self, u: int, v: int) -> bool:
        # 判断两个点是否在同一集合
        return self.find(u) == self.find(v)

    def join(self, u: int, v: int):
        # 合并两个集合（把 v 的根挂到 u 的根上）
        u = self.find(u)
        v = self.find(v)
        if u == v:
            return
        self.father[v] = u


class Solution:
    # 删一条边之后判断是不是树
    def _isTreeAfterRemoveEdge(self, edges: List[List[int]], n: int, deleteEdge: int) -> bool:
        uf = UnionFind(n + 1)   # 节点是 1..n，所以开 n+1
        for i, (u, v) in enumerate(edges):
            if i == deleteEdge:
                continue
            if uf.isSame(u, v):     # 出现环，不是树
                return False
            uf.join(u, v)
        return True

    # 在有向图里找到删除的那条边，使其变成树（没有入度为 2 的点时）
    def _getRemoveEdge(self, edges: List[List[int]], n: int) -> List[int]:
        uf = UnionFind(n + 1)
        for u, v in edges:
            if uf.isSame(u, v):     # 这一条导致了环
                return [u, v]
            uf.join(u, v)
        return []

    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:
        n = len(edges)
        # 记录每个节点的入度
        inDegree = [0] * (n + 1)
        for u, v in edges:
            inDegree[v] += 1

        # 记录入度为 2 的那两个边的下标（如果有）
        candidates = []
        # 倒序遍历，因为要优先返回二维数组中靠后的那条边
        for i in range(n - 1, -1, -1):
            if inDegree[edges[i][1]] == 2:
                candidates.append(i)

        # 情况 1 / 2：存在入度为 2 的点
        if candidates:
            # 先尝试删后面那条（下标大的先入 candidates[0]）
            if self._isTreeAfterRemoveEdge(edges, n, candidates[0]):
                return edges[candidates[0]]
            else:
                return edges[candidates[1]]

        # 情况 3：没有入度为 2 的点，一定存在有向环，找到构成环的那条边
        return self._getRemoveEdge(edges, n)
```
# [947. 移除最多的同行或同列石头](https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/)

•	这个并查集里，同一集合里的元素，表示“这些行和列在图上是连通的”，也就是属于同一个连通分量。
•	这种“连通”的性质，在代码中通过：
•	join 把两个点的根合并，
•	find 让同一连通块里的所有点指向同一个根，
•	最后用根的去重（umap[find(x)]）来体现。


```python
from typing import List

class UnionFind:
    def __init__(self, n: int):
        # 初始化时每个元素的父节点都是自己
        self.father = [i for i in range(n)]

    def find(self, u: int) -> int:
        # 路径压缩版本的 find
        if self.father[u] != u:
            self.father[u] = self.find(self.father[u])
        return self.father[u]

    def isSame(self, u: int, v: int) -> bool:
        # 判断两个点是否在同一集合
        return self.find(u) == self.find(v)

    def join(self, u: int, v: int):
        # 合并两个集合（把 v 的根挂到 u 的根上）
        u = self.find(u)
        v = self.find(v)
        if u == v:
            return
        self.father[v] = u


class Solution:
    def removeStones(self, stones: List[List[int]]) -> int:
        # 行和列都在 [0, 10000]，列统一偏移一个 OFFSET
        OFFSET = 10000+1
        N = 20005              # 对应你 C++ 里的 n = 20005
        uf = UnionFind(N)

        # 1. 把每块石头的 行节点x 和 列节点(y+OFFSET) 连在一起
        for x, y in stones:
            uf.join(x, y + OFFSET)

        # 2. 统计所有出现过的行/列节点的根，一共有多少个连通块
        roots = set()
        for x, y in stones:
            roots.add(uf.find(x))
            roots.add(uf.find(y + OFFSET))

        # 3. 答案 = 石头总数 - 连通块个数
        return len(stones) - len(roots)
```

# [1202. 交换字符串中的元素](https://leetcode.cn/problems/smallest-string-with-swaps/)

只要连通在一起就可以互相交换了，这些互相交换了，就找最小顺序就好了，这就是并查集的用处所在

![fig](https://leetcode.com/problems/smallest-string-with-swaps/Figures/1202/Slide1.png)

Therefore, we can break the solution down into four steps: build a graph using the given pairs, find the connected components in the graph, sort the characters in each connected component in ascending order, and build the smallest string.

```java
class Solution {
    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {
        UnionFind uf = new UnionFind(s.length());

        // Iterate over the edges
        for (List<Integer> edge : pairs) {
            int source = edge.get(0);
            int destination = edge.get(1);
            
            // Perform the union of end points
            uf.union(source, destination);
        }
        
        Map<Integer, List<Integer>> rootToComponent = new HashMap<>();
        // Group the vertices that are in the same component
        for (int vertex = 0; vertex < s.length(); vertex++) {
            int root = uf.find(vertex);
            // Add the vertices corresponding to the component root
            rootToComponent.putIfAbsent(root, new ArrayList<>());
            rootToComponent.get(root).add(vertex);
        }
        
        // String to store the answer
        char[] smallestString = new char[s.length()];
        // Iterate over each component
        for (List<Integer> indices : rootToComponent.values()) {
            // Sort the characters in the group
            List<Character> characters = new ArrayList<>();
            for (int index : indices) {
                characters.add(s.charAt(index));
            }
            Collections.sort(characters);
            
            // Store the sorted characters
            for (int index = 0; index < indices.size(); index++) {
                smallestString[indices.get(index)] = characters.get(index);
            }
        }
        
        return new String(smallestString);
    }
}

class UnionFind {
    private int[] root;
    private int[] rank;

    // Initialize the array root and rank
    // Each vertex is representative of itself with rank 1
    public UnionFind(int size) {
        root = new int[size];
        rank = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = 1;
        }
    }

    // Get the root of a vertex
    public int find(int x) {
        if (x == root[x]) {
            return x;
        }
        return root[x] = find(root[x]);
    }

    // Perform the union of two components
    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            if (rank[rootX] >= rank[rootY]) {
                root[rootY] = rootX;
                rank[rootX] += rank[rootY];
            } else {
                root[rootX] = rootY;
                rank[rootY] += rank[rootX];
            }
        }
    }
}
```
# [721. 账户合并](https://leetcode.cn/problems/accounts-merge/)

看答案吧，并查集或者dfs都是很好的方法

# [1258. Synonymous Sentences](https://leetcode.com/problems/synonymous-sentences/)

不需要限制于整数
```python
class Solution:
    def generateSentences(self, synonyms: List[List[str]], text: str) -> List[str]:
        uf = {}
        
        def union(x, y):
            uf[find(y)] = find(x)
            
        def find(x):
            uf.setdefault(x, x)
            if uf[x]!=x:
                uf[x] = find(uf[x])
            return uf[x]
        
        for a,b in synonyms:
            union(a, b)
            
        d = collections.defaultdict(set)
        for a, b in synonyms:
            root = find(a)
            d[root] |= set([a, b])
        txt = text.split()
        res = []
        for t in txt:
            if t not in uf:
                res.append([t])
            else:
                r = find(t)
                res.append(list(d[r]))
        fin_res = [" ".join(sentence) for sentence in itertools.product(*res)]
        return sorted(fin_res)
```