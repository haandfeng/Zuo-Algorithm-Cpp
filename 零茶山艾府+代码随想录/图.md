
# [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)


dfs很简单，主要是这道题的解题思路：
怎么找到一座新的岛屿呢？只有那个数字是1，并且没被visited过，就说明是新的岛屿。这个时候就需要对这个岛屿进行dfs，把它的所有相邻的陆地visited
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid or not grid[0]:
            return 0
        m, n = len(grid), len(grid[0])
        visited = [[False] * n for _ in range(m)]
        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        def dfs(i: int, j: int) -> None:
            # 先判越界
            if i < 0 or i >= m or j < 0 or j >= n:
                return
            # 不是陆地或已访问，返回
            if grid[i][j] != '1' or visited[i][j]:
                return

            visited[i][j] = True
            for dr, dc in dirs:
                dfs(i + dr, j + dc)

        cnt = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1' and not visited[i][j]:
                    cnt += 1
                    dfs(i, j)
        return cnt
```

# [695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)
和上一题差不多

```python
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        if not grid or not grid[0]:
            return 0
        m, n = len(grid), len(grid[0])
        visited = [[False] * n for _ in range(m)]
        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        self.area = 0
        res = 0
        def dfs(i:int, j:int) -> None:
            if i<0 or i>=m or j<0 or j>=n:
                return
            if grid[i][j] != '1' or visited[i][j]:
                return
            self.area+=1
            visited[i][j] = True
            for row,col in dirs:
                dfs(i+row,j+col)

        for i in range(m):
            for j in range(n):
                if not visited[i][j] and grid[i][j]=='1':
                    self.area=0
                    dfs(i,j)
                    res = max(self.area,res)
        return res

```
# [卡码网：101. 孤岛的总面积](https://kamacoder.com/problempage.php?pid=1173)
反向思考，不是孤岛更好解决：
1.从border出发的岛都不是孤岛
2.从飞其他地方出发的岛就是孤岛
把不是孤岛染色成2。染完后找1就好了


# [卡码网：102. 沉没孤岛](https://kamacoder.com/problempage.php?pid=1174)
一样的思路

# [卡码网：103. 水流问题](https://kamacoder.com/problempage.php?pid=1175)


# [827. 最大人工岛](https://leetcode.cn/problems/making-a-large-island/)

主要思路就是先把每一个岛标号色，这样就不需要重复计算岛的面积，只要看相邻的有哪些岛就好了，这样就可以连起来了
```python
class Solution:
    def largestIsland(self, grid: List[List[int]]) -> int:
        n = len(grid)
        def dfs(i: int, j: int) -> int:
            size = 1
            grid[i][j] = len(area) + 2  # 记录 (i,j) 属于哪个岛
            for x, y in (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1):
                if 0 <= x < n and 0 <= y < n and grid[x][y] == 1:
                    size += dfs(x, y)
            return size

        # DFS 每个岛，统计各个岛的面积，记录到 area 列表中
        area = []
        for i, row in enumerate(grid):
            for j, x in enumerate(row):
                if x == 1:
                    area.append(dfs(i, j))

        # 加上这个特判，可以快很多
        if not area:  # 没有岛
            return 1

        ans = 0
        for i, row in enumerate(grid):
            for j, x in enumerate(row):
                if x: continue
                s = set()
                for x, y in (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1):
                    if 0 <= x < n and 0 <= y < n and grid[x][y]:
                        s.add(grid[x][y])  # 记录上下左右格子所属岛屿编号
                ans = max(ans, sum(area[idx - 2] for idx in s) + 1)  # 累加面积

        # 如果最后 ans 仍然为 0，说明所有格子都是 1，返回 n^2
        return ans if ans else n * n
```


# [463. 岛屿的周长](https://leetcode.cn/problems/island-perimeter/)

算周长只需要统计有几个岛屿就好了


```python
class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        ans = 0
        for i, row in enumerate(grid):
            for j, x in enumerate(row):
                if x == 0:
                    continue
                if i == 0 or grid[i - 1][j] == 0:  # 上：出界或者是水
                    ans += 1
                if i == m - 1 or grid[i + 1][j] == 0:  # 下：出界或者是水
                    ans += 1
                if j == 0 or row[j - 1] == 0:  # 左：出界或者是水
                    ans += 1
                if j == n - 1 or row[j + 1] == 0:  # 右：出界或者是水
                    ans += 1
        return ans
```


# [207. 课程表](https://leetcode.cn/problems/course-schedule/)
拓扑排序经典题目，主要是要考虑两个点
1. 如何存图->用邻接表/邻接矩阵
2. 如果管理依赖关系->通过出度入度处理依赖关系
```python
from typing import List          # 支持函数参数类型标注 List[List[int]]from collections import defaultdict, deque  # 用到 defaultdict 和 dequeclass Solution: 
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:  
        graph = defaultdict(list)  
        degree = [0] * numCourses  
        queue = deque()  
        result = []  
        for course, pre in prerequisites:  
            graph[pre].append(course)  
            degree[course] += 1  
        for index, value in enumerate(degree):  
            if value == 0:  
                queue.append(index)  
        while len(queue) != 0:  
            index = queue.popleft()  
            for value in graph[index]:  
                degree[value] -= 1  
                if degree[value] == 0:  
                    queue.append(value)  
            result.append(index)  
        if len(result) == numCourses:  
            return True  
        else:  
            return False
```

# [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)
和上一题一样

```python
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        graph = defaultdict(list)
        degree = [0] * numCourses
        queue = deque()
        result = []
        for course, pre in prerequisites:
            graph[pre].append(course)
            degree[course] += 1
        for index, value in enumerate(degree):
            if value == 0:
                queue.append(index)
        while len(queue) != 0:
            index = queue.popleft()
            for value in graph[index]:
                degree[value] -= 1
                if degree[value] == 0:
                    queue.append(value)
            result.append(index)
        if len(result) == numCourses:
            return result
        else:
            return []

```


# 并查集

下面的是并查集的问题


# [1971. 寻找图中是否存在路径](https://leetcode.cn/problems/find-if-path-exists-in-graph/)
就是实现一遍并查集，然后放在一起就好了
```python
class UnionFind:
    def __init__(self, n: int):
        # 初始化时每个元素的父节点都是自己
        self.father = [i for i in range(n)]

    def find(self, u: int) -> int:
        # 路径压缩版本的 find
        if self.father[u] != u:
            self.father[u] = self.find(self.father[u])
        return self.father[u]

    def isSame(self, u: int, v: int) -> bool:
        # 判断两个点是否在同一集合
        return self.find(u) == self.find(v)

    def join(self, u: int, v: int):
        # 合并两个集合（把 v 的根挂到 u 的根上）
        u = self.find(u)
        v = self.find(v)
        if u == v:
            return
        self.father[v] = u
class Solution:
    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:
        uf = UnionFind(n)

        # 把所有边都连起来
        for u, v in edges:
            uf.join(u, v)

        # 判断 source 和 destination 是否在同一个连通块里
        return uf.isSame(source, destination)
```
# [684. 冗余连接](https://leetcode.cn/problems/redundant-connection/)


# [685. 冗余连接 II](https://leetcode.cn/problems/redundant-connection-ii/)


# [947. 移除最多的同行或同列石头](https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/)



# [1202. 交换字符串中的元素](https://leetcode.cn/problems/smallest-string-with-swaps/)


# [721. 账户合并](https://leetcode.cn/problems/accounts-merge/)


# [1258. Synonymous Sentences](https://leetcode.com/problems/synonymous-sentences/)
