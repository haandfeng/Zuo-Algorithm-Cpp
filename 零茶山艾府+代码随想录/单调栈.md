#0x3f  #单调栈 
要计算的内容涉及上一个或下一个更大的元素的时候，考虑用单调栈
# [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

找到下一个比现在栈顶元素大的元素就出栈
思路看视频，总体思路是就是，如果栈顶元素比自己大，就把自己压入，不然就弹出栈顶，直到栈顶元素比自己小
```java
public int[] dailyTemperatures(int[] temperatures) {  
    Stack<Integer> stack = new Stack<>();  
    int[] ans = new int[temperatures.length];  
    for(int i = 0; i < temperatures.length; i++){  
        if (stack.empty()){  
            stack.push(i);  
        }else if(temperatures[i] > temperatures[stack.peek()]){  
            while(!stack.empty() && temperatures[i] > temperatures[stack.peek()]){  
                ans[stack.peek()] = i - stack.peek();  
                stack.pop();  
            }  
            stack.push(i);  
        }else {  
            stack.push(i);  
        }  
    }  
    while(!stack.empty()){  
        ans[stack.peek()] = 0;  
        stack.pop();  
    }  
    return ans;  
}
```


一样的思路，python要简单很多
```python
class Solution:
    def dailyTemperatures(self, temperatures):
        stack = []
        res = [0] * len(temperatures)
        for i, v in enumerate(temperatures):
            if not stack:
                stack.append(i)
                continue
            while stack and v > temperatures[stack[-1]]:
                res[stack[-1]] = i - stack[-1]
                stack.pop()
            stack.append(i)
        return res
```
# [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)


默写了很多次了。记住 使用单调栈方法的时候，一开始的stack第一个元素是mid，下一个元素是left。当前遍历到的元素是right。然后算面积
```python
class Solution:
    def trap(self, height: List[int]) -> int:
        stack = []
        ans = 0
        for i,v in enumerate(height):
            if not stack:
                stack.append(i)
                continue
            while stack and v > height[stack[-1]]:
                right = i
                mid = stack[-1]
                stack.pop()
                if not stack:
                    continue
                left = stack[-1]
                area = (right-left-1) * (min(height[left],height[right])-height[mid])
                ans +=area
            stack.append(i)
        return ans
```
# [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

先找nums2的下一个更大元素，然后nums1匹配

```python
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        idx = {x: i for i, x in enumerate(nums1)}
        ans = [-1] * len(nums1)
        st = []
        for x in nums2:
            while st and x > st[-1]:
                # x 是栈顶的下一个更大元素
                # 既然栈顶已经算出答案，弹出
                ans[idx[st.pop()]] = x  # 记录答案
            if x in idx:  # x 在 nums1 中
                st.append(x)  # 只需把在 nums1 中的元素入栈
        return ans
```

# [503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)

两种思路，思路一，对于循环问题，把数组拼起来，拼两次
思路二，循环两次，下面是思路2的代码
```python
class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        stack = []
        ans = [-1] * len(nums)
        for i in range(2 * len(nums)):
            i = i  %  len(nums)
            if not stack:
                stack.append(i)
                continue
            while stack and nums[i] > nums[stack[-1]]:
                ans[stack[-1]] = nums[i]
                stack.pop()
            stack.append(i)
        return ans
```
# [901. 股票价格跨度](https://leetcode.cn/problems/online-stock-span/)
一样，只是自己设计数据结构存储price和index
```python
class StockSpanner:
    def __init__(self):
        self.stack = [(-1, inf)]  # 这样无需判断栈为空的情况
        self.cur_day = -1  # 第一个 next 调用算作第 0 天

    def next(self, price: int) -> int:
        while price >= self.stack[-1][1]:
            self.stack.pop()  # 栈顶数据后面不会再用到了，因为 price 更大
        self.cur_day += 1
        self.stack.append((self.cur_day, price))
        return self.cur_day - self.stack[-2][0]
```
# [1019. 链表中的下一个更大节点](https://leetcode.cn/problems/next-greater-node-in-linked-list/)

我的第一个思路，转成数组，用的是评论区代码。这题难在，找到了右边比他大的数字，需要怎么定位栈里面的的数字。
转数组是一种方法，栈里面可以既存数字，也存下标
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def nextLargerNodes(self, head: Optional[ListNode]) -> List[int]:
        # 链表转成数组
        tmp = []

        while head:
            tmp.append(head.val)
            head = head.next

        st = []
        ans = [0] * len(tmp)

        for i, x in enumerate(tmp):
            while st and x > tmp[st[-1]]:
                ans[st[-1]] = x
                st.pop()
            st.append(i)
        return ans
```

我们可以可以考虑从右到左遍历，这样子就可以首先保存右边更大的数字，到了左边后，就自然而然的获得了下标

![1019-1-c.png|475](https://pic.leetcode.cn/1681051452-jbvxIo-1019-1-c.png)

```python
class Solution:
    def nextLargerNodes(self, head: Optional[ListNode]) -> List[int]:
        ans = []
        st = []  # 单调栈（节点值）
        def f(node: Optional[ListNode], i: int) -> None:
            if node is None:
                nonlocal ans
                ans = [0] * i  # i 就是链表长度
                return
            f(node.next, i + 1)
            while st and st[-1] <= node.val:
                st.pop()  # 弹出无用数据
            if st:
                ans[i] = st[-1]  # 栈顶就是第 i 个节点的下一个更大元素
            st.append(node.val)
        f(head, 0)
        return ans
```

# [1944. 队列中可以看到的人数](https://leetcode.cn/problems/number-of-visible-people-in-a-queue/)

我的思路是先找到每个人比他大的数字的文字。随后再找从自己的右边开始到比自身大的数字的递增的数字个数

时间复杂度超了，在找人的时候是O(n^2)

```python
class Solution:
    def canSeePersonsCount(self, heights: List[int]) -> List[int]:
        stack = []
        n = len(heights)
        ans = [n] * n
        ret = [0] * n
        for i in range(n):
            if not stack:
                stack.append(i)
                continue
            while stack and heights[i] > heights[stack[-1]]:
                ans[stack[-1]] = i
                stack.pop()
            stack.append(i)
        for i in range(n - 1):
            larger_index = ans[i]
            cnt = 1
            largest = heights[i + 1]
            for j in range(i + 2, larger_index + 1):
                if j >= n:
                    break
                if heights[j] > largest:
                    largest = heights[j]
                    cnt += 1
            ret[i] = cnt
        return ret
```

为方便描述，下文将 heights 简记为 h。

如果暴力枚举，对于每个 i，我们需要遍历 i 右边所有的 j，一个一个地判断是否满足题目要求。

怎么优化？如果某个 j 一定不会被 i 看到，我们就不需要去遍历这样的 j 了。根据题目要求，如果在 i 和 j 之间，存在一个 k，使得 h[k]>h[j]，那么 j 就一定不会被 i 看到。注意题目保证所有元素互不相同，无需处理身高相等的情况。

从右往左遍历 h，如果发现一个 h[k] 比右边的数 h[j] 大，那么 h[k] 就把 h[j]「挡住」，k 左边的人再也不会看到 j 了。

这启发我们用一个数据结构（栈）维护没有被挡住的人的身高。对于那些被挡住的人，永远不会去遍历他们了（及时去掉无用数据）。

看示例 1：

| i | h[i] | 入栈前 | 入栈后 | ans[i] | 解释 |
|---|------|--------|--------|---------|------|
| 5 | 9 | [] | [9] | 0 | |
| 4 | 11 | [9] | [11] | 1 | 11 挡住 9 |
| 3 | 5 | [11] | [11, 5] | 1 | |
| 2 | 8 | [11,5] | [11,8] | 2 | 8 挡住 5 |
| 1 | 6 | [11,8] | [11,8,6] | 1 | |
| 0 | 10 | [11,8,6] | [11,10] | 3 | 10 挡住 8,6 |

---

从右往左遍历到 `i` 时，如果栈顶比 `h[i]` 小，就不断弹出栈顶，直到栈为空或者栈顶大于 `h[i]`

统计弹出的元素个数，作为第 `i` 个能看到的人数 `ans[i]`。  

出栈结束后，若栈不为空，说明第 `i` 个人还可以再看到一个人（栈顶），把 `ans[i]` 加一。  

对于比栈顶更靠右的人，由于栈顶比 `h[i]` 大，根据题目要求，`i` 无法看到比栈顶更靠右的人，所以无需遍历这些更靠右的人。

```python
class Solution:
    def canSeePersonsCount(self, heights: List[int]) -> List[int]:
        n = len(heights)
        ans = [0] * n
        st = []
        for i in range(n - 1, -1, -1):
            while st and st[-1] < heights[i]:
                st.pop()
                ans[i] += 1
            if st:  # 还可以再看到一个人
                ans[i] += 1
            st.append(heights[i])
        return ans
```
# [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)
假设 h=heights[i] 是矩形的高度，那么矩形的宽度最大是多少？我们需要知道：

在 i 左侧的小于 h 的最近元素的下标 left，如果不存在则为 −1。求出了 left，那么 left+1 就是矩形最左边那根柱子。
在 i 右侧的小于 h 的最近元素的下标 right，如果不存在则为 n。求出了 right，那么 right−1 就是矩形最右边那根柱子。

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        int[] left = new int[n];
        Deque<Integer> st = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            int x = heights[i];
            //一直弹出比自己大的元素
            while (!st.isEmpty() && x <= heights[st.peek()]) {
                st.pop();
            }
            //st为空，表示不存在比这个height左边小的柱子
            left[i] = st.isEmpty() ? -1 : st.peek();
            st.push(i);
        }

        int[] right = new int[n];
        st.clear();
        for (int i = n - 1; i >= 0; i--) {
            int x = heights[i];
            while (!st.isEmpty() && x <= heights[st.peek()]) {
                st.pop();
            }
            right[i] = st.isEmpty() ? n : st.peek();
            st.push(i);
        }

        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans = Math.max(ans, heights[i] * (right[i] - left[i] - 1));
        }
        return ans;
    }
}
```

思路和接雨水很像，但我还是没想出来

```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        heights.append(-1)  # 最后大火收汁，用 -1 把栈清空
        st = [-1]  # 在栈中只有一个数的时候，栈顶的「下面那个数」是 -1，对应 left[i] = -1 的情况
        ans = 0
        for right, h in enumerate(heights):
            while len(st) > 1 and heights[st[-1]] >= h:
                i = st.pop()  # 矩形的高（的下标）
                left = st[-1]  # 栈顶下面那个数就是 left
                ans = max(ans, heights[i] * (right - left - 1))
            st.append(right)
        return ans
```
# [1793. 好子数组的最大分数](https://leetcode.cn/problems/maximum-score-of-a-good-subarray/)


和上一题基本一样，我也差不多写出来了。但注意区间的开闭问题，和k的取舍

```python
class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        stack = []
        ret = 0
        for i, num in enumerate(nums):
            while stack and num < nums[stack[-1]]:
                mid = stack.pop()
                left = stack[-1] if stack else -1
                right = i
                if left < k < right:  # 注意严格不等式
                    ret = max(ret, nums[mid] * (right - left - 1))
            stack.append(i)

        n = len(nums)
        while stack:
            mid = stack.pop()
            left = stack[-1] if stack else -1
            right = n
            if left < k < right:  # 注意严格不等式
                ret = max(ret, nums[mid] * (right - left - 1))
        return ret
```



# [85. 最大矩形](https://leetcode.cn/problems/maximal-rectangle/)

直接调用 84 题代码解决
对于本题，设 matrix 有 m 行，我们可以枚举矩形的底边，做 m 次 84 题。
![lc85.png](https://pic.leetcode.cn/1750330058-gMdckr-lc85.png)

以第一行为底的柱子高度为 [1,0,1,0,0]，最大矩形面积为 1。
以第二行为底的柱子高度为 [2,0,2,1,1]，最大矩形面积为 3。
以第三行为底的柱子高度为 [3,1,3,2,2]，最大矩形面积为 6。
以第四行为底的柱子高度为 [4,0,0,3,0]，最大矩形面积为 4。
答案为 max(1,3,6,4)=6。
由于我们枚举的是矩形的底边，如果 matrix\[i]\[j]=0，那么没有柱子，高度等于 0。否则，在上一行柱子的基础上，把柱子高度增加 1。形象地说，就是在柱子下面垫一块石头，把柱子抬高

```python
class Solution:
    # 84. 柱状图中最大的矩形
    def largestRectangleArea(self, heights: List[int]) -> int:
        st = [-1]  # 在栈中只有一个数的时候，栈顶的「下面那个数」是 -1，对应 left[i] = -1 的情况
        ans = 0
        for right, h in enumerate(heights):
            while len(st) > 1 and heights[st[-1]] >= h:
                i = st.pop()  # 矩形的高（的下标）
                left = st[-1]  # 栈顶下面那个数就是 left
                ans = max(ans, heights[i] * (right - left - 1))
            st.append(right)
        return ans

    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        n = len(matrix[0])
        heights = [0] * (n + 1)  # 末尾多一个 0，理由见我 84 题题解
        ans = 0
        for row in matrix:
            # 计算底边为 row 的柱子高度
            for j, c in enumerate(row):
                if c == '0':
                    heights[j] = 0  # 柱子高度为 0
                else:
                    heights[j] += 1  # 柱子高度加一
            ans = max(ans, self.largestRectangleArea(heights))  # 调用 84 题代码
        return ans
        
```

