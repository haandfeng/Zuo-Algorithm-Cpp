#0x3f  #单调栈 
要计算的内容涉及上一个或下一个更大的元素的时候，考虑用单调栈
# [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

找到下一个比现在栈顶元素大的元素就出栈
思路看视频，总体思路是就是，如果栈顶元素比自己大，就把自己压入，不然就弹出栈顶，直到栈顶元素比自己小
```java
public int[] dailyTemperatures(int[] temperatures) {  
    Stack<Integer> stack = new Stack<>();  
    int[] ans = new int[temperatures.length];  
    for(int i = 0; i < temperatures.length; i++){  
        if (stack.empty()){  
            stack.push(i);  
        }else if(temperatures[i] > temperatures[stack.peek()]){  
            while(!stack.empty() && temperatures[i] > temperatures[stack.peek()]){  
                ans[stack.peek()] = i - stack.peek();  
                stack.pop();  
            }  
            stack.push(i);  
        }else {  
            stack.push(i);  
        }  
    }  
    while(!stack.empty()){  
        ans[stack.peek()] = 0;  
        stack.pop();  
    }  
    return ans;  
}
```


一样的思路，python要简单很多
```python
class Solution:
    def dailyTemperatures(self, temperatures):
        stack = []
        res = [0] * len(temperatures)
        for i, v in enumerate(temperatures):
            if not stack:
                stack.append(i)
                continue
            while stack and v > temperatures[stack[-1]]:
                res[stack[-1]] = i - stack[-1]
                stack.pop()
            stack.append(i)
        return res
```
# [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)


默写了很多次了。记住 使用单调栈方法的时候，一开始的stack第一个元素是mid，下一个元素是left。当前遍历到的元素是right。然后算面积
```python
class Solution:
    def trap(self, height: List[int]) -> int:
        stack = []
        ans = 0
        for i,v in enumerate(height):
            if not stack:
                stack.append(i)
                continue
            while stack and v > height[stack[-1]]:
                right = i
                mid = stack[-1]
                stack.pop()
                if not stack:
                    continue
                left = stack[-1]
                area = (right-left-1) * (min(height[left],height[right])-height[mid])
                ans +=area
            stack.append(i)
        return ans
```
# [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

先找nums2的下一个更大元素，然后nums1匹配

```python
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        idx = {x: i for i, x in enumerate(nums1)}
        ans = [-1] * len(nums1)
        st = []
        for x in nums2:
            while st and x > st[-1]:
                # x 是栈顶的下一个更大元素
                # 既然栈顶已经算出答案，弹出
                ans[idx[st.pop()]] = x  # 记录答案
            if x in idx:  # x 在 nums1 中
                st.append(x)  # 只需把在 nums1 中的元素入栈
        return ans
```

# [503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)

两种思路，思路一，对于循环问题，把数组拼起来，拼两次
思路二，循环两次，下面是思路2的代码
```python
class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        stack = []
        ans = [-1] * len(nums)
        for i in range(2 * len(nums)):
            i = i  %  len(nums)
            if not stack:
                stack.append(i)
                continue
            while stack and nums[i] > nums[stack[-1]]:
                ans[stack[-1]] = nums[i]
                stack.pop()
            stack.append(i)
        return ans
```
# [901. 股票价格跨度](https://leetcode.cn/problems/online-stock-span/)
一样，只是自己设计数据结构存储price和index
```python
class StockSpanner:
    def __init__(self):
        self.stack = [(-1, inf)]  # 这样无需判断栈为空的情况
        self.cur_day = -1  # 第一个 next 调用算作第 0 天

    def next(self, price: int) -> int:
        while price >= self.stack[-1][1]:
            self.stack.pop()  # 栈顶数据后面不会再用到了，因为 price 更大
        self.cur_day += 1
        self.stack.append((self.cur_day, price))
        return self.cur_day - self.stack[-2][0]
```
# [1019. 链表中的下一个更大节点](https://leetcode.cn/problems/next-greater-node-in-linked-list/)



# [1944. 队列中可以看到的人数](https://leetcode.cn/problems/number-of-visible-people-in-a-queue/)






# [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)
假设 h=heights[i] 是矩形的高度，那么矩形的宽度最大是多少？我们需要知道：

在 i 左侧的小于 h 的最近元素的下标 left，如果不存在则为 −1。求出了 left，那么 left+1 就是矩形最左边那根柱子。
在 i 右侧的小于 h 的最近元素的下标 right，如果不存在则为 n。求出了 right，那么 right−1 就是矩形最右边那根柱子。

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        int[] left = new int[n];
        Deque<Integer> st = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            int x = heights[i];
            //一直弹出比自己大的元素
            while (!st.isEmpty() && x <= heights[st.peek()]) {
                st.pop();
            }
            //st为空，表示不存在比这个height左边小的柱子
            left[i] = st.isEmpty() ? -1 : st.peek();
            st.push(i);
        }

        int[] right = new int[n];
        st.clear();
        for (int i = n - 1; i >= 0; i--) {
            int x = heights[i];
            while (!st.isEmpty() && x <= heights[st.peek()]) {
                st.pop();
            }
            right[i] = st.isEmpty() ? n : st.peek();
            st.push(i);
        }

        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans = Math.max(ans, heights[i] * (right[i] - left[i] - 1));
        }
        return ans;
    }
}
```


#  [1793. 好子数组的最大分数](https://leetcode.cn/problems/maximum-score-of-a-good-subarray/)






# [85. 最大矩形](https://leetcode.cn/problems/maximal-rectangle/)