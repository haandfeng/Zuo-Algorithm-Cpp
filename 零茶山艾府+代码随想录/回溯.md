#0x3f #回溯 

回溯法，一般可以解决如下几种问题：
- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

回溯算法模板框架如下：
```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

通过递归实现通量构造答案
回溯3问
1. 当前操作？/  每一步的操作是什么
2. 子问题？
3. 下一个子问题？

# [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)
三问：
1. 枚举path[i]要填入的字母
2. 构造字符串>=i的部分
3. 构造字符串>=i+1的部分
dfs(i) -> dfs(i+1)

首先构造一个数组mapping数组和字母呢

# [78. 子集](https://leetcode.cn/problems/subsets/)

## 方法一
三问
1. 枚举第i个数 选/不选
2. 从下标 >=i的数字中构造子集
3. 从下标>=i+1的数字中构造子集

## 方法二
1. 枚举一个下标j>=i的数字，加入path
2. 从下标>=i的数字中构造子集
3. 从下标>=j+1的数字中构造子集
# [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)
## 方法一
1. 枚举回文字串[i,j]，加入path
2. 从下标>=i的后缀中构造回文分割
3. 从下标>=j+1的后缀中构造回文分割

## 方法二
选or不选
# 左链接
[[排列组合]]