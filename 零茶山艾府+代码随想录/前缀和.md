
# [303. 区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/)
模版题

需要注意，prefix的数字数量是n+1，prefix[0] = 0，这样可以有效避免特殊情况
```python
class NumArray:
    def __init__(self, nums: List[int]):
        s = [0] * (len(nums) + 1)
        for i, x in enumerate(nums):
            s[i + 1] = s[i] + x
        self.s = s

    def sumRange(self, left: int, right: int) -> int:
        return self.s[right + 1] - self.s[left]
```

**库函数版**
```python
class NumArray:
    def __init__(self, nums: List[int]):
        self.s = list(accumulate(nums, initial=0))

    def sumRange(self, left: int, right: int) -> int:
        return self.s[right + 1] - self.s[left]
```

`accumulate(iterable, func=operator.add, *, initial=None)`
- 会对序列做“累积计算”，默认是累加
- 如果给了 initial，会把这个初始值放在结果最前面
```python
from itertools import accumulate

nums = [1, 2, 3, 4]
print(list(accumulate(nums)))             # [1, 3, 6, 10] 前缀和
print(list(accumulate(nums, initial=0)))  # [0, 1, 3, 6, 10] 带初始值
```

答疑
问：为什么要定义 s[0]=0，这样做有什么好处？

答：如果 left=0，要计算的子数组是一个前缀（从 a[0] 到 a[right]）。按照公式，我们要用 s[right+1] 减去 s[0]。如果不定义 s[0]=0，就必须特判 left=0 的情况了（读者可以试试）。通过定义 s[0]=0，任意子数组（包括前缀）都可以表示为两个前缀和的差。此外，如果 a 是空数组，定义 s[0]=0 的写法是可以兼容这种情况的。


# [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

[[Hot100#[560. 和为 K 的子数组](https //leetcode.cn/problems/subarray-sum-equals-k/)]]



# [2602. 使数组元素全部相等的最少操作次数](https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/)

首先最暴力的办法就是每一个数字遍历->然后和每个q进行比较
但这样就会重复遍历很多次数组

因为是两种操作，一个是inc，一个是dec。如果只有其中一种都好办

可以考虑一下的思路，把它分成两种

![[Pasted image 20250915144139.png|225]]

bisect_left回返回第一个大于等于q的下表
```python
class Solution:
    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:
        n = len(nums)
        nums.sort()
        s = list(accumulate(nums, initial=0))  # 前缀和
        ans = []
        for q in queries:
            j = bisect_left(nums, q)
            left = q * j - s[j]  # 蓝色面积
            right = s[n] - s[j] - q * (n - j)  # 绿色面积
            ans.append(left + right)
        return ans
```


# [304. 二维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/)

改成二维，是一样的
```python
class NumMatrix:  
  
    def __init__(self, matrix: List[List[int]]):  
        self.prefix = [[0] * (len(matrix[0])+1) for _ in range(len(matrix))]  
        for i in range(len(matrix)):  
            for j in range(len(matrix[0])):  
                self.prefix[i][j+1] = self.prefix[i][j] + matrix[i][j]  
  
    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:  
        sum = 0  
        for i in range(row1,row2+1):  
            sum += self.prefix[i][col2+1] - self.prefix[i][col1]  
        return sum
```


# [307. 区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/)

不会，很复杂。树状数组，看答案吧
```python
class NumArray:
    __slots__ = 'nums', 'tree'

    def __init__(self, nums: List[int]):
        n = len(nums)
        tree = [0] * (n + 1)
        for i, x in enumerate(nums, 1):  # i 从 1 开始
            tree[i] += x
            nxt = i + (i & -i)  # 下一个关键区间的右端点
            if nxt <= n:
                tree[nxt] += tree[i]
        self.nums = nums
        self.tree = tree

    def update(self, index: int, val: int) -> None:
        delta = val - self.nums[index]
        self.nums[index] = val
        i = index + 1
        while i < len(self.tree):
            self.tree[i] += delta
            i += i & -i

    def prefixSum(self, i: int) -> int:
        s = 0
        while i:
            s += self.tree[i]
            i &= i - 1  # i -= i & -i 的另一种写法
        return s

    def sumRange(self, left: int, right: int) -> int:
        return self.prefixSum(right + 1) - self.prefixSum(left)
```


# [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)

[[Hot100#[560. 和为 K 的子数组](https //leetcode.cn/problems/subarray-sum-equals-k/)]]

我认为主要思路是: 明显是要求一个区间的和->前缀和。但具体要求哪个区间并不知道，可能是多个区间。但数学公式是不变的，是 si - sj = k 。 所以思考成两数之和



