 #0x3f  #二叉树 #二叉树遍历 #二叉树的递归套路 

递归：
	递：从原问题出发，把问题分解成更小的子问题（思考整棵树和左右子树的关系）
	归：递下去的尽头（边界条件），返回答案，但要思考自身，和子问题的关系
- 涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。
- 求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。
- 求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了
# [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
[[二叉树的最大深度]]
## 自底向上（后序遍历）
```c++
int maxDepth(TreeNode* root) {  
    if (root == nullptr) return 0;  
    int left = maxDepth(root->left);  
    int right = maxDepth(root->right);  
    return max(left, right) + 1;  
}
```

## 自顶向下（先序遍历）
3. `auto dfs = [&](this auto&& dfs, TreeNode* node, int depth) -> void`定义了一个递归的匿名函数 dfs，采用 C++14 引入的**泛型 Lambda**，允许在 Lambda 内部进行递归调用。

• this auto&& dfs：这是 Lambda 参数列表中的 **递归 Lambda 本身**，类似于函数指针，用于递归调用自身。

• TreeNode* node：当前递归遍历到的二叉树节点。

• int depth：当前递归的深度。

• -> void：表示 dfs 的返回类型是 void。


```c++
int maxDepth(TreeNode* root) {  
    int ans = 0;  
    auto dfs = [&](this auto&& dfs, TreeNode* node, int depth) -> void {  [
]()        if (node == nullptr) {  
            return;  
        }  
        depth++;  
        ans = max(ans, depth);  
        dfs(node->left, depth);  
        dfs(node->right, depth);  
    };  
    dfs(root, 0);  
    return ans;  
}
```

# [111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)
和最大深度差不多，可是要注意特殊情况，左子树或者右子树一边全部为空的时候，不能考虑他的高度为0 
```c++
int minDepth(TreeNode* root) {  
    if (root == nullptr) return 0;  
    int left = minDepth(root->left);  
    int right = minDepth(root->right);  
    if (left == 0) {return right+1;}  
    if (right == 0) {return left+1;}  
    return min(left, right)+1;  
}
```

# [222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)
[[求完全二叉树节点的个数]]
判断左子树是不是满二叉树，右子树是不是满二叉树
如果左子树的深度=右子树的深度，说明是这个数是满二叉树 节点的数量=2^n - 1  
注意 - 的计算优先级大于 <<
```c++
int countNodes(TreeNode* root) {  
    // 边界条件，防止root为空  
    if (root ==nullptr) return 0;  
    // 之后的所有边界条件，叶子就返回1，基准 叶子也是满二叉树  
    if (root->left == nullptr && root->right == nullptr) return 1;  
    // 判断是不是相同  
    int lH=0, rH=0;  
    TreeNode* l_node = root->left;  
    TreeNode* r_node = root->right;  
    while (l_node || r_node) {  
        if (l_node) {  
            l_node = l_node->left;  
            ++lH;  
        }  
        if (r_node) {  
            r_node = r_node->right;  
            ++rH;  
        }  
    }  
    if (lH == rH) {  
        return (2 << lH) - 1;  
    }  
    return 1+ countNodes(root->left) + countNodes(root->right);  
}
```
# [112. 路径总和](https://leetcode.cn/problems/path-sum/)

注意要判断是不是叶子节点，我审错题目了，还有题目给的函数没能传递sum，要传递
```c++
bool getSum(TreeNode* root, int sum, int target) {  
    if (root == nullptr) return false;  
    sum += root->val;  
    if (sum == target && root->left==nullptr && root->right==nullptr) {return true;}  
    return getSum(root->left, sum, target) || getSum(root->right, sum, target);  
}  
bool hasPathSum(TreeNode* root, int targetSum) {  
    if (root == nullptr) return false;  
    int sum = 0;  
    return  getSum(root,sum,targetSum);  
}
```

0x3f
比我的简单，可以用删除，就倒着减少了
```c++
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if (root == nullptr) {
            return false;
        }
        targetSum -= root->val;
        if (root->left == root->right) { // root 是叶子
            return targetSum == 0;
        }
        return hasPathSum(root->left, targetSum) || hasPathSum(root->right, targetSum);
    }
};
```

# [129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)

我认为用到了回溯的思想，把所有的可能的路径都加到了结果数组里面，然后计算结果
```c++
int getSum(vector<vector<int>> &allNumbers) {  
    int sum = 0;  
    for (int i = 0; i < allNumbers.size(); i++) {  
        long long mul = 1;  
        for (int j = allNumbers[i].size()-1 ; j >= 0; --j) {  
            sum += allNumbers[i][j]*mul;  
            mul *= 10;  
        }  
    }  
    return sum;  
}  
  
void getVector(vector<vector<int>> &allNumbers,TreeNode* root, vector<int>& now) {  
    if (root == nullptr) return;  
    now.push_back(root->val);  
    getVector(allNumbers, root->left,now);  
    getVector(allNumbers, root->right,now);  
    if (root->left==nullptr && root->right==nullptr) {  
        allNumbers.push_back(now);  
    }  
    now.pop_back();  
}  
int sumNumbers(TreeNode* root) {  
    vector<vector<int>> allNumbers;  
    vector<int> now;  
    getVector(allNumbers,root,now);  
    return getSum(allNumbers);  
}
```

0x3f

他对遍历到的数计算比我好，我对于信息的利用率太低了
对于路径 4→9→5，我们可以按照如下方式生成数字 495。

初始化 x=0。
从 4 开始递归，更新 x=x⋅10+4=4。
向下递归到 9，更新 x=x⋅10+9=49。
向下递归到 5，更新 x=x⋅10+5=495。


dfs没返回值
```c++
class Solution {
    int ans = 0;

    void dfs(TreeNode *node, int x) {
        if (node == nullptr) {
            return;
        }
        x = x * 10 + node->val;
        if (node->left == node->right) { // node 是叶子节点
            ans += x;
            return;
        }
        dfs(node->left, x);
        dfs(node->right, x);
    }

public:
    int sumNumbers(TreeNode *root) {
        dfs(root, 0);
        return ans;
    }
};
```


dfs有返回值
```c++
class Solution {
public:
    int sumNumbers(TreeNode *root, int x = 0) {
        if (root == nullptr) {
            return 0;
        }
        x = x * 10 + root->val;
        if (root->left == root->right) { // root 是叶子节点
            return x;
        }
        return sumNumbers(root->left, x) + sumNumbers(root->right, x);
    }
};
```

# [1448. 统计二叉树中好节点的数目](https://leetcode.cn/problems/count-good-nodes-in-binary-tree/)
解决的子问题是：
	已只max，判断自己是不是好节点，获得左子树有多少个好节点，右子树有多少个好节点
边界条件是：
	null返回0
```c++
int gN(TreeNode* root, int max) {  
    if (root == nullptr) return 0;  
    if (root->val >= max) {  
        max = root->val;  
        return gN(root->right, max)+gN(root->left,max)+1;  
    }  
    return gN(root->left, max)+gN(root->right,max);  
}  
int goodNodes(TreeNode* root) {  
    return gN(root,INT_MIN);  
}
```

0x3f
思路一致
```c++
class Solution {
public:
    int goodNodes(TreeNode *root, int mx = INT_MIN) {
        if (root == nullptr)
            return 0;
        int left = goodNodes(root->left, max(mx, root->val));
        int right = goodNodes(root->right, max(mx, root->val));
        return left + right + (mx <= root->val);
    }
};
```
# [987. 二叉树的垂序遍历](https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/)

有点懒了，而且处理结果的方法不好写，所以我选择直接看0x3f的思路。。


在 DFS 的同时，用一个哈希表（或者有序字典）来记录这些数据。哈希表的 key 是 col，哈希表的 value 是一个列表，列表中保存 (row,val) 二元组。

DFS 结束后，按照 key 从小到大遍历哈希表，对于哈希表的每个 value，把 value 中的二元组排序，最后取出 value 中的 val 加入答案

## 写法一
和我的想法差不多，但我觉得写得很麻烦
```c++
class Solution {
    map<int, vector<pair<int, int>>> groups;

    void dfs(TreeNode *node, int row, int col) {
        if (node == nullptr) {
            return;
        }
        // col 相同的分到同一组
        groups[col].emplace_back(row, node->val);
        dfs(node->left, row + 1, col - 1);
        dfs(node->right, row + 1, col + 1);
    }

public:
    vector<vector<int>> verticalTraversal(TreeNode *root) {
        dfs(root, 0, 0);
        vector<vector<int>> ans;
        for (auto &[_, g] : groups) {
            ranges::sort(g);
            vector<int> vals;
            for (auto &[_, val] : g) {
                vals.push_back(val);
            }
            ans.push_back(vals);
        }
        return ans;
    }
};
```

## 写法二
也可以在 DFS 的同时记录 col 的最小值，这样无需对 key 排序，也无需使用有序字典。
	所以可以用 `unordered_map` 加快运行效率
```c++
class Solution {
    unordered_map<int, vector<pair<int, int>>> groups;
    int min_col = 0;

    void dfs(TreeNode *node, int row, int col) {
        if (node == nullptr) {
            return;
        }
        min_col = min(min_col, col);
        groups[col].emplace_back(row, node->val);
        dfs(node->left, row + 1, col - 1);
        dfs(node->right, row + 1, col + 1);
    }

public:
    vector<vector<int>> verticalTraversal(TreeNode *root) {
        dfs(root, 0, 0);
        vector<vector<int>> ans;
        for (int i = min_col; i < min_col + (int) groups.size(); i++) {
            auto &g = groups[i];
            ranges::sort(g);
            vector<int> vals;
            for (auto &[_, val] : g) {
                vals.push_back(val);
            }
            ans.push_back(vals);
        }
        return ans;
    }
};
```

## 写法三
也可以用两个列表记录数据，一个列表 left 负责统计负数 col，另一个列表 right 负责统计非负数 col。
这样就可以不用map了
```c++
class Solution {
public:
    vector<vector<int>> verticalTraversal(TreeNode *root) {
        vector<vector<pair<int, int>>> left, right;
        function<void(TreeNode*, int, int)> dfs = [&](TreeNode *node, int row, int col) {
            if (node == nullptr) {
                return;
            }
            if (col < -(int) left.size()) {
                left.push_back({});
            } else if (col == right.size()) {
                right.push_back({});
            }
            (col < 0 ? left[-col - 1] : right[col]).emplace_back(row, node->val);
            dfs(node->left, row + 1, col - 1);
            dfs(node->right, row + 1, col + 1);
        };
        dfs(root, 0, 0);

        vector<vector<int>> ans;
        auto add = [&](vector<vector<pair<int, int>>> &a) {
            for (auto &g : a) {
                ranges::sort(g);
                vector<int> vals;
                for (auto &[_, val] : g) {
                    vals.push_back(val);
                }
                ans.push_back(vals);
            }
        };
        ranges::reverse(left);
        add(left);
        add(right);
        return ans;
    }
};
```

##  写法四

```c++
class Solution {
public:
    vector<vector<int>> verticalTraversal(TreeNode *root) {
        vector<tuple<int, int, int>> data;
        function<void(TreeNode*, int, int)> dfs = [&](TreeNode *node, int row, int col) {
            if (node == nullptr) {
                return;
            }
            data.emplace_back(col, row, node->val);
            dfs(node->left, row + 1, col - 1);
            dfs(node->right, row + 1, col + 1);
        };
        dfs(root, 0, 0);

        vector<vector<int>> ans;
        // std::tuple 的排序是按照 **字典序** 进行的，即
        ranges::sort(data);
        int last_col = INT_MIN;
        for (auto &[col, _, val]: data) {
            if (col != last_col) {
                last_col = col;
                ans.push_back({});
            }
            ans.back().push_back(val);
        }
        return ans;
    }
};
```
# [100. 相同的树](https://leetcode.cn/problems/same-tree/)
[[判断两颗树是否结构相同]]
解决的子问题是：
	左边两颗子树树否相同和右边两颗子树是否相同
边界条件是：
	是两颗树有一个是空的，就要判断是不是两个都是空
```c++
bool isSameTree(TreeNode* p, TreeNode* q) {  
    if (p == nullptr && q == nullptr) return true;  
    if (p == nullptr || q == nullptr) return false;  
    if (p->val != q->val) return false;  
    // 只要不存在val不相等的情况，这个一定返回true，所以不需要p->val == q->val
    return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);  
}
```

0x3f
```c++
class Solution {
public:
    bool isSameTree(TreeNode *p, TreeNode *q) {
        if (p == nullptr || q == nullptr)
            return p == q; // 必须都是 nullptr
        return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```
# [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)
[[对称二叉树]]
解决的子问题是：
	拆成左右两颗树，看根节点是否相等，然后递归左边的左子树和右边的右子树对比
边界条件是：
	是两颗树有一个是空的，就要判断是不是两个都是空

```c++
bool isSameTree(TreeNode* p, TreeNode* q) {  
    if (p == nullptr && q == nullptr) return true;  
    if (p == nullptr || q == nullptr) return false;  
    if (p->val != q->val) return false;  
    return isSameTree(p->left,q->right) && isSameTree(p->right,q->left);  
}  
  
bool isSymmetric(TreeNode* root) {  
    return isSameTree(root->left,root->right);  
}
```

0x3f
```c++
class Solution {
    // 在【100. 相同的树】的基础上稍加改动
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (p == nullptr || q == nullptr) {
            return p == q;
        }
        return p->val == q->val && isSameTree(p->left, q->right) && isSameTree(p->right, q->left);
    }

public:
    bool isSymmetric(TreeNode* root) {
        return isSameTree(root->left, root->right);
    }
};
```

# [572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)
感觉我的解法有点乱

```c++
bool iS(TreeNode* root, TreeNode* subRoot) {  
    if (root == nullptr && subRoot == nullptr) return true;  
    if (root == nullptr || subRoot == nullptr) return false;  
    if (root->val != subRoot->val) return false;  
    return iS(root->right, subRoot->right) && iS(root->left, subRoot->left);  
}  
  
// 检查 root 是否包含子树 subRootbool isSubtree(TreeNode* root, TreeNode* subRoot) {  
    if (root == nullptr && subRoot == nullptr) return true;  
    if (root == nullptr || subRoot == nullptr) return false;  
    if (root->val == subRoot->val) return iS(root, subRoot)||isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot);;  
    if (root->left == nullptr && root->right == nullptr) return false;  
    return isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot);  
}
```


题解：
而判断 t 是否为 s 的**子树**的三个条件是**或**的关系，即：

1. 当前两棵树相等；
2. 或者，t 是 s 的左子树；
3. 或者，t 是 s 的右子树。
```c++
class Solution {
public:
    bool check(TreeNode *o, TreeNode *t) {
        if (!o && !t) {
            return true;
        }
        if ((o && !t) || (!o && t) || (o->val != t->val)) {
            return false;
        }
        return check(o->left, t->left) && check(o->right, t->right);
    }

    bool dfs(TreeNode *o, TreeNode *t) {
        if (!o) {
            return false;
        }
        return check(o, t) || dfs(o->left, t) || dfs(o->right, t);
    }

    bool isSubtree(TreeNode *s, TreeNode *t) {
        return dfs(s, t);
    }
};
```
# [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)
[[判断是否是平衡搜索二叉树]]
[[判断二叉树是不是平衡二叉树]]
[[二叉树概念汇总#平衡二叉树|平衡二叉树]]
[[二叉树概念汇总#二叉搜索树- 搜索二叉树|搜索二叉树]]
平衡二叉树：左子树和有右子树的高度差不超过1
只要有一个子树不同，就立刻全部返回

解决的子问题是：
	拆成左右两颗树，看左数的高度差和右数的高度差
边界条件：
	节点为nullptr，要返回高度0，返回true
感觉我的很麻烦，浪费时间（重复获得高度了，就应该像0x3f的一样，每次递归的时候，就要获得判断结果是否符合要求）
```c++
int iB(TreeNode* root) {  
    if (root == nullptr) return 0;  
    return max(iB(root->left),iB(root->right))+1;  
}  
bool isBalanced(TreeNode* root) {  
    if (root == nullptr) return true;  
    int left = iB(root->left);  
    int right = iB(root->right);  
    return (abs(left-right)<=1)&& isBalanced(root->left) && isBalanced(root->right);  
}
```
0x3f
零神有了-1标记是否不平衡了，提高结果判断
一边获得树的高度， 一边判断大小
```c++
class Solution {
    int get_height(TreeNode *node) {
        if (node == nullptr) return 0;
        int leftH = get_height(node->left);
        if (leftH == -1) return -1; // 提前退出，不再递归
        int rightH = get_height(node->right);
        if (rightH == -1 || abs(leftH - rightH) > 1) return -1;
        return max(leftH, rightH) + 1;
    }

public:
    bool isBalanced(TreeNode *root) {
        return get_height(root) != -1;
    }
};

```
# [257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)
想清楚怎么遍历，每次要传递什么值，特殊情况
```c++
void bT(TreeNode* root,vector<string>& res, string s="") {  
    if (root == nullptr) return;  
    s.append(to_string(root->val)+"->");  
    if (root->left == nullptr && root->right == nullptr) {  
        s.resize(s.size() - 2);  
        res.push_back(s);  
    }  
    bT(root->left, res,s);  
    bT(root->right, res, s);  
}  
vector<string> binaryTreePaths(TreeNode* root) {  
    vector<string> res;  
    bT(root, res, "");  
    return res;  
}
```



# [404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)
前序遍历，参数里面有结果，终止条件是null返回， 中 要看是不是左叶子
```c++
void sLL(TreeNode* root, int&sum) {  
    if (root == nullptr) return;  
    if (root->left != nullptr) {  
        if (root->left->left==nullptr && root->left->right == nullptr) {  
            sum += root->left->val;  
        }  
    }  
    sLL(root->left, sum);  
    sLL(root->right, sum);  
}  
  
int sumOfLeftLeaves(TreeNode* root) {  
    int sum = 0;  
    sLL(root, sum);  
    return sum;  
}
```

卡尔哥是用后序遍历
返回值就是子树的左叶子节点的和，我把返回值放到了参数上
# [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

要解决两个问题：
1. 怎么把答案记下来
2. 记录哪个节点为答案->递归深度=答案位置

右视图：优先遍历右子树
```c++
int Vsize = 0 ;  
void rS(TreeNode* root, vector<int>& res, int depth) {  
    if (root == nullptr) return;  
    if (depth == Vsize) {  
        res.push_back(root->val);  
        ++Vsize;  
    }  
    rS(root->right,res,depth+1);  
    rS(root->left,res,depth+1);  
}  
vector<int> rightSideView(TreeNode* root) {  
    vector<int> res;  
    int depth = 0;  
    rS( root, res,depth );  
    return res;  
}
```

0x3f
先递归右子树，再递归左子树，当某个深度首次到达时，对应的节点就在右视图中。
```c++
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> ans;
        auto dfs = [&](this auto&& dfs, TreeNode* node, int depth) -> void {
            if (node == nullptr) {
                return;
            }
            if (depth == ans.size()) { // 这个深度首次遇到
                ans.push_back(node->val);
            }
            dfs(node->right, depth + 1); // 先递归右子树，保证首次遇到的一定是最右边的节点
            dfs(node->left, depth + 1);
        };
        dfs(root, 0);
        return ans;
    }
};
```
# [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)
[[翻转二叉树]]
解决的子问题是：
	拆成左右两颗树，看左子树，变成右子树，左子树的左边，编程右子树的右边，左子树的右边，变成右子树的左边
边界条件：
	节点为nullptr，返回nullptr

==但我不会处理一边为空的情况== 都一样，但我没有解析好子问题

0x3f的做法
对于根节点，它的左右儿子必须交换，即左儿子变成右儿子，右儿子变成左儿子。
对于根节点的左右子树，也需要翻转其内部节点。这是一个和原问题相似的子问题，看完视频后，你知道，这可以用递归解决。


```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr) {
            return nullptr;
        }
        auto left = invertTree(root->left); // 翻转左子树
        auto right = invertTree(root->right); // 翻转右子树
        root->left = right; // 交换左右儿子
        root->right = left;
        return root;
    }
};
```

# [617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)
[[合并二叉树]]
解决的子问题是：
	root节点的值相加。root1和root2的左右子树合并，root1 的左子树指向新合并的左子树，root1的右子树指向新合并的右子树
边界条件：
	节点为nullptr，返回nullptr

```c++
TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {  
    if (root1 == nullptr && root2 == nullptr) return nullptr;  
    if (root1 == nullptr && root2 != nullptr) {  
        root1 = root2;  
        return root1;  
    }  
    if (root1 != nullptr && root2 != nullptr) {  
        root1->val += root2->val;  
        root1->left = mergeTrees(root1->left, root2->left);  
        root1->right = mergeTrees(root1->right, root2->right);  
    }  
  
    return root1;  
}
```

0x3f

```c++
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        //root1 是空的，无需合并，直接返回root2
        if (root1 == nullptr) return root2;
        //root2 是空的，无需合并，直接返回root1
        if (root2 == nullptr) return root1;
        return new TreeNode(root1->val + root2->val,
            mergeTrees(root1->left, root2->left),    // 合并左子树
            mergeTrees(root1->right, root2->right)); // 合并右子树
    }
};
```
# [1026. 节点与其祖先之间的最大差值](https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/)

要解决的子问题
	当前节点已知的可能的最大差值，左子树的最大差值，右子树的最大差值，然后比较
边界条件
	 如果当前节点为空，表示不知道最大差值，返回0，回到上一个节点

```c++
int mA(TreeNode* root,int max, int min) {  
    if (root == nullptr) return 0;  
    if (root->val > max) max = root->val;  
    if (root->val < min) min = root->val;  
    int a = mA(root->left,max,min);  
    int b = mA(root->right,max,min);  
    int max_value = a > b ? a : b;  
    return max_value>max-min?max_value:max-min;  
}  
  
int maxAncestorDiff(TreeNode* root) {  
    return mA(root,INT_MIN,INT_MAX);  
}
```

0x3f
无需记录路径中的全部节点值，只需记录路径中的最小节点值 mn 和最大节点值 mx
![[Pasted image 20250110112018.png]]
方法一
```c++
class Solution {
    int ans = 0;

    void dfs(TreeNode *node, int mn, int mx) {
        if (node == nullptr) return;
        // 虽然题目要求「不同节点」，但是相同节点的差值为 0，不会影响最大差值
        // 所以先更新 mn 和 mx，再计算差值也是可以的
        // 在这种情况下，一定满足 mn <= node.val <= mx
        mn = min(mn, node->val);
        mx = max(mx, node->val);
        ans = max(ans, max(node->val - mn, mx - node->val));
        dfs(node->left, mn, mx);
        dfs(node->right, mn, mx);
    }

public:
    int maxAncestorDiff(TreeNode *root) {
        dfs(root, root->val, root->val);
        return ans;
    }
};
```

优化
换个角度看问题：对于一条从根出发向下的路径，我们要计算的实际上是这条路径上任意两点的最大差值。

递归到空节点时，mx 是从根到叶子的路径上的最大值，mn 是从根到叶子的路径上的最小值，所以 mx−mn 就是从根到叶子的路径上任意两点的最大差值。

所以无需每个节点都去更新答案，而是在递归到空节点时才去更新答案。
```c++
class Solution {
    int ans = 0;

    void dfs(TreeNode *node, int mn, int mx) {
        if (node == nullptr) {
            ans = max(ans, mx - mn);
            return;
        }
        mn = min(mn, node->val);
        mx = max(mx, node->val);
        dfs(node->left, mn, mx);
        dfs(node->right, mn, mx);
    }

public:
    int maxAncestorDiff(TreeNode *root) {
        dfs(root, root->val, root->val);
        return ans;
    }
};
```

方法二

方法一的思路是维护 B 的祖先节点中的最小值和最大值，我们还可以站在祖先 A 的视角，维护 A 子孙节点中的最小值 mn 和最大值 mx。

换句话说，最小值和最大值不再作为入参，而是作为返回值，意思是以 A 为根的子树中的最小值 mn 和最大值 mx。

递归到节点 A 时，先递归左右子树，拿到左右子树的最小值和最大值。那么：

mn 等于当前节点值，左子树最小值，右子树最小值，这三者的最小值。
mx 等于当前节点值，左子树最大值，右子树最大值，这三者的最大值。
然后计算

```c++
class Solution {
    int ans = 0;

    pair<int, int> dfs(TreeNode *node) {
        if (node == nullptr) {
            return {INT_MAX, INT_MIN}; // 保证空节点不影响 mn 和 mx
        }
        auto [l_mn, l_mx] = dfs(node->left);
        auto [r_mn, r_mx] = dfs(node->right);
        int mn = min(node->val, min(l_mn, r_mn));
        int mx = max(node->val, max(l_mx, r_mx));
        ans = max(ans, max(node->val - mn, mx - node->val));
        return {mn, mx};
    }

public:
    int maxAncestorDiff(TreeNode *root) {
        dfs(root);
        return ans;
    }
};
```

# [1080. 根到叶路径上的不足节点](https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/)
我的思路是：
要解决的子问题
	判断自己是不是叶子节点，如果是，判断有没有小于 limit 。如果不是叶子节点，就要看左右子树返回的来值，他他们是不是要删除（返回true要删除）
边界条件
	 左子树是空和右子树为空（因为子问题没有解决子右子树为空的判断，所以边界条件是这个），子树为空不用递归判断，直接返回true（要删除）
==主要问题就是忽略了右儿子本来就是空的条件
```c++
bool sS(TreeNode* root, int limit, int sum) {  
    sum += root->val;  
    if (root->left == nullptr && root->right == nullptr) {  
        if (sum < limit) return true;  
        return false;  
    }  
    bool a,b;  
    if (root->left!=nullptr) a = sS(root->left, limit, sum);  
    else a = true;  
    if (root->right!=nullptr) b = sS(root->right, limit, sum);  
    else b = true;  
  
    if (a) {  
        root->left = nullptr;  
    }  
    if (b) {  
        root->right = nullptr;  
    }  
  
    return a & b;  
}  
  
TreeNode* sufficientSubset(TreeNode* root, int limit) {  
    if (root == nullptr) return nullptr;  
    if (sS(root, limit, 0)) root = nullptr;  
    return root;  
}
```

0x3f
***一、思考***
对于一个叶子节点，要想删除它，需要满足什么条件？

对于一个非叶节点，如果它有一个儿子没被删除，那么它能被删除吗？如果它的儿子都被删除，意味着什么？

***二、解惑***
对于一个叶子节点 leaf，由于根到 leaf 的路径仅有一条，所以如果这条路径的元素和小于 limit，就删除 leaf。

对于一个非叶节点 node，==如果 node 有一个儿子没被删除，那么 node 就不能被删除。==这可以用反证法证明：假设可以把 node 删除，那么经过 node 的所有路径和都小于 limit，也就意味着经过 node 的儿子的路径和也小于 limit，说明 node 的儿子需要被删除，矛盾，所以 node 不能被删除。

==如果 node 的儿子都被删除，说明经过 node 的所有儿子的路径和都小于 limit，这等价于经过 node 的所有路径和都小于 limit，所以 node 需要被删除。==

因此，要删除非叶节点 node，当且仅当 node 的所有儿子都被删除。

三、算法
一个直接的想法是，添加一个递归参数 sumPath，表示从根到当前节点的路径和。

但为了能直接调用 sufficientSubset，还可以从 limit 中减去当前节点值。

如果当前节点是叶子，且此时 limit>0，说明从根到这个叶子的路径和小于 limit，那么删除这个叶子。
如果当前节点不是叶子，那么往下递归，更新它的左儿子为对左儿子调用 sufficientSubset 的结果，更新它的右儿子为对右儿子调用 sufficientSubset 的结果。

==如果左右儿子都为空，那么就删除当前节点，返回空；否则不删，返回当前节点。==

```c++
class Solution {
public:
    TreeNode *sufficientSubset(TreeNode *root, int limit) {
        limit -= root->val;
        if (root->left == root->right) // root 是叶子
            // 如果 limit > 0 说明从根到叶子的路径和小于 limit，删除叶子，否则不删除
            return limit > 0 ? nullptr : root;
        if (root->left) root->left = sufficientSubset(root->left, limit);
        if (root->right) root->right = sufficientSubset(root->right, limit);
        // 如果有儿子没被删除，就不删 root，否则删 root
        return root->left || root->right ? root : nullptr;
    }
};
```




# [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)
二叉搜索树需要==left 需要比所有节点值都要小()，right 需要比所有节点值都要大== == ==根节点 比左子树最大要大，比右子树最小要小==
[[搜索二叉树]] [[验证二叉搜索树]] [[判断二叉树是不是搜索二叉树]] 
任何一个节点为头的数, 左边的值都比头要小, 右边的数都比这个头要大

递归的时候确定范围

## 方法一 前序
先访问节点值，在访问左节点，右节点所有节点值都必须要在一个区间里面
往左递归，开区间的右边界更新为节点值，往右递归，开区间的左边界更新为

注意
虽然题目是 int 类型，但开始递归的时候，==left 需要比所有节点值都要小，right 需要比所有节点值都要大==，如果节点值刚好是 int 的最小值/最大值，就没有这样的 left 和 right 了，所以需要用 long 类型。
```c++
class Solution {
public:
    bool isValidBST(TreeNode* root, long long left = LLONG_MIN, long long right = LLONG_MAX) {
        if (root == nullptr) {
            return true;
        }
        long long x = root->val;
        return left < x && x < right &&
               isValidBST(root->left, left, x) &&
               isValidBST(root->right, x, right);
    }
}; 
```

## 方法二 中序
左子树->节点值->右子树
遍历出来的结果是递增的->判断当前节点值小于上一个节点值
用一个全局变量储存 pre（上一个值）
```c++
long long pre = LLONG_MIN;  
bool iV2(TreeNode* root) {  
    if (root == nullptr) return true;  
    bool f1 = iV2(root->left);  
    if (pre >= root->val) return false;  
    pre = root->val;  
    bool f2 = iV2(root->right);  
    return f1 && f2;  
}  
bool isValidBST(TreeNode* root) {  
    return iV2(root);  
}
```

0x3f
更快速，一false直接返回false，后面的东西递归都暂停了
```c++
class Solution {
    long long pre = LLONG_MIN;
public:
    bool isValidBST(TreeNode* root) {
        if (root == nullptr) {
            return true;
        }
        if (!isValidBST(root->left) || root->val <= pre) {
            return false;
        }
        pre = root->val;
        return isValidBST(root->right);
    }
};
```
## 方法三 后序
左子树->右子树->节点值

把节点的取值范围往上传，判断节点值要大于左子树的最大值，右子树的最小值。
左边不能只返回值大值，右边不能只返回最小值，因为左边的最大值可能来自左边的右子树，同理右边的也不行

一发现不是二叉搜索时，就返回-无穷到正无穷
其实这个pair的意义是记录子树遇到的最小和最大值
```c++
pair<long long , long long> iV(TreeNode* root) {  
    if (root == nullptr) return make_pair(LLONG_MAX, LLONG_MIN);  
    pair<long long, long long> r1 = iV(root->left);  
    pair<long long, long long> r2 =iV(root->right);  
    if (root->val > r1.second && root->val < r2.first) return make_pair(r1.first<root->val?r1.first:root->val, r2.second>root->val?r2.second:root->val);  
    return make_pair(LLONG_MIN, LLONG_MAX);  
}  
  
bool isValidBST(TreeNode* root) {  
     pair<long long, long long> res = iV(root);  
    if (res.first == LLONG_MIN && res.second== LLONG_MAX) return false;  
    return true;  
}
```

0x3f的
```c++
class Solution {
    pair<long long, long long> dfs(TreeNode* node) {
        if (node == nullptr) {
            return {LLONG_MAX, LLONG_MIN};
        }
        auto[l_min, l_max] = dfs(node->left);
        auto[r_min, r_max] = dfs(node->right);
        long long x = node->val;
        // 也可以在递归完左子树之后立刻判断，如果发现不是二叉搜索树，就不用递归右子树了
        if (x <= l_max || x >= r_min) {
            return {LLONG_MIN, LLONG_MAX};
        }
        return {min(l_min, x), max(r_max, x)};
    }

public:
    bool isValidBST(TreeNode* root) {
        return dfs(root).second != LLONG_MAX;
    }
};
```

##  双指针法

规避二叉搜索树的问题最小值要取longlong 的问题
# [二叉树的迭代遍历](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html#%E6%80%9D%E8%B7%AF)

感觉也是常考的考点，可以关注一下
[[入门笔记#迭代遍历]]
[[非递归方式实现二叉树的三序遍历]] 

## 前序
[LeetCode 144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)
压栈的时候要先压右节点，再压左节点（先左后右）
弹出的时候把右左孩子压入栈中
```c++
vector<int> preorderTraversal(TreeNode* root) {  
    vector<int> res;  
    if (root == nullptr) return res;  
    stack<TreeNode*> s;  
    s.push(root);  
    while (!s.empty()) {  
        root = s.top();  
        s.pop();  
        res.push_back(root->val);  
        if (root->right) s.push(root->right);  
        if (root->left) s.push(root->left);  
    }  
    return res;  
}
```
## 后序
[LeetCode 145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)
卡尔用的是前序翻转 中左右->中右左->(翻转结果)左右中
```c++
vector<int> postorderTraversal(TreeNode* root) {  
    vector<int> res;  
    if (root == nullptr) return res;  
    stack<TreeNode*> s;  
    s.push(root);  
    while (!s.empty()) {  
        root = s.top();  
        s.pop();  
        res.push_back(root->val);  
        if (root->left) s.push(root->left);  
        if (root->right) s.push(root->right);  
    }  
    reverse(res.begin(), res.end());  
    return res;  
}
```
## 中序
[LeetCode 94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)
左中右
先一路向左，一直入栈直到叶子节点，然后弹出，压入右节点，就实现了左中右了

用一个指针记录遍历顺序，用栈记录处理顺序
```c++
vector<int> inorderTraversal(TreeNode* root) {  
    vector<int> res;  
    if (root == nullptr) return res;  
    stack<TreeNode*> s;  
    TreeNode* cur = root;  
    while (!s.empty() || cur) {  
        while (cur) {  
            s.push(cur);  
            cur = cur->left;  
        }  
        cur = s.top();  
        s.pop();  
        res.push_back(cur->val);  
        cur = cur->right;  
    }  
    return res;  
}
```

# [589. N 叉树的前序遍历](https://leetcode.cn/problems/n-ary-tree-preorder-traversal/)
```c++
void pO(Node* root,vector<int>& res) {  
    if (root == nullptr) return;  
    res.push_back(root->val);  
    for (int i = 0; i < root->children.size(); i++) {  
        pO(root->children[i], res);  
    }  
}  
vector<int> preorder(Node* root) {  
    vector<int> res;  
    pO(root, res);  
    return res;  
}
```

# [590. N 叉树的后序遍历](https://leetcode.cn/problems/n-ary-tree-postorder-traversal/)

```c++
void pS(Node* root,vector<int>& res) {  
    if (root == nullptr) return;  
    for (int i = 0; i < root->children.size(); i++) {  
        pO(root->children[i], res);  
    }  
    res.push_back(root->val);  
}  
vector<int> postorder(Node* root) {  
    vector<int> res;  
    pS(root, res);  
    return res;  
}
```
# [700. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)
比root小看左，比root大看右边
```c++
TreeNode* searchBST(TreeNode* root, int val) {  
    if (root == nullptr) return nullptr;  
    if (root->val == val) return root;  
    if (val < root->val) return searchBST(root->left, val);  
    if (val > root->val) return searchBST(root->right, val);  
}
```
# [530. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

中序遍历，升序，看pre和当前结果
根据条件 node 一定大于 0
```c++
int pre = -1;  
int min1 = INT_MAX;  
int getMinimumDifference(TreeNode* root) {  
    if (root == nullptr) return 0;  
    getMinimumDifference(root->left);  
    if (pre!=-1) {  
        min1 = min(abs(root->val - pre), min1);  
    }  
    pre = root->val;  
    getMinimumDifference(root->right);  
    return min1;  
}
```

## 双指针法
一个指针指向前面，一个指针指向cur
`if pre!= nullptr` 判断是不是第一个
看代码随想录
# [501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

假定 BST 满足如下定义：

- 结点左子树中所含节点的值 **小于等于** 当前节点的值
- 结点右子树中所含节点的值 **大于等于** 当前节点的值
- 左子树和右子树都是二叉搜索树

遍历+哈希似乎不行，不懂，但和二叉搜索树没关系

二叉搜索树一定要中序遍历->满足有序

还是全部遍历->二叉搜索时只是删除了哈希这个数据结构的作用

看卡尔哥的吧，我不知道我什么写错了，找不到逻辑上的问题

```c++
class Solution {
private:
    int maxCount = 0; // 最大频率
    int count = 0; // 统计频率
    TreeNode* pre = NULL;
    vector<int> result;
    void searchBST(TreeNode* cur) {
        if (cur == NULL) return ;

        searchBST(cur->left);       // 左
                                    // 中
        if (pre == NULL) { // 第一个节点
            count = 1;
        } else if (pre->val == cur->val) { // 与前一个节点数值相同
            count++;
        } else { // 与前一个节点数值不同
            count = 1;
        }
        pre = cur; // 更新上一个节点

        if (count == maxCount) { // 如果和最大值相同，放进result中
            result.push_back(cur->val);
        }

        if (count > maxCount) { // 如果计数大于最大值频率
            maxCount = count;   // 更新最大频率
            result.clear();     // 很关键的一步，不要忘记清空result，之前result里的元素都失效了
            result.push_back(cur->val);
        }

        searchBST(cur->right);      // 右
        return ;
    }

public:
    vector<int> findMode(TreeNode* root) {
        count = 0;
        maxCount = 0;
        pre = NULL; // 记录前一个节点
        result.clear();

        searchBST(root);
        return result;
    }
};
```
# [701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)
到了空就创建node，不空就比大小往左往右走，记得要更新左右子树，没有什么难度
```c++
TreeNode* insertIntoBST(TreeNode* root, int val) {  
    if (root == nullptr) {  
        return new TreeNode(val);  
    }  
    if (val < root->val) {  
        root->left = insertIntoBST(root->left, val);  
    }  
    if (val > root->val) {  
        root->right = insertIntoBST(root->right, val);  
    }  
    return root;  
}
```

# [450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)

分五种情况讨论

1. 没找到要删除的节点
2. 左空右空（叶子节点） 直接删
3. 左不为空，右空       直接指
4. 左空，右不空       直接指
5. 左不空，右不空
	 把左子树，放到右子树的最左边节点，父节点直接指向右节点

注意释放内存的逻辑，我没有，看卡尔哥的
```c++
TreeNode* deleteNode(TreeNode* root, int key) {  
    if (root == nullptr) return nullptr;  
    if (root->val == key) {  
        if (root->left == nullptr && root->right == nullptr) {return nullptr;}  
        else if (root->left != nullptr && root->right == nullptr) {return root->left;}  
        else if (root->left == nullptr && root->right != nullptr) {return root->right;}  
        else {  
            TreeNode* cur = root->right;  
            while (cur->left != nullptr) {  
                cur = cur->left;  
            }  
            cur->left =root->left;  
            return root->right;  
        }  
    }  
    else {  
        root->left = deleteNode(root->left, key);  
        root->right = deleteNode(root->right, key);  
    }  
    return root;  
}
```

卡尔哥
```c++
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) return root; // 第一种情况：没找到删除的节点，遍历到空节点直接返回了
        if (root->val == key) {
            // 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
            if (root->left == nullptr && root->right == nullptr) {
                ///! 内存释放
                delete root;
                return nullptr;
            }
            // 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点
            else if (root->left == nullptr) {
                auto retNode = root->right;
                ///! 内存释放
                delete root;
                return retNode;
            }
            // 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
            else if (root->right == nullptr) {
                auto retNode = root->left;
                ///! 内存释放
                delete root;
                return retNode;
            }
            // 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置
            // 并返回删除节点右孩子为新的根节点。
            else {
                TreeNode* cur = root->right; // 找右子树最左面的节点
                while(cur->left != nullptr) {
                    cur = cur->left;
                }
                cur->left = root->left; // 把要删除的节点（root）左子树放在cur的左孩子的位置
                TreeNode* tmp = root;   // 把root节点保存一下，下面来删除
                root = root->right;     // 返回旧root的右孩子作为新root
                delete tmp;             // 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）
                return root;
            }
        }
        if (root->val > key) root->left = deleteNode(root->left, key);
        if (root->val < key) root->right = deleteNode(root->right, key);
        return root;
    }
};
```
# [669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/)
[[修剪搜索二叉树]]
我的理解就是，终止条件是nullptr，中左右，中间的判断条件就是越界了，整个左子树or右子树删除，再看另外一边的子树有没有要删除的，返回结果

和删除二叉搜索树的一边为空很像
```c++
TreeNode* trimBST(TreeNode* root, int low, int high) {  
    if (root == nullptr) return nullptr;  
    if (root->val<low) {  
        return trimBST(root->right, low, high);  
    }  
    if (root->val>high) {  
        return trimBST(root->left, low, high);  
    }  
    root->left = trimBST(root->left, low, high);  
    root->right = trimBST(root->right, low, high);  
    return root;  
}
```

# [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

因为要平衡，所以要从中间拆分成两块，并且因为是升序数组，所以中间的节点一定是二叉搜索树的root
```c++
TreeNode* gATB(vector<int>& nums,int l, int r) {  
    if (l >=r) return nullptr;  
    int mid = l+(r-l) / 2;  
    TreeNode* root = new TreeNode(nums[mid]);  
    root->left =gATB(nums, l, mid);  
    root->right = gATB(nums, mid+1, r);  
    return root;  
}  
TreeNode* sortedArrayToBST(vector<int>& nums) {  
    return gATB(nums, 0, nums.size());  
}
```

# [538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

同leetcode 1038
原本想用vector模拟右中左遍历，获取前缀和的，但是觉得浪费空间，于是用了一个变量last模拟前缀和数组的最新值，但是这样就会出现什么时候要更新最新值的问题，所以才用了INT_MIN作为null指针的标记，其实c++传引用也可以解决这个问题，但防止不是c++还是传值吧
```c++
int cB(TreeNode* root, int last) {  
    if (root == nullptr) return INT_MIN;  
    int right  = cB(root->right,last);  
    if (right != INT_MIN) last = right;  
    root->val = root->val + last;  
    last = root->val;  
    int left = cB(root->left, last);  
    if (left != INT_MIN) last = left;  
    return last;  
}  
TreeNode* convertBST(TreeNode* root) {  
    cB(root,0);  
    return root;  
}
```

卡尔哥
想复杂了，还是要把他看成搜索二叉树看成一个数组来做
```c++
class Solution {
private:
    int pre = 0; // 记录前一个节点的数值
    void traversal(TreeNode* cur) { // 右中左遍历
        if (cur == NULL) return;
        traversal(cur->right);
        cur->val += pre;
        pre = cur->val;
        traversal(cur->left);
    }
public:
    TreeNode* convertBST(TreeNode* root) {
        pre = 0;
        traversal(root);
        return root;
    }
};

```
# [938. 二叉搜索树的范围和](https://leetcode.cn/problems/range-sum-of-bst/)
```c++
int rangeSumBST(TreeNode* root, int low, int high) {  
    if (root == nullptr) return 0;  
    int sum = 0;  
    if (root->val >= low && root->val <= high) {  
        sum = root->val;  
        sum+=rangeSumBST(root->left, low, high);  
        sum+=rangeSumBST(root->right, low, high);  
    }  
    if (root->val < low) sum+=rangeSumBST(root->right, low, high);  
    if (root->val > high) sum+=rangeSumBST(root->left, low, high);  
    return sum;  
}
```


0x3f
根据这些性质，设根节点的值为 x，分类讨论：

- 如果 x>high，那么 x 不在 [low,high] 范围内，并且根据二叉搜索树的性质，右子树的所有节点值都大于 x，从而大于 high，所以也不在 [low,high] 范围内，我们只需计算左子树的在 [low,high] 范围内的节点值之和。
- 如果 x<low，那么 x 不在 [low,high] 范围内，并且根据二叉搜索树的性质，左子树的所有节点值都小于 x，从而小于 low，所以也不在 [low,high] 范围内，我们只需计算右子树的在 [low,high] 范围内的节点值之和。
- 否则，low≤x≤high，那么 x 在 [low,high] 范围内，且左右子树都可能有节点在 [low,high] 范围内，我们累加 x、左子树的在 [low,high] 范围内的节点值之和、右子树的在 [low,high] 范围内的节点值之和，这三部分的和作为答案。

由于要计算的问题都形如「某棵子树在 [low,high] 范围内的节点值之和」，所以可以用递归解决。
```c++
class Solution {
public:
    int rangeSumBST(TreeNode *root, int low, int high) {
        if (root == nullptr) {
            return 0;
        }
        int x = root->val;
        int sum = low <= x && x <= high ? x : 0;
        if (x > low) { // 左子树可能有节点值在范围内
            sum += rangeSumBST(root->left, low, high);
        }
        if (x < high) { // 右子树可能有节点值在范围内
            sum += rangeSumBST(root->right, low, high);
        }
        return sum;
    }
};
```
# [2476. 二叉搜索树最近节点查询](https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/)
这题虽然给的是二叉搜索树，但如果你真的在树上搜索，那就进坑了，因为题目没说是平衡的，如果给的树是一条链，queries里有大量的极端值导致遍历整条链才知道答案是啥，那复杂度就爆炸了。所以还是得按任意二叉树的做法，先把所有节点值放进一个数组，然后二分查找

我的解法超出了时间限制，遍历了两次二叉树

设 j 是大于等于 q=queriesi​ 的第一个数的下标，如果不存在则 j=n。

对于 maxi​：
- 如果 j<n，那么 maxi​=a[j]。
- 否则 maxi​=−1。

对于 mini​：
- 如果 j<n 且 a[j]=q，那么 mini=a[j]。
- 否则如果 j>0，那么 mini​=a[j−1]。
- 否则 mini​=−1。

```c++
class Solution {  
    vector<int> a;  
  
    void dfs(TreeNode *node) {  
        if (node == nullptr) {  
            return;  
        }  
        dfs(node->left);  
        a.push_back(node->val);  
        dfs(node->right);  
    };  
  
public:  
    vector<vector<int>> closestNodes(TreeNode *root, vector<int> &queries) {  
        dfs(root);  
        int n = a.size();  
        vector<vector<int>> ans;  
        for (int q : queries) {  
            // 使用 ranges::lower_bound 查找第一个大于等于 q 的位置  
            // 在已排序数组 a 中，找到第一个大于或等于 q 的元素位置。  
            // 返回的结果是一个迭代器，- a.begin() 将迭代器转为索引。  
            int j = ranges::lower_bound(a, q) - a.begin();  
            // 如果 j < n（索引有效），则 mx = a[j]。  
            // 如果 j == n（q 大于数组中所有元素），则没有大于或等于 q 的值，将 mx = -1。  
            int mx = j < n ? a[j] : -1;  
            if (j == n || a[j] != q) { // a[j]>q, a[j-1]<q  
                j--;  
            }  
            int mn = j >= 0 ? a[j] : -1;  
            ans.push_back({mn, mx});  
        }  
        return ans;  
    }  
};
```

# [230. 二叉搜索树中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)
考察中序搜索
因为node都大于0，所以我是用-1标记没找到，后面返回一个正数就好了，记得k要加引用，因为是全局变量

```c++
int kS(TreeNode* root, int& k) {  
    if (root == nullptr) return -1;  
    int left = kS(root->left, k);  
    --k;  
    if (k==0)  return root->val;  
    int right = kS(root->right, k);  
    return max(left,right);  
}  
int kthSmallest(TreeNode* root, int k) {  
    return kS( root, k);  
}
```

0x3f

递归逻辑：

1. 递归边界：如果当前节点是空节点，返回 −1，表示没有找到。注意题目保证节点值非负。
2. 执行中序遍历，先递归左子树。
3. 判断左子树的返回值 leftRes 是否为 −1。如果不是 −1，说明我们在左子树中找到了答案，返回 leftRes。如果是 −1，说明尚未找到答案，继续下一步。
4. 把 k 减少 1。如果 k=0，那么答案就是当前节点值，返回当前节点值。
5. 现在，答案要么在当前节点的右子树中，要么在除了当前子树的其余节点中。递归右子树，如果答案在右子树中，那么直接返回答案；如果答案不在右子树中，那么右子树也会返回 −1，由于当前子树搜索完毕，所以当前子树没有找到答案，返回 −1。综上所述，可以直接返回右子树的返回值。


# [1373. 二叉搜索子树的最大键值和](https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/)

题目不讲人话，我来翻译一下。 给你一个树，你要找到这个树的子树，要求该子树是二叉搜索树（可能有多个）。若能找到，返回其中“键值和”最大的二叉搜索树的“键值和”。 例如root = [2,1,3] 那么可以找到三棵符合要求的树[2,1,3]和[1]和[3]，其中“键值和”最大是[2,1,3]的6，所以返回6


每棵子树返回：
- 这棵子树的最小节点值。
- 这棵子树的最大节点值。
- 这棵子树的所有节点值之和。

如果左子树的最大值 ≥ 当前节点值，或者右子树的最小值 ≤ 当前节点值，都不符合二叉搜索树的定义，那么当前这棵子树不是二叉搜索树。此时可以返回 −∞,∞,0（第三个数随意）。这种返回值可以简化代码，对于父节点，同样通过判断子树的最小值/最大值和当前节点值的大小关系，就可以知道子树是否为二叉搜索树了。

如果当前子树是二叉搜索树，那么把左右子树的节点值之和，加上当前节点值，去更新答案的最大值，并作为当前子树的所有节点值之和，返回给父节点。

==我为什么没想到==
1. 过于专注于二叉搜索树中序遍历有序，其实验证二叉搜索时可以直接根据左子树的最大值和右子树的最小值，然后比较得到结果
2. 找子树，感觉还是二叉树后序遍历比较直观
```c++
class Solution {
    int ans = 0; // 二叉搜索树可以为空

    tuple<int, int, int> dfs(TreeNode *node) {
        if (node == nullptr)
            return {INT_MAX, INT_MIN, 0};

        auto [l_min, l_max, l_sum] = dfs(node->left); // 递归左子树
        auto [r_min, r_max, r_sum] = dfs(node->right); // 递归右子树
        int x = node->val;
        if (x <= l_max || x >= r_min) // 不是二叉搜索树
            return {INT_MIN, INT_MAX, 0};

        int s = l_sum + r_sum + x; // 这棵子树的所有节点值之和
        ans = max(ans, s);

        return {min(l_min, x), max(r_max, x), s};
    }

public:
    int maxSumBST(TreeNode *root) {
        dfs(root);
        return ans;
    }
};
```

# [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
我的思路，但不知道编码怎么实现，看卡尔哥，还有0x3f吧
![[Pasted image 20250112155623.png]]
卡尔：
凡是构造二叉树的题目，应该使用前序遍历，先构造中
通过后序数组找中，然后再中序数组里面切割左右（中的左边就是左子树，中的右边就是右子树）
1. 后序数组为0，空节点
2. 后序数组的最后一个元素为节点元素
3. 寻找中序数组位置作为切割点
4. 切中序数组
5. 切后序数组
6. 递归处理左区间，右区间

我的写的太丑陋了，思路是对的，模仿一下0x3f
分割的话，其实只需要计算出左子树的大小就好了
这个界限，看的猪脑要烧掉了。。不是很熟悉c++的这种操作
0x3f
```c++
class Solution {  
public:  
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {  
        if (postorder.empty()) { // 空节点  
            return nullptr;  
        }  
        // postorder.back()（根节点）在 inorder 数组中查找位置，从而计算出左子树的节点数量（即左子树的大小）。  
        int left_size = ranges::find(inorder, postorder.back()) - inorder.begin(); // 左子树的大小  
        // 分割出左子树，左闭右开  
        vector<int> in1(inorder.begin(), inorder.begin() + left_size);  
        // 分割出右子树，左闭右开  
        vector<int> in2(inorder.begin() + left_size + 1, inorder.end());  
        vector<int> post1(postorder.begin(), postorder.begin() + left_size);  
        vector<int> post2(postorder.begin() + left_size, postorder.end() - 1);  
        TreeNode* left = buildTree(in1, post1);  
        TreeNode* right = buildTree(in2, post2);  
        return new TreeNode(postorder.back(), left, right);  
    }  
};
```

卡尔哥的，比较详细
```c++
class Solution {
private:
    TreeNode* traversal (vector<int>& inorder, vector<int>& postorder) {
        if (postorder.size() == 0) return NULL;

        // 后序遍历数组最后一个元素，就是当前的中间节点
        int rootValue = postorder[postorder.size() - 1];
        TreeNode* root = new TreeNode(rootValue);

        // 叶子节点
        if (postorder.size() == 1) return root;

        // 找到中序遍历的切割点
        int delimiterIndex;
        for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {
            if (inorder[delimiterIndex] == rootValue) break;
        }

        // 切割中序数组
        // 左闭右开区间：[0, delimiterIndex)
        vector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);
        // [delimiterIndex + 1, end)
        vector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end() );

        // postorder 舍弃末尾元素
        postorder.resize(postorder.size() - 1);

        // 切割后序数组
        // 依然左闭右开，注意这里使用了左中序数组大小作为切割点
        // [0, leftInorder.size)
        vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());
        // [leftInorder.size(), end)
        vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());

        root->left = traversal(leftInorder, leftPostorder);
        root->right = traversal(rightInorder, rightPostorder);

        return root;
    }
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if (inorder.size() == 0 || postorder.size() == 0) return NULL;
        return traversal(inorder, postorder);
    }
};

```

0x3f速度优化版

1. 用一个哈希表（或者数组）预处理 inorder 每个元素的下标，这样就可以 O(1) 查到 postorder[n−1] 在 inorder 的位置，从而 O(1) 知道左子树的大小。
2. 把递归参数改成子数组下标区间（左闭右开区间）的左右端点，从而避免复制

```c++
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        int n = inorder.size();
        unordered_map<int, int> index;
        for (int i = 0; i < n; i++) {
            index[inorder[i]] = i;
        }
// 左闭右开
        auto dfs = [&](auto&& dfs, int in_l, int in_r, int post_l, int post_r) -> TreeNode* {
            if (post_l == post_r) { // 空节点
                return nullptr;
            }
            int left_size = index[postorder[post_r - 1]] - in_l; // 左子树的大小
            TreeNode* left = dfs(dfs, in_l, in_l + left_size, post_l, post_l + left_size);
            TreeNode* right = dfs(dfs, in_l + left_size + 1, in_r, post_l + left_size, post_r - 1);
            return new TreeNode(postorder[post_r - 1], left, right);
        };
        return dfs(dfs, 0, n, 0, n); // 左闭右开区间
    }
};
```
# [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

[[从前序与中序遍历序列构造二叉树]]
[[从前序与中序遍历序列构造二叉树]]

[[用先序数组和中序数组重建一棵树]] 
[[已知中序遍历数组和先序遍历数组，返回后序遍历数组]]
[[二叉树经典问题#先序和中序遍历构造二叉树]]

和后序和一样，找到第一个节点就可以把二叉树切开了
注意边界条件的拆分

```c++
TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {  
    if (preorder.empty()) return nullptr;  
    int left_size = ranges::find(inorder,*preorder.begin()) - inorder.begin();  
    vector<int> prel (preorder.begin()+1, preorder.begin()+left_size+1); 
    vector<int> prer (preorder.begin()+left_size+1,preorder.end());  
    vector<int> inl(inorder.begin(), inorder.begin()+left_size);  
    vector<int> inr(inorder.begin()+left_size+1,inorder.end());  
    return new TreeNode(*preorder.begin(),buildTree(prel,inl),buildTree(prer,inr));  
}
```

0x3f优化版
```c++
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();
        unordered_map<int, int> index;
        for (int i = 0; i < n; i++) {
            index[inorder[i]] = i;
        }

        auto dfs = [&](auto&& dfs, int pre_l, int pre_r, int in_l, int in_r) -> TreeNode* {
            if (pre_l == pre_r) { // 空节点
                return nullptr;
            }
            int left_size = index[preorder[pre_l]] - in_l; // 左子树的大小
            TreeNode* left = dfs(dfs, pre_l + 1, pre_l + 1 + left_size, in_l, in_l + left_size);
            TreeNode* right = dfs(dfs, pre_l + 1 + left_size, pre_r, in_l + 1 + left_size, in_r);
            return new TreeNode(preorder[pre_l], left, right);
        };
        return dfs(dfs, 0, n, 0, n); // 左闭右开区间
    }
};
```
# [889. 根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)
不能确定为一个一颗二叉树
我卡在了怎么确定左子树的位置和右子树的位置，其实这里可以直接看preorder[1]，他是左子树的根节点，找到根节点，那么根据后序遍历的位置就可以找到左右子树的位置

连续完全匹配就是左子树
题目说，如果存在多个答案，我们可以返回其中任何一个。那么不妨**规定**：无论什么情况，在前序遍历中，preorder[1] 都是**左子树**的根节点值。
1. 规定preorder[1]是左子树的根
2. 所以在postorder里面找到preorder找到preorder[1]的位置，他的左边就是左子树，右边就是右子树
3. 重新在preorder中定义左右子树
4. 同理递归

要注意假定第二个位置 是左子树根节点的前提是 有第二个，所以要多一个判断语句为一个值

```c++
class Solution {
public:
    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {
        int n = preorder.size();
        vector<int> index(n + 1);
        for (int i = 0; i < n; i++) {
            index[postorder[i]] = i;
        }

        // 注意 post_r 可以省略
        auto dfs = [&](auto&& dfs, int pre_l, int pre_r, int post_l) -> TreeNode* {
            if (pre_l == pre_r) { // 空节点
                return nullptr;
            }
            if (pre_l + 1 == pre_r) { // 叶子节点
                return new TreeNode(preorder[pre_l]);
            }
            int left_size = index[preorder[pre_l + 1]] - post_l + 1; // 左子树的大小
            TreeNode* left = dfs(dfs, pre_l + 1, pre_l + 1 + left_size, post_l);
            TreeNode* right = dfs(dfs, pre_l + 1 + left_size, pre_r, post_l + left_size);
            return new TreeNode(preorder[pre_l], left, right);
        };
        return dfs(dfs, 0, n, 0); // 左闭右开区间
    }
};
```

# [654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)

和前面根据遍历的结果构造二叉树差不多
```c++
TreeNode* constructMaximumBinaryTree(vector<int>& nums) {  
    if (nums.empty()) return nullptr;  
    // 使用 std::max_element 找到最大元素的迭代器  
    auto max_it = max_element(nums.begin(), nums.end());  
    TreeNode* root = new TreeNode(*max_it);  
    // 计算索引  
    // int index = std::distance(nums.begin(), max_it);  
    // 切割vector，左闭右开  
    vector<int> left(nums.begin(), max_it);  
    vector<int> right(max_it+1, nums.end());  
    root->left = constructMaximumBinaryTree(left);  
    root->right = constructMaximumBinaryTree(right);  
    return root;  
}
```

卡尔
差不多，主要问题就是不要复制数组，构造数组，要操作下标

# [1110. 删点成林](https://leetcode.cn/problems/delete-nodes-and-return-forest/)
后序遍历

```c++
TreeNode* dN(TreeNode* root, vector<int>& to_delete,vector<TreeNode*>& res) {  
    if (root == nullptr) return nullptr;  
    root->left = dN(root->left, to_delete, res);  
    root->right = dN(root->right, to_delete, res);  
    for (auto key : to_delete) {  
        if (root->val == key) {  
            if (root->left != nullptr) {res.push_back(root->left);}  
            if (root->right != nullptr) {res.push_back(root->right);}  
            delete root;  
            return nullptr;  
        }  
    }  
    return root;  
}  
vector<TreeNode*> delNodes(TreeNode* root, vector<int>& to_delete) {  
    vector<TreeNode*> res;  
    root = dN(root,to_delete,res);  
    if (root)  res.push_back(root);  
    return res;  
}
```

0x3f

把 toDelete 全部丢到一个哈希表 s 中，这样可以 O(1) 判断节点值是否在 toDelete 中。

如果当前节点被删除，但是左儿子（右儿子）没被删除，意味着左儿子（右儿子）是一棵树的根节点，加入答案。

1. 更新左儿子（右儿子）为递归左儿子（右儿子）的返回值。
2. 如果当前节点被删除，那么就检查左儿子（右儿子）是否被删除，如果没被删除，就加入答案。
3. 如果当前节点被删除，返回空节点，否则返回当前节点。
4. 最后，如果根节点没被删除，把根节点加入答案。
```c++
class Solution {
    vector<TreeNode*> ans;
    unordered_set<int> s;

    TreeNode* dfs(TreeNode *node) {
        if (node == nullptr) return nullptr;
        node->left = dfs(node->left);
        node->right = dfs(node->right);
        if (!s.count(node->val)) return node;
        if (node->left) ans.push_back(node->left);
        if (node->right) ans.push_back(node->right);
        return nullptr;
    }

public:
    vector<TreeNode*> delNodes(TreeNode *root, vector<int> &to_delete) {
        for (int x : to_delete) s.insert(x);
        if (dfs(root)) ans.push_back(root);
        return ans;
    }
};
```


# [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)
节点本身也可以是自己的祖先
[[最近公共祖先-时间O(N)空间O(1)解法]]
[[二叉树的最近公共祖先]]
[[二叉树的最近公共祖先问题]]
[[二叉树上两个节点的最低公共祖先]]


利用回溯，自下而上->后序遍历回溯
遇到p or q就会返回


分类讨论
当前节点指的是当前遍历的节点
![[Pasted image 20250110232841.png]]

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == q || root == p || root == NULL) return root;
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if (left != NULL && right != NULL) return root;
        if (left == NULL) return right;
        return left;
    }
};
```


# [235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

[[搜索二叉树的最近公共祖先]]

利用二叉搜索树的性质求公共祖先
如果pq都小于当前节点，pq都在左子树，递归左子树返回结果
如果pq都大于当前节点，pq都在右子树，递归右子树返回结果
如果pq分别在左右子树中，最近公共祖先就是当前节点
当前节点是p or q 最近就是当前节点
当前节点不可能为空，不需要判断（一定存在）

```c++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {  
    if (root == nullptr || root == p || root == q) return root;  
    int min1 = min(p->val, q->val);  
    int max1 = max(p->val, q->val);  
    if (root->val > min1 && root->val < max1) {return root;}  
    if (root->val > max1) return lowestCommonAncestor(root->left, p, q);  
    if (root->val < min1) return lowestCommonAncestor(root->right, p, q);  
    return root;  
}
```

0x3f
```c++
class Solution {
public:
    TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {
        int x = root->val;
        if (p->val < x && q->val < x) { // p 和 q 都在左子树
            return lowestCommonAncestor(root->left, p, q);
        }
        if (p->val > x && q->val > x) { // p 和 q 都在右子树
            return lowestCommonAncestor(root->right, p, q);
        }
        return root; // 其它
    }
};
```
# [1123. 最深叶节点的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/)
返回包含原始树中所有最深节点的最小子树”
## 方法一：递归递归，有递有归
如果左子树的最大深度比右子树的大，那么最深叶结点就只在左子树中，所以最近公共祖先也只在左子树中。

如果左右子树的最大深度一样呢？当前节点一定是最近公共祖先吗？

不一定。比如节点 1 的左右子树最深叶节点 0,8 的深度都是 2，但该深度并不是全局最大深度，所以节点 1 并不能是答案。

1. 递归这棵二叉树，同时维护全局最大深度 maxDepth。
2. 在「递」的时候往下传 depth，用来表示当前节点的深度。
3. 在「归」的时候往上传当前子树最深叶节点的深度。
4. 设左子树最深叶节点的深度为 leftMaxDepth，右子树最深叶节点的深度为 rightMaxDepth。如果 leftMaxDepth=rightMaxDepth=maxDepth，那么更新答案为当前节点。==注意这并不代表我们找到了答案，如果后面发现了更深的叶节点，那么答案还会更新。==（我的思路卡在了这一步）
• function<int(TreeNode*, int)>:
• 表示一个可调用对象（函数类型），它接受两个参数：
1. 一个指向 TreeNode 类型的指针（TreeNode*），即当前递归操作的树节点。
2. 一个整数（int），表示当前节点所在的深度。
返回包含原始树中所有最深节点的最小子树”
```c++
class Solution {
public:
    TreeNode *lcaDeepestLeaves(TreeNode *root) {
        TreeNode *ans = nullptr;
        int max_depth = -1; // 全局最大深度
        function<int(TreeNode*, int)> dfs = [&](TreeNode *node, int depth) {
            if (node == nullptr) {
                max_depth = max(max_depth, depth); // 维护全局最大深度
                return depth;
            }
            int left_max_depth = dfs(node->left, depth + 1); // 获取左子树最深叶节点的深度
            int right_max_depth = dfs(node->right, depth + 1); // 获取右子树最深叶节点的深度
            if (left_max_depth == right_max_depth && left_max_depth == max_depth)
                ans = node;
            return max(left_max_depth, right_max_depth); // 当前子树最深叶节点的深度
        };
        dfs(root, 0);
        return ans;
    }
};
```

## 方法二：自底向上
也可以不用全局变量，而是把每棵子树都看成是一个「子问题」，即对于每棵子树，我们需要知道：

- 这棵子树最深叶结点的深度。这里是指叶子在这棵子树内的深度，而不是在整棵二叉树的视角下的深度。相当于这棵子树的高度。
- 这棵子树的最深叶结点的最近公共祖先 lca。
分类讨论：

- 设子树的根节点为 node，node 的左子树的高度为 leftHeight，node 的右子树的高度为 rightHeight。
- 如果 leftHeight>rightHeight，那么子树的高度为 leftHeight+1，lca 是左子树的 lca。
- 如果 leftHeight<rightHeight，那么子树的高度为 rightHeight+1，lca 是右子树的 lca。
- 如果 leftHeight=rightHeight，那么子树的高度为 leftHeight+1，lca 就是 node。反证法：如果 lca 在左子树中，那么 lca 不是右子树的最深叶结点的祖先，这不对；如果 lca 在右子树中，那么 lca 不是左子树的最深叶结点的祖先，这也不对；如果 lca 在 node 的上面，那就不符合「最近」的要求。所以 lca 只能是 node。


```c++
class Solution {
    pair<int, TreeNode*> dfs(TreeNode *node) {
        if (node == nullptr)
            return {0, nullptr};
        auto [left_height, left_lca] = dfs(node->left);
        auto [right_height, right_lca] = dfs(node->right);
        if (left_height > right_height) // 左子树更高
            return {left_height + 1, left_lca};
        if (left_height < right_height) // 右子树更高
            return {right_height + 1, right_lca};
        return {left_height + 1, node}; // 一样高
    }

public:
    TreeNode *lcaDeepestLeaves(TreeNode *root) {
        return dfs(root).second;
    }
};
```


# [2096. 从二叉树一个节点到另一个节点每一步的方向](https://leetcode.cn/problems/step-by-step-directions-from-a-binary-tree-node-to-another/)

##  解法一：DFS + BFS
我们可以从起点出发，通过 BFS 找到终点，同时记录每个点的来源节点和方向，在找到终点后，顺着来源节点往回走，同时记录答案。

由于要往父节点方向走，我们需要先通过一次 DFS 记录每个节点的父节点，这样就可以在 BFS 中往父节点和左右节点三个方向前进了。

DFS 的过程中也可以顺带找到起点。

==没读懂过，懒得读懂了，感觉太复杂了==
```c++
string getDirections(TreeNode* root, int startValue, int destValue) {
    queue<TreeNode*> q;
    unordered_map<TreeNode*, TreeNode*> parents;

    auto dfs = [&](TreeNode* node, TreeNode* parent, auto& dfs_ref) -> void {
        if (!node) return;
        parents[node] = parent;
        if (node->val == startValue) {
            q.push(node); // Only one start point
        }
        dfs_ref(node->left, node, dfs_ref);
        dfs_ref(node->right, node, dfs_ref);
    };

    dfs(root, nullptr, dfs);

    string ans;
    unordered_map<TreeNode*, bool> vis;
    vis[nullptr] = true;
    vis[q.front()] = true;

    struct Pair {
        TreeNode* from;
        char dir;
    };

    unordered_map<TreeNode*, Pair> from;

    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();

        if (node->val == destValue) {
            while (from[node].from) {
                ans.push_back(from[node].dir);
                node = from[node].from;
            }
            reverse(ans.begin(), ans.end());
            return ans;
        }

        if (node->left && !vis[node->left]) {
            vis[node->left] = true;
            from[node->left] = {node, 'L'};
            q.push(node->left);
        }

        if (node->right && !vis[node->right]) {
            vis[node->right] = true;
            from[node->right] = {node, 'R'};
            q.push(node->right);
        }

        if (parents[node] && !vis[parents[node]]) {
            vis[parents[node]] = true;
            from[parents[node]] = {node, 'U'};
            q.push(parents[node]);
        }
    }

    return ans;
}
```


## 解法二：最近公共祖先

二叉树中一个节点到另一个节点的最短路径一定可以分为两个部分（可能为空）：从起点节点向上到两个节点的**最近公共祖先**，再从最近公共祖先向下到达终点节点。

按照 [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/) 给出的方法

我们可以从起点出发，找到到起点和终点的路径，然后去掉前缀相同的部分。剩下即为从起点和终点的最近公共祖先出发，到起点和终点的路径，分别记作 pathToStart 和 pathToDest。

我们要找的最短路径即为：起点 => 起点和终点的最近公共祖先 => 终点。

对于起点到最近公共祖先这一段，可以看成长度为 pathToStart 的向父节点走的路径；对于最近公共祖先到终点这一段就是 pathToDest。将这两段路径拼起来即为答案。



```c++
string getDirections(TreeNode* root, int startValue, int destValue) {
    vector<char> path;
    auto dfs = [&](TreeNode* node, int target, auto& dfs_ref) -> bool {
        if (!node) {
            return false;
        }
        if (node->val == target) {
            return true;
        }
        path.push_back('L');
        if (dfs_ref(node->left, target, dfs_ref)) {
            return true;
        }
        path.back() = 'R';
        if (dfs_ref(node->right, target, dfs_ref)) {
            return true;
        }
        path.pop_back();
        return false;
    };

    dfs(root, startValue, dfs);
    vector<char> pathToStart = path;

    path.clear();
    dfs(root, destValue, dfs);
    vector<char> pathToDest = path;

    while (!pathToStart.empty() && !pathToDest.empty() && pathToStart[0] == pathToDest[0]) {
        pathToStart.erase(pathToStart.begin());
        pathToDest.erase(pathToDest.begin());
    }

    string result(pathToStart.size(), 'U');
    result += string(pathToDest.begin(), pathToDest.end());
    return result;
}
```
# [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
[[二叉树的层序遍历]]  
把自己放到队列，把队列里面的孩子放到下一个队列里
用队列可以避免使用两个数组，浪费空间，只需要记录当前层有几个节点就好了
```c++
vector<vector<int>> levelOrder(TreeNode* root) {  
    vector<vector<int>> res;  
    queue<TreeNode*> q;  
    if (root){q.push(root);}  
    while (!q.empty()) {  
        int size = q.size();  
        res.push_back(vector<int>());  
        for (int i = 0; i < size; i++) {  
            TreeNode* node = q.front();  
            q.pop();  
            res.back().push_back(node->val);  
            if (node->left != nullptr) q.push(node->left);  
            if (node->right != nullptr) q.push(node->right);  
        }  
    }  
    return res;  
}
```
# [103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)
[[二叉树的锯齿形层次遍历]]
翻转偶数层的节点，偶数层翻转，奇数层不变
```c++
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode *root) {
        if (root == nullptr) return {};
        vector<vector<int>> ans;
        queue<TreeNode *> q;
        q.push(root);
        while (!q.empty()) {
            vector<int> vals;
            for (int n = q.size(); n--;) {
                auto node = q.front();
                q.pop();
                vals.push_back(node->val);
                if (node->left)  q.push(node->left);
                if (node->right) q.push(node->right);
            }
            if (ans.size() % 2) ranges::reverse(vals);
            ans.emplace_back(vals);
        }
        return ans;
    }
};
```
# [513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

## 方法一
返回最后一层的第一个答案：层序遍历
```c++
int findBottomLeftValue(TreeNode* root) {  
    queue<TreeNode*> q;  
    q.push(root);  
    int res = 0;  
    while (!q.empty()) {  
        int size = q.size();  
        for (int i = 0; i < size; i++) {  
            TreeNode* node = q.front();  
            q.pop();  
            if (i ==0) res = node->val;  
            if (node->left != nullptr) q.push(node->left);  
            if (node->right != nullptr) q.push(node->right);  
        }  
    }  
    return res;  
}
```
## 方法二

把层序遍历从右到左遍历，最后一个节点就是左下角的值
```c++
class Solution {
public:
    int findBottomLeftValue(TreeNode *root) {
        TreeNode *node;
        queue<TreeNode *> q;
        q.push(root);
        while (!q.empty()) {
            node = q.front(); q.pop();
            if (node->right) q.push(node->right);
            if (node->left)  q.push(node->left);
        }
        return node->val;
    }
};
```
## 方法三
递归
用一个全局变量记录已知的最大深度，记录结果，用一个参数记录现在遍历的深度

==懒得写了==

# [107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)
遍历完后答案反转
```c++
vector<vector<int>> levelOrderBottom(TreeNode* root) {  
    vector<vector<int>> res;  
    queue<TreeNode*> q;  
    if (root){q.push(root);}  
    while (!q.empty()) {  
        int size = q.size();  
        res.push_back(vector<int>());  
        for (int i = 0; i < size; i++) {  
            TreeNode* node = q.front();  
            q.pop();  
            res.back().push_back(node->val);  
            if (node->left != nullptr) q.push(node->left);  
            if (node->right != nullptr) q.push(node->right);  
        }  
    }  
    reverse(res.begin(), res.end());  
    return res;         
}
```

# [637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

```c++
vector<double> averageOfLevels(TreeNode* root) {  
    vector<vector<int>> res;  
    vector<double> ret;  
    queue<TreeNode*> q;  
    if (root){q.push(root);}  
    while (!q.empty()) {  
        int size = q.size();  
        res.push_back(vector<int>());  
        for (int i = 0; i < size; i++) {  
            TreeNode* node = q.front();  
            q.pop();  
            res.back().push_back(node->val);  
            if (node->left != nullptr) q.push(node->left);  
            if (node->right != nullptr) q.push(node->right);  
        }  
    }  
    for (int i = 0; i < res.size(); i++) {  
        double sum = 0;  
        for (int j = 0; j < res[i].size(); j++) {  
            sum += res[i][j];  
        }  
        ret.push_back(sum / res[i].size());  
    }  
    return ret;  
}
```
# [429.N叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)
```c++
vector<vector<int>> levelOrder(Node* root) {  
    vector<vector<int>> res;  
    queue<Node*> q;  
    if (root) q.push(root);  
    while (!q.empty()) {  
        int size = q.size();  
        res.push_back(vector<int>());  
        for (int i = 0; i < size; i++) {  
            Node* node = q.front();  
            q.pop();  
            res.back().push_back(node->val);  
            for (int j = 0; j < node->children.size(); j++) {  
                q.push(node->children[j]);  
            }  
        }  
    }  
    return res;  
}
```

# [515. 在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

```c++
vector<int> largestValues(TreeNode* root) {  
    vector<int> res;  
    queue<TreeNode*> q;  
    if (root) {q.push(root);}  
    while (!q.empty()) {  
        int size = q.size();  
        int max1 = INT_MIN;  
        for (int i = 0; i < size; i++) {  
            TreeNode* node = q.front();  
            q.pop();  
            max1 = max(max1, node->val);  
            if (node->left != nullptr) q.push(node->left);  
            if (node->right != nullptr) q.push(node->right);  
        }  
        res.push_back(max1);  
    }  
    return res;  
}
```

# [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)
[[填充每个节点的下一个右侧节点指针]]
```c++
Node* connect(Node* root) {  
  
    queue<Node*> q;  
    if (root) q.push(root);  
    while (!q.empty()) {  
        int size = q.size();  
        Node* pre = nullptr;  
        Node* cur = nullptr;  
        for (int i = 0; i < size; i++) {  
            cur = q.front();  
            q.pop();  
            if (pre) pre->next = cur;  
            pre = cur;  
            if (cur->left != nullptr) q.push(cur->left);  
            if (cur->right != nullptr) q.push(cur->right);  
        }  
    }  
    return root;  
}
```

# [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)
对于层序遍历，两道题一样
```c++
Node* connect(Node* root) {  
  
    queue<Node*> q;  
    if (root) q.push(root);  
    while (!q.empty()) {  
        int size = q.size();  
        Node* pre = nullptr;  
        Node* cur = nullptr;  
        for (int i = 0; i < size; i++) {  
            cur = q.front();  
            q.pop();  
            if (pre) pre->next = cur;  
            pre = cur;  
            if (cur->left != nullptr) q.push(cur->left);  
            if (cur->right != nullptr) q.push(cur->right);  
        }  
    }  
    return root;  
}
```
# [2415. 反转二叉树的奇数层](https://leetcode.cn/problems/reverse-odd-levels-of-binary-tree/)

用多了一个数据结构，用来翻转数据，注意不能直接反转指针treenode，这样会导致下面的也翻转

因为题目是完全二叉树，所以只要左子树有值，右子树也有
```c++
TreeNode* reverseOddLevels(TreeNode* root) {  
    queue<TreeNode*> q;  
    stack<int> s;  
    if (root) q.push(root);  
    int n = 0;  
    while (!q.empty()) {  
        int size = q.size();  
        for (int i = 0; i < size; i++) {  
            TreeNode* node = q.front();  
            q.pop();  
            if (node->left != nullptr) q.push(node->left);  
            if (node->right != nullptr) q.push(node->right);  
            if (n%2 == 0) {  
                if (node->left != nullptr) {  
                    s.push(node->left->val);  
                    s.push(node->right->val);  
                }  
            }else {  
                int val = s.top();  
                s.pop();  
                node->val = val;  
            }  
        }  
        ++n;  
    }  
    return root;  
}
```

0x3f

```python
class Solution:
    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        q, level = [root], 0
        while q[0].left:
            q = list(chain.from_iterable((node.left, node.right) for node in q))
            if level == 0:
                for i in range(len(q) // 2):
                    x, y = q[i], q[len(q) - 1 - i]
                    x.val, y.val = y.val, x.val
            level ^= 1
        return root
```
# [2641. 二叉树的堂兄弟节点 II](https://leetcode.cn/problems/cousins-in-binary-tree-ii/)
queue要用来标记父节点
用哈希表记住，每一个父节点的孩子的值的和
遍历哈希表，求和，重新赋值
感觉这样很消耗时间复杂度（最吗 ）
```C++
TreeNode* replaceValueInTree(TreeNode* root) {  
    queue<pair<TreeNode*,TreeNode*>> q;  
    if (root) q.push(make_pair(root, root));  
    unordered_map<TreeNode*,int> map;  
    while (!q.empty()) {  
        int size = q.size();  
        vector<pair<TreeNode*,TreeNode*>> nodes;  
        for (int i = 0; i < size; i++) {  
            TreeNode* node = q.front().first;  
            TreeNode* parent = q.front().second;  
            if (map.find(parent) == map.end()) {  
                map.insert(make_pair(parent, node->val));  
            }else {  
                map[parent] += node->val;  
            }  
            nodes.push_back(make_pair(node, parent));  
            q.pop();  
            if (node->left != nullptr) q.push(make_pair(node->left, node));  
            if (node->right != nullptr) q.push(make_pair(node->right, node));  
  
        }  
        for (int i = 0; i < nodes.size(); i++) {  
            int sum = 0;  
            TreeNode* node = nodes[i].first;  
            TreeNode* parent = nodes[i].second;  
            for (auto it = map.begin(); it != map.end(); it++) {  
                if (it->first != parent) sum += it->second;  
            }  
            node->val = sum;  
        }  
        map.clear();  
    }  
    return root;  
}
```

0x3f
对于一个节点 x 来说，它的所有**堂兄弟节点**值的和，等于 x 这一层的所有节点值之和减去 x 及其兄弟节点的值之和。

用 BFS 遍历二叉树，对于每一层：
- 首先，遍历当前层的每个节点，通过节点的左右儿子，计算下一层的节点值之和 nextLevelSum。
- 然后，再次遍历当前层的每个节点 x，计算 x 的左右儿子的节点值之和 childrenSum，更新 x 的左右儿子的节点值为 nextLevelSum−childrenSum。

==我的骚操作太多，数据结构用太多，遍历了n^2次了, 0x3f两次==

```c++
class Solution {
public:
    TreeNode *replaceValueInTree(TreeNode *root) {
        root->val = 0;
        vector<TreeNode*> q = {root};
        while (!q.empty()) {
            vector<TreeNode*> nxt;
            // 计算下一层的节点值之和
            int next_level_sum = 0;
            for (auto node : q) {
                if (node->left) {
                    nxt.push_back(node->left);
                    next_level_sum += node->left->val;
                }
                if (node->right) {
                    nxt.push_back(node->right);
                    next_level_sum += node->right->val;
                }
            }

            // 再次遍历，更新下一层的节点值
            for (auto node : q) {
                int children_sum = (node->left ? node->left->val : 0) +
                                   (node->right ? node->right->val : 0);
                if (node->left) node->left->val = next_level_sum - children_sum;
                if (node->right) node->right->val = next_level_sum - children_sum;
            }
            q = move(nxt);
        }
        return root;
    }
};
```
# 左链接
[[二叉树经典问题]]
[[07 二叉树的基本算法]]
[[08 二叉树的递归套路]]
[[二叉树概念汇总]]
[[二叉树的递归套路]]
