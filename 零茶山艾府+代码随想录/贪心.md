#0x3f #贪心 
# [455. 分发饼干](https://leetcode.cn/problems/assign-cookies/)
大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。

**这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩**。

贪心：让最大的饼干满足胃口最大的小孩
```c++
int findContentChildren(vector<int>& g, vector<int>& s) {  
    if (s.size() == 0) return 0;  
    if (g.size() == 0) return 0;  
    sort(g.begin(), g.end());  
    sort(s.begin(), s.end());  
    int n = 0;  
    int j = s.size()-1;  
    for (int i = g.size() - 1; i >= 0; i--) {  
        if (g[i] <= s[j]) {  
            --j;  
            ++n;  
            if (j<0) break;  
        }  
    }  
    return n;  
}
```

# [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

在计算是否有峰值的时候，大家知道遍历的下标 i ，计算 prediff（nums[i] - nums[i-1]） 和 curdiff（nums[i+1] - nums[i]），如果`prediff < 0 && curdiff > 0` 或者 `prediff > 0 && curdiff < 0` 此时就有波动就需要统计。

这是我们思考本题的一个大体思路，但本题要考虑三种情况：

1. 情况一：上下坡中有平坡
	如果我们采用，删左面三个 2 的规则，那么 当 `prediff = 0 && curdiff < 0` 也要记录一个峰值，因为他是把之前相同的元素都删掉留下的峰值。
	所以我们记录峰值的条件应该是： `(preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)`，为什么这里允许 prediff == 0 ，就是为了 上面我说的这种情况
2. 情况二：数组首尾两端
	之前我们在 讨论 情况一：相同数字连续 的时候， prediff = 0 ，curdiff < 0 或者 >0 也记为波谷。
	那么为了规则统一，针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即 preDiff = 0
	针对以上情形，result 初始为 1（默认最右面有一个峰值），此时 curDiff > 0 && preDiff <= 0，那么 result++（计算了左面的峰值），最后得到的 result 就是 2（峰值个数为 2 即摆动序列长度为 2）
3. 情况三：单调坡中有平坡
	因为 单调中的平坡 不能算峰值（即摆动）。
	我们只需要在 这个坡度 摆动变化的时候，更新 prediff 就行，这样 prediff 在 单调区间有平坡的时候 就不会发生变化，造成我们的误判。
```c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();
        int curDiff = 0; // 当前一对差值
        int preDiff = 0; // 前一对差值
        int result = 1;  // 记录峰值个数，序列默认序列最右边有一个峰值
        for (int i = 0; i < nums.size() - 1; i++) {
            curDiff = nums[i + 1] - nums[i];
            // 出现峰值
            if ((preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)) {
                result++;
                preDiff = curDiff; // 注意这里，只在摆动变化的时候更新prediff
            }
        }
        return result;
    }
};
```

# [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)
[[最大子数组和]]
局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。

result 要初始化为最小负数。这样才可以找到最大的值，因为这个数组可以连续为负数
 
```c++
int maxSubArray(vector<int>& nums) {  
    int cur=0;  
    long long res = LLONG_MIN;  
    if (nums.size() == 1) return nums[0];  
    for (int i = 0; i < nums.size(); i++) {  
        cur += nums[i];  
        res = res > cur ? res : cur;  
        if (cur < 0 ) {  
            cur = 0;  
            continue;  
        }  
    }  
    return res;  
}
```
# [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

[[买卖股票的最佳时机 II]]

**此时就是把利润分解为每天为单位的维度，而不是从 0 天到第 3 天整体去考虑！**

那么根据 prices 可以得到每天的利润序列：(prices[i] - prices[i - 1]).....(prices[1] - prices[0])。


从图中可以发现，其实我们需要收集每天的正利润就可以，**收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间**。

那么只收集正利润就是贪心所贪的地方！

**局部最优：收集每天的正利润，全局最优：求得最大利润**。

局部最优可以推出全局最优，找不出反例，试一试贪心！

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0;
        for (int i = 1; i < prices.size(); i++) {
            result += max(prices[i] - prices[i - 1], 0);
        }
        return result;
    }
};
```

# [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)
[[跳跃游戏]]
其实跳几步无所谓，关键在于可跳的覆盖范围！

不一定非要明确一次究竟跳几步，每次取最大的跳跃步数，这个就是可以跳跃的覆盖范围。

这个范围内，别管是怎么跳的，反正一定可以跳过来。

**那么这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！**

每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。

**贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点**。
```c++
  
bool canJump(vector<int>& nums) {  
    int range = 0;  
    int i =0;  
    while (i <= range) {  
        range = max(range,i+nums[i]);  
        if (range >= nums.size()-1) return true;  
        ++i;  
    }  
    return false;  
}
```
# [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)
[[跳跃游戏 II]]
贪心的思路，局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最少步数。

思路虽然是这样，但在写代码的时候还不能真的能跳多远就跳多远，那样就不知道下一步最远能跳到哪里了。

**所以真正解题的时候，要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最少步数！**

**这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖**。
```c++
int jump(vector<int>& nums) {  
    if (nums.size() == 0) return 0;  
    if (nums.size() == 1) return 1;  
    int range = 0;  
    int i =0;  
    int res = 0;  
    for (; i < nums.size();) {  
        range = i+nums[i];  
        ++res;  
        if (range>=nums.size()-1) return res;  
        int temp = 0;  
        for (int j = i+1; j < range; j++) {  
             if (j+nums[j] > temp) {  
                 temp = j+nums[j];  
                 i = j;  
             }  
        }  
    }  
    return res;  
}
```

代码随想录

```c++
// 版本一
class Solution {
public:
    int jump(vector<int>& nums) {
        if (nums.size() == 1) return 0;
        int curDistance = 0;    // 当前覆盖最远距离下标
        int ans = 0;            // 记录走的最大步数
        int nextDistance = 0;   // 下一步覆盖最远距离下标
        for (int i = 0; i < nums.size(); i++) {
            nextDistance = max(nums[i] + i, nextDistance);  // 更新下一步覆盖最远距离下标
            if (i == curDistance) {                         // 遇到当前覆盖最远距离下标
                ans++;                                  // 需要走下一步
                curDistance = nextDistance;             // 更新当前覆盖最远距离下标（相当于加油了）
                if (nextDistance >= nums.size() - 1) break;  // 当前覆盖最远距到达集合终点，不用做ans++操作了，直接结束
            }
        }
        return ans;
    }
};
```


# [1005. K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

**我这里其实是为了给大家展现出来 经常被大家忽略的贪心思路，这么一道简单题，就用了两次贪心！**

那么本题的解题步骤为：

- 第一步：将数组按照绝对值大小从大到小排序，**注意要按照绝对值的大小**
- 第二步：从前向后遍历，遇到负数将其变为正数，同时K--
- 第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完
- 第四步：求和

```c++
class Solution {  
//这个比较函数确保在排序后，数组 A 中绝对值最大的元素会排在最前面。这样可以优先对绝对值大的负数进行操作（如果有负数的话）。
    static bool cmp(int a, int b) {  
        return abs(a) > abs(b);  
    }  
public:  
    int largestSumAfterKNegations(vector<int>& A, int K) {  
        sort(A.begin(), A.end(), cmp);       // 第一步  
        for (int i = 0; i < A.size(); i++) { // 第二步  
            if (A[i] < 0 && K > 0) {  
                A[i] *= -1;  
                K--;  
            }  
        }  
        if (K % 2 == 1) A[A.size() - 1] *= -1; // 第三步  
        int result = 0;  
        for (int a : A) result += a;        // 第四步  
        return result;  
    }  
};
```
# [134. 加油站](https://leetcode.cn/problems/gas-station/)
i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。

```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int curSum = 0;
        int totalSum = 0;
        int start = 0;
        for (int i = 0; i < gas.size(); i++) {
            curSum += gas[i] - cost[i];
            totalSum += gas[i] - cost[i];
            if (curSum < 0) {   // 当前累加rest[i]和 curSum一旦小于0
                start = i + 1;  // 起始位置更新为i+1
                curSum = 0;     // curSum从0开始
            }
        }
        if (totalSum < 0) return -1; // 说明怎么走都不可能跑一圈了
        return start;
    }
};
```
# [135. 分发糖果](https://leetcode.cn/problems/candy/)
从左到右，从右到左
```c++
class Solution {  
public:  
    int candy(vector<int>& ratings) {  
        vector<int> candyVec(ratings.size(), 1);  
        // 从前向后  
        for (int i = 1; i < ratings.size(); i++) {  
            if (ratings[i] > ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1;  
        }  
        // 从后向前  
        for (int i = ratings.size() - 2; i >= 0; i--) {  
            if (ratings[i] > ratings[i + 1] ) {  
                candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1);  
            }  
        }  
        // 统计结果  
        int result = 0;  
        for (int i = 0; i < candyVec.size(); i++) result += candyVec[i];  
        return result;  
    }  
};
```
# [860. 柠檬水找零](https://leetcode.cn/problems/lemonade-change/)
优先找大额的
```c++
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int five = 0, ten = 0, twenty = 0;
        for (int bill : bills) {
            // 情况一
            if (bill == 5) five++;
            // 情况二
            if (bill == 10) {
                if (five <= 0) return false;
                ten++;
                five--;
            }
            // 情况三
            if (bill == 20) {
                // 优先消耗10美元，因为5美元的找零用处更大，能多留着就多留着
                if (five > 0 && ten > 0) {
                    five--;
                    ten--;
                    twenty++; // 其实这行代码可以删了，因为记录20已经没有意义了，不会用20来找零
                } else if (five >= 3) {
                    five -= 3;
                    twenty++; // 同理，这行代码也可以删了
                } else return false;
            }
        }
        return true;
    }
};
```
# [406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)

# [52. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)

# [435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)

# [763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)

# [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

# [738. 单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/)

# [968. 监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/)


# 左链接
- [[13 贪心算法（上）]]
- [[14 贪心算法（下）]]
- [[09 贪心算法]]
- [[_贪心算法Memo]]