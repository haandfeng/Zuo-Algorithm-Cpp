# 子数组最小值的累加和-难点解释


---
[[子数组最小值的累加和]] 使用[[算法笔记/zuoAlgorithm/003. 编程基础技巧及工具/单调栈]]  
以10位置的7做最小值的最大范围:  
左边找离我最近的比我小的: 5, 在位置5   
右边找离我最近的比我小的: 4, 在位置15   
所以在中间6~14范围上最小值就是这个7
![[Pasted image 20210129160825.png]]

推广:  
假设来到i位置, 上面的值是X,
左边找离我最近的比我小的位置: Y  
右边找离我最近的比我小的位置: Z

子数组的开头可选位置: i - (k+1) +1 = i-k 个开始位置   
子数组的结尾可选位置: (j-1) - i + 1  = j-i   个结束位置   
子数组以i位置的X为最小值产生多少累加和:   
 (i - k) \* (j - i) \* X
![[Pasted image 20210129161803.png]]


**数组中有相等值时候的处理**:   

所有相等的数3为最小值能扩到一个最大的范围 `[1~13]`
对每一个相等的3枚举所有可能的**开始位置**跟**结束位置**, 注意区间不要重复计算

两种策略:   
对于每一个3,  开始选局部, 结束选区间最大可能整体:   
开始位置从上一个3下一个位置到自己结束, 结尾位置为自己开始到区间结束  
对于每一个3,  开始选最大可能整体, 结束选局部:   
对于每一个3, 开始位置从区间开始到自己, 结尾位置为自己开始到下一个3之前   
![[Pasted image 20210129164318.png]]   
就是为了去重


#### 为什么计算以每一个i作为最小值的所有子数组 可以把题目中要求的所有子数组全部罗列出来?

这只是一种标准, 如果我求出:   
必须以0位置的数做最小值子数组有多少个     
必须以1位置的数做最小值子数组有多少个  
必须以2位置的数做最小值子数组有多少个   
如果我把每一个位置它的子数组数量都求出来, 而且不重的话, 都累加起来就是答案

之所以理解不了是你还按照子数组的方式去想问题, 假设这个例子:
```text
[5   4    1    2]
 0   1    2    3

```

如果你就把目光限制死, 先定义子数组再求最小值去累加, 这个题就没有办法优化了
所以我们想法是:  
必须以0位置的5做最小值子数组有多少个: 就它一个  
必须以1位置的4做最小值子数组有多少个: 0~1, 1~1, 两个  

两种标准的确是截然不同的, 但是是殊途同归的

你为啥这么设计?  
你可以认为是一个经验, 但是你没有发现我们总是在这么干, 单调栈总是再求以单个位置数做什么标准下, 它产生多少答案, 以下个位置的数做统一标准的情况下, 它产生多少答案...
总这么干, 它就是一个很良好的思维传统


假设我们所有的子数组都求出来, 每一个子数组必然有一个最小值是这个子数组中确定的一个数, 这个问题 跟 以每一个i作为最小值所确定的所有子数组 这两个集合是可以一一对应的
它们的规模是相等的, 所以题目中的问题可以简化中上述逻辑来求解


另外:    
[[为何要对 1000000007 取模？]]


![[Pasted image 20210129173327.png]]

啥区别:    
前一种右边相等就停, 每次开头的位置只会多不会少, 前面都要算   
和左边遇到相等停是一样的   
左边遇到相等停 你右边就是全量, 左边的开头就要被阉割     
如果右边遇到相等停 你左边开头就是全量, 右边的结尾就要被阉割  

