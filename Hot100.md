# [1. 两数之和](https://leetcode.cn/problems/two-sum/)
[[哈希表#[1. 两数之和](https //leetcode.cn/problems/two-sum/)]]
用hash表
```c++
vector<int> twoSum(vector<int>& nums, int target) {  
    unordered_map<int, int> hashtable;  
    for (int i = 0; i < nums.size(); ++i) {  
        auto it = hashtable.find(target - nums[i]);  
        if (it != hashtable.end()) {  
            return {it->second, i};  
        }  
        hashtable[nums[i]] = i;  
    }  
    return {};  
}
```

# [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

注意到，如果把 aab,aba,baa 按照字母从小到大排序，我们可以得到同一个字符串 aab。
而对于每种字母出现次数不同于 aab 的字符串，例如 abb 和 bab，排序后为 abb，不等于 aab。
==所以当且仅当两个字符串排序后一样，这两个字符串才能分到同一组。== 相同点
根据这一点，我们可以用哈希表来分组，把排序后的字符串当作 key，原字符串组成的列表（即答案）当作 value。

```c++
vector<vector<string>> groupAnagrams(vector<string>& strs) {  
    unordered_map<string, vector<string>> m;  
    for (string& s : strs) {  
        string sorted_s = s;  
        ranges::sort(sorted_s);  
        m[sorted_s].push_back(s); // sorted_s 相同的字符串分到同一组  
    }  
  
    vector<vector<string>> ans;  
    ans.reserve(m.size()); // 预分配空间  
    for (auto& [_, value] : m) {  
        ans.push_back(value);  
    }  
    return ans;
}
```


# [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

我们考虑枚举数组中的每个数 x，考虑以其为起点，不断尝试匹配 x+1,x+2,⋯ 是否存在，假设最长匹配到了 x+y，那么以 x 为起点的最长连续序列即为 x,x+1,x+2,⋯,x+y，其长度为 y+1，我们不断枚举并更新答案即可。

对于匹配的过程，暴力的方法是 O(n) 遍历数组去看是否存在这个数，但其实更高效的方法是用一个哈希表存储数组中的数，这样查看一个数是否存在即能优化至 O(1) 的时间复杂度。

仅仅是这样我们的算法时间复杂度最坏情况下还是会达到 O(n 
2
 )（即外层需要枚举 O(n) 个数，内层需要暴力匹配 O(n) 次），无法满足题目的要求。但仔细分析这个过程，我们会发现其中执行了很多不必要的枚举，如果已知有一个 x,x+1,x+2,⋯,x+y 的连续序列，而我们却重新从 x+1，x+2 或者是 x+y 处开始尝试匹配，那么得到的结果肯定不会优于枚举 x 为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可。

那么怎么判断是否跳过呢？由于我们要枚举的数 x 一定是在数组中不存在前驱数 x−1 的，不然按照上面的分析我们会从 x−1 开始尝试匹配，因此我们每次在哈希表中检查是否存在 x−1 即能判断是否需要跳过了。


```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> num_set;
        for (const int& num : nums) {
            num_set.insert(num);
        }

        int longestStreak = 0;

        for (const int& num : num_set) {
            if (!num_set.count(num - 1)) {
                int currentNum = num;
                int currentStreak = 1;

                while (num_set.count(currentNum + 1)) {
                    currentNum += 1;
                    currentStreak += 1;
                }

                longestStreak = max(longestStreak, currentStreak);
            }
        }

        return longestStreak;           
    }
};
```


# [283. 移动零](https://leetcode.cn/problems/move-zeroes/)
把 0 视作空位。我们要把所有非零元素都移到数组左边的空位上，并保证非零元素的顺序不变。

例如 nums=[0,0,1,2]，把 1 放到最左边的空位上，数组变成 [1​, 0, 0, 2]。注意 1 移动过去后，在原来 1 的位置又产生了一个新的空位。也就是说，我们交换了 nums[0]=0 和nums[2]=1 这两个数。

为了保证非零元素的顺序不变，我们需要维护最左边的空位的位置（下标）。

![[Pasted image 20250305163349.png]]


```c++
void moveZeroes(vector<int>& nums) {  
    int i0 = 0;  
    for (int& x : nums) { // 注意 x 是引用  
        if (x) {  
            swap(x, nums[i0]);  
            i0++;  
        }  
    }  
}
```


# [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)
[[双向双指针#[11. 盛最多水的容器](https //leetcode.cn/problems/container-with-most-water/)]]

如果要找到要容量更大的，说明移动的时候要找到更长的线，木桶效应，靠短板决定，所以要更新短板
```c++
int maxArea(vector<int>& height) {  
    int ans = 0,left=0,right =height.size()-1;  
    while (left < right) {  
        ans = max((right-left)*min(height[left],height[right]), ans);  
        if (height[left] >= height[right]) {--right;}  
        else {++left;}  
    }  
    return ans;  
}
```


# [15. 三数之和](https://leetcode.cn/problems/3sum/)
[[双向双指针#[15. 三数之和](https //leetcode.cn/problems/3sum/)]]
两数之和的变种，先确定一个数，然后写两数之和的代码
注意去重
没有做优化，优化看连接
```c++
vector<vector<int>> threeSum(vector<int>& nums) {  
    vector<vector<int>> ans;  
    sort(nums.begin(), nums.end());  
    for (int i = 0; i < nums.size(); i++) {  
        if (i > 0 && nums[i] == nums[i-1]) {continue;}  
        int target = -nums[i];  
        int left = i + 1, right = nums.size() - 1;  
        while (left < right) {  
            if (nums[left] + nums[right] == target) {  
                ans.push_back({nums[i],nums[left],nums[right]});  
                ++left;  
                while (left < right && nums[left] == nums[left-1]) {++left;}  
            }else if (nums[left] + nums[right] > target) {  
                --right;  
            }else {  
                ++left;  
            }  
        }  
    }  
    return ans;  
}
```


# [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)
[[双向双指针#[42. 接雨水](https //leetcode.cn/problems/trapping-rain-water/)]]
一个单位能接到水的容量是往左看和往右看的木板的最小值-自己的高度
前缀最大值和后缀最大值

```java
public void findMax(int [] pre,int [] post,int [] height){  
    for(int i = 0; i < height.length; i++) {  
        if(i==0){  
            pre[i]=height[i];  
        }  
        else {  
            pre[i] = Math.max(height[i], pre[i-1]);  
        }  
    }  
    for(int i = height.length-1; i >= 0; i--) {  
        if(i == height.length-1){  
            post[i]=height[i];  
        }else {  
            post[i] = Math.max(height[i], post[i+1]);  
        }  
    }  
}  
public int trap(int[] height) {  
    int [] pre = new int[height.length];  
    int [] post = new int[height.length];  
    findMax(pre,post,height);  
    int ans = 0;  
    for(int i = height.length-1; i >= 0; i--) {  
        int temp = Math.min(post[i],pre[i])-height[i];  
        if(temp >0){  
            ans+=temp;  
        }  
    }  
    return ans;  
}
```
# [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

[[滑动窗口(同向双指针)#[3. 无重复字符的最长子串](https //leetcode.cn/problems/longest-substring-without-repeating-characters/)]]
```java
public int lengthOfLongestSubstring(String s) {  
    HashSet<Character> set = new HashSet<>();  
    int ans = 0, left = 0;  
    for(int i = 0; i<s.length();++i){  
        while(set.contains(s.charAt(i))){  
            set.remove(s.charAt(left++));  
        }  
        set.add(s.charAt(i));  
        ans = Math.max(i - left +1,ans);  
    }  
    return ans;  
}
```
# [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)
注意这个窗口的位置
```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> ans = new ArrayList<>();
        int[] cnt = new int[26]; // 统计 p 的每种字母的出现次数
        for (char c : p.toCharArray()) {
            cnt[c - 'a']++;
        }
        int left = 0;
        for (int right = 0; right < s.length(); right++) {
            int c = s.charAt(right) - 'a';
            cnt[c]--; // 右端点字母进入窗口
            while (cnt[c] < 0) { // 字母 c 太多了
                cnt[s.charAt(left) - 'a']++; // 左端点字母离开窗口
                left++;
            }
            if (right - left + 1 == p.length()) { // s' 和 p 的每种字母的出现次数都相同
                ans.add(left); // s' 左端点下标加入答案
            }
        }
        return ans;
    }
}
```

# ==[560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)==
## 前置：[303. 区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/)
为方便描述，把 nums 记作 a。
对于数组 a，定义它的前缀和
	s [0] = 0 
	s [1] = a[0]
	s [2] = a[0]+a[1]
	.......
![[Pasted image 20250307155115.png]]


问：为什么要定义 s[0]=0，这样做有什么好处？

答：如果 left=0，要计算的子数组是一个前缀（从 a[0] 到 a[right]），我们要用 s[right+1] 减去 s[0]。如果不定义 s[0]=0，就必须特判 left=0 的情况了（读者可以试试）。通过定义 s[0]=0，任意子数组（包括前缀）都可以表示为两个前缀和的差。此外，如果 a 是空数组，定义 s[0]=0 的写法是可以兼容这种情况的

```c++
class NumArray {
    vector<int> s;
public:
    NumArray(vector<int> &nums) {
        s.resize(nums.size() + 1);
        for (int i = 0; i < nums.size(); i++) {
            s[i + 1] = s[i] + nums[i];
        }
    }

    int sumRange(int left, int right) {
        return s[right + 1] - s[left];
    }
};
```

## 和为K的子数组

我的理解：s\[j]表示到j为止的前缀和，s\[i] 表示到i为止的前缀和，子数组就是s\[j]-s\[i]，遍历到s\[j]，想找到s\[j]-s\[i]= k有多少个，只要看自己左边的s\[i]有多少个就好了，要找到s\[i]有多少个=》通过s\[i] = k- s\[j]来找到

两次循环
```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> s(n + 1);
        for (int i = 0; i < n; i++) {
            s[i + 1] = s[i] + nums[i];
        }

        int ans = 0;
        unordered_map<int, int> cnt;
        for (int sj : s) {
            // 注意不要直接 += cnt[sj-k]，如果 sj-k 不存在，会插入 sj-k
            ans += cnt.contains(sj - k) ? cnt[sj - k] : 0;
            cnt[sj]++;
        }
        return ans;
    }
};
```

一次循环，其实只要知道到目前为止的前缀和就好了，不需要知道之前的前缀和和之后的前缀和是多少，所以循环一次就好了
```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int ans = 0, s = 0;
        unordered_map<int, int> cnt{{0, 1}}; // s[0]=0 单独统计
        for (int x : nums) {
            s += x;
            // 注意不要直接 += cnt[s-k]，如果 s-k 不存在，会插入 s-k
            ans += cnt.contains(s - k) ? cnt[s - k] : 0;
            cnt[s]++;
        }
        return ans;
    }
};
```
# [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)


# [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

# ==[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)==

[[贪心#[53. 最大子数组和](https //leetcode.cn/problems/maximum-subarray/)]]
我用贪心做的，但其实可以用前缀和or动态规划来做，可以做做
[灵茶山艾府讲解和扩展题](https://leetcode.cn/problems/maximum-subarray/solutions/2533977/qian-zhui-he-zuo-fa-ben-zhi-shi-mai-mai-abu71/?envType=study-plan-v2&envId=top-100-liked)

```c++
int maxSubArray(vector<int>& nums) {  
    int  right = 0,temp = 0;  
    long long ans = LLONG_MIN;  
    while (right < nums.size()) {  
        if (temp >= 0) {  
            temp += nums[right];  
            ans = ans > temp ? ans : temp;  
        }else {  
            temp = 0;  
            temp += nums[right];  
            ans = ans > temp ? ans : temp;  
        }  
        ++right;  
    }  
    return ans;  
}
```


# [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

```java
class Solution {  
    public int[][] merge(int[][] intervals) {  
        Arrays.sort(intervals, (p, q) -> p[0] - q[0]); // 按照左端点从小到大排序  
        List<int[]> ans = new ArrayList<>();  
        for (int[] p : intervals) {  
            int m = ans.size();  
            if (m > 0 && p[0] <= ans.get(m - 1)[1]) { // 可以合并  
                ans.get(m - 1)[1] = Math.max(ans.get(m - 1)[1], p[1]); // 更新右端点最大值  
            } else { // 不相交，无法合并  
                ans.add(p); // 新的合并区间  
            }  
        }  
        return ans.toArray(new int[ans.size()][]);  
    }  
}
```
# [189. 轮转数组](https://leetcode.cn/problems/rotate-array/)
注意要取膜，具体操作可以看0x3f
```java
class Solution {  
    public void reverse(int[] nums,int left, int right){  
        while(left < right){  
            int temp = nums[left];  
            nums[left] = nums[right];  
            nums[right] = temp;  
            ++left;  
            --right;  
        }  
    }  
    public void rotate(int[] nums, int k) {  
        k = k%nums.length;  
        reverse(nums,0,nums.length-1);  
        reverse(nums, 0, k-1);  
        reverse(nums, k, nums.length-1);  
    }  
}
```
# ==[238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)==
answer[i] 等于 nums 中除了 nums[i] 之外其余各元素的乘积。换句话说，如果知道了 i 左边所有数的乘积，以及 i 右边所有数的乘积，就可以算出 answer[i]。

于是：

定义 pre[i] 表示从 nums[0] 到 nums[i−1] 的乘积。
定义 suf[i] 表示从 nums[i+1] 到 nums[n−1] 的乘积。

我们可以先计算出从 nums[0] 到 nums[i−2] 的乘积 pre[i−1]，再乘上 nums[i−1]，就得到了 pre[i]，即
pre[i]=pre[i−1]⋅nums[i−1]
同理有
suf[i]=suf[i+1]⋅nums[i+1]

初始值：pre[0]=suf[n−1]=1。按照上文的定义，pre[0] 和 suf[n−1] 都是空子数组的元素乘积，我们规定这是 1，因为 1 乘以任何数 x 都等于 x，这样可以方便递推计算 pre[1]，suf[n−2] 等。

算出 pre 数组和 suf 数组后，有

answer[i]=pre[i]⋅suf[i]

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> pre(n, 1);
        for (int i = 1; i < n; i++) {
            pre[i] = pre[i - 1] * nums[i - 1];
        }

        vector<int> suf(n, 1);
        for (int i = n - 2; i >= 0; i--) {
            suf[i] = suf[i + 1] * nums[i + 1];
        }

        vector<int> ans(n);
        for (int i = 0; i < n; i++) {
            ans[i] = pre[i] * suf[i];
        }
        return ans;
    }
};
```

优化：不使用额外空间
先计算 suf，然后一边计算 pre，一边把 pre 直接乘到 suf[i] 中。最后返回 suf。

题目说「输出数组不被视为额外空间」，所以该做法的空间复杂度为 O(1)。此外，这种做法比上面少遍历了一次。

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> suf(n);
        suf[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--) {
            suf[i] = suf[i + 1] * nums[i + 1];
        }

        int pre = 1;
        for (int i = 0; i < n; i++) {
            // 此时 pre 为 nums[0] 到 nums[i-1] 的乘积，直接乘到 suf[i] 中
            // 现在pre就是pre[i]
            suf[i] *= pre;
            pre *= nums[i];
        }

        return suf;
    }
};
```

# ==[41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)==

原地哈希
由于题目要求我们「只能使用常数级别的空间」，而要找的数一定在 [1, N + 1] 左闭右闭（这里 N 是数组的长度）这个区间里。因此，我们可以就把原始的数组当做哈希表来使用。事实上，哈希表其实本身也是一个数组；
我们要找的数就在 [1, N + 1] 里，最后 N + 1 这个元素我们不用找。因为在前面的 N 个元素都找不到的情况下，我们才返回 N + 1；
那么，我们可以采取这样的思路：就把 1 这个数放到下标为 0 的位置， 2 这个数放到下标为 1 的位置，按照这种思路整理一遍数组。然后我们再遍历一次数组，第 1 个遇到的它的值不等于下标的那个数，就是我们要找的缺失的第一个正数。
这个思想就相当于我们自己编写哈希函数，这个哈希函数的规则特别简单，那就是数值为 i 的数映射到下标为 i - 1 的位置。

```c++
class Solution {
public:
    int firstMissingPositive(vector<int> &nums) {
        for (int i = 0; i < nums.size(); i++) {
            while (nums[i] != i + 1) {
                if (nums[i] <= 0 || nums[i] > nums.size() || nums[i] == nums[nums[i] - 1])
                    break;
                // 将nums[i] 放置到对应位置上[1,2,3...]
                int idx = nums[i] - 1;
                nums[i] = nums[idx];
                nums[idx] = idx + 1;
            }
        }
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] != (i + 1)) {
                return (i + 1);
            }
        }
        return (nums.size() + 1);
    }
};

```


## 类似题目：[LCR 120. 寻找文件副本](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

也是把数组位置当作哈希，如果交换前，发现要交换的位置上的值已经和位置一样了，说明有重复，返回
```c++
void swap(vector<int>& nums, int i, int j) {  
    int temp = nums[i];  
    nums[i] = nums[j];  
    nums[j] = temp;  
}  
int findRepeatDocument(vector<int>& documents) {  
    for (int i = 0; i < documents.size(); i++) {  
        while (documents[i] != i) {  
            if (documents[documents[i]] == documents[i]) {  
                return documents[i];  
            }  
            swap(documents, i, documents[i]);  
        }  
    }  
    return -1;  
}
```
# [73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

```c++
void setZeroes(vector<vector<int>>& matrix) {  
    int m = matrix.size(), n = matrix[0].size();  
    vector<int> row(m,0), col(n,0);  
    for (int i = 0; i < m; i++) {  
        for (int j = 0; j < n; j++) {  
            if (matrix[i][j] == 0) {  
                row[i] = 1;  
                col[j] = 1;  
            }  
        }  
    }  
    for (int i = 0; i < m; i++) {  
        if (row[i]) { for (int j = 0; j < n; j++) matrix[i][j] = 0;}  
    }  
    for (int j = 0; j < n; j++) {  
        if (col[j]) { for (int i = 0; i < m; i++) matrix[i][j] = 0;}  
    }  
}
```

#  [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)
不要用卡尔的思路
[[双向双指针#[LCR 146. 螺旋遍历二维数组](https //leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)/ [54. 螺旋矩阵](https //leetcode.cn/problems/spiral-matrix/)]]
```c++
vector<int> spiralOrder(vector<vector<int>>& matrix) {  
    int m = matrix.size(), n = matrix[0].size();  
    int up = 0, down = m-1, left = 0, right = n-1;  
    vector<int> ans;  
    while (true) {  
        for (int i = left; i <= right; i++) {  
            ans.push_back(matrix[up][i]);  
        }  
        if (++up > down) {break;}  
        for (int i = up; i <= down; i++) {  
            ans.push_back(matrix[i][right]);  
        }  
        if (--right<left){break;}  
        for (int i = right; i >= left; i--) {  
            ans.push_back(matrix[down][i]);  
        }  
        if (--down<up){break;}  
        for (int i = down; i >= up; i--) {  
            ans.push_back(matrix[i][left]);  
        }  
        if (++left>right){break;}  
    }  
    return ans;  
}
```

# [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

对于矩阵中的第一行而言，在旋转后，它出现在倒数第一列的位置：
并且，第一行的第 x 个元素在旋转后恰好是倒数第一列的第 x 个元素。

对于矩阵中的第二行而言，在旋转后，它出现在倒数第二列的位置：

对于矩阵中的第三行和第四行同理。这样我们可以得到规律：

对于矩阵中第 i 行的第 j 个元素，在旋转后，它出现在倒数第 i 列的第 j 个位置。
由于矩阵中的行列从 0 开始计数，因此对于矩阵中的元素 matrix\[row]\[col]，在旋转后，它的新位置为 matrix \[col]\[n−row−1]。n是matrix的size
$$
\text{matrix}_{new}[\text{col}][n - \text{row} - 1] = \text{matrix}[\text{row}][\text{col}]
$$


我们还可以另辟蹊径，用翻转操作代替旋转操作。
![[Pasted image 20250308203354.png]]


# [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)
二分法，找到右上角的数comp，如果target比comp小则删除comp所在一列（comp所在列一定比target大），同理如果target比comp小则删除comp所在一行。
```java
class Solution {  
    public boolean searchMatrix(int[][] matrix, int target) {  
        int m = matrix.length-1;  
        int n = matrix[0].length-1;  
        //  
        int row = 0;  
        int col = n;  
        while(row <= m && col >= 0){  
            if(matrix[row][col] == target){  
                return true;  
            }else if(matrix[row][col] < target){  
                ++row;  
            }else{  
                --col;  
            }  
        }  
        return false;  
    }  
}
```

# [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

[灵神解法](https://leetcode.cn/problems/intersection-of-two-linked-lists/solutions/2958778/tu-jie-yi-zhang-tu-miao-dong-xiang-jiao-m6tg1/?envType=study-plan-v2&envId=top-100-liked)


# [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)
[[链表#[206. 反转链表](https //leetcode.cn/problems/reverse-linked-list/)]]

```c++
ListNode* reverseList(ListNode* head) {  
    ListNode* prev = nullptr;  
    ListNode* next = nullptr;  
    ListNode* curr = head;  
    while (curr != nullptr) {  
        next = curr->next;  
        curr->next = prev;  
        prev = curr;  
        curr = next;  
    }  
    return prev;  
}
```


# [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)
[[链表#[234. 回文链表](https //leetcode.cn/problems/palindrome-linked-list/)]]

```c++
ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* next = nullptr;
    ListNode* curr = head;
    while (curr != nullptr) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}


bool isPalindrome(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
    }
    ListNode* mid = reverseList(slow);
    slow = head;
    while (mid != nullptr) {
        if (mid->val != slow->val) {return false;}
        slow = slow->next;
        mid = mid->next;
    }
    return true;
}
```


# [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)
[[链表#[141. 环形链表](https //leetcode.cn/problems/linked-list-cycle/)]]

```c++
bool hasCycle(ListNode *head) {  
    ListNode* slow = head;  
    ListNode* fast = head;  
    while (fast != nullptr && fast->next != nullptr) {  
        slow = slow->next;  
        fast = fast->next->next;  
        if (slow == fast) {  
            return true;  
        }  
    }  
    return false;  
}
```


# ==[142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)==
[[链表#[142. 环形链表 II](https //leetcode.cn/problems/linked-list-cycle-ii/)]]

```c++
class Solution {
public:
    ListNode* detectCycle(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
            if (fast == slow) { // 相遇
                while (slow != head) { // 再走 a 步
                    slow = slow->next;
                    head = head->next;
                }
                return slow;
            }
        }
        return nullptr;
    }
};
```
# [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)
用一个dummy node把他们穿在一起

```c++
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {  
    ListNode dummy (0);  
    // ListNode dummy2 (0,list2);  
    if (list1 == nullptr ) {  
        return list2;  
    }  
    if (list2 == nullptr ) {  
        return list1;  
    }  
    ListNode* p0 = &dummy;  
    ListNode* p1 = list1;  
    ListNode* p2 = list2;  
    while (p1 != nullptr && p2 != nullptr) {  
        ListNode* temp =nullptr;  
        if (p1->val <= p2->val) {  
            p0->next = p1;  
            p1 = p1->next;  
            p0 = p0->next;  
        }else {  
            p0->next = p2;  
            p2 = p2->next;  
            p0 = p0->next;  
        }  
    }  
    if (p1 == nullptr) {  
        p0->next = p2;  
    }  
    if (p2 == nullptr) {  
        p0->next = p1;  
    }  
    return dummy.next;  
  
}
```


# [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

[[链表#[445. 两数相加 II](https //leetcode.cn/problems/add-two-numbers-ii/)]]
```c++
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {  
    if (l1 == nullptr || l2 == nullptr) {  
        return l1 == nullptr ? l2 : l1;  
    }  
    int carry = 0;  
    ListNode* p1 = l1;  
    ListNode* p2 = l2;  
    ListNode* prev1 = nullptr;  
    while (p1 != nullptr && p2 != nullptr) {  
        int sum = p1->val + p2->val+carry;  
        carry = sum / 10;  
        sum = sum % 10;  
        p1->val = sum;  
        prev1 = p1;  
        p1 = p1->next;  
        p2 = p2->next;  
    }  
    if (p1 == nullptr && p2 == nullptr) {  
        if (carry == 1) {  
            prev1->next = new ListNode(1);  
        }  
    }  
    else if (p1 == nullptr && p2 != nullptr) {  
        p1 = prev1;  
        while (p2 != nullptr) {  
            int sum = p2->val + carry;  
            carry = sum / 10;  
            sum = sum % 10;  
            p2->val = sum;  
            p1->next= p2;  
            p1= p1->next;  
            p2 = p2->next;  
        }  
        if (carry == 1) {  
            p1->next = new ListNode(1);  
        }  
    }else if (p1 != nullptr && p2 == nullptr) {  
        while (p1 != nullptr) {  
            int sum = p1->val + carry;  
            carry = sum / 10;  
            sum = sum % 10;  
            p1->val = sum;  
            prev1 = p1;  
            p1 = p1->next;  
        }  
        if (carry == 1) {  
            prev1->next = new ListNode(1);  
        }  
    }  
    return l1;  
}
```

# [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)
[[链表#[19. 删除链表的倒数第 N 个结点](https //leetcode.cn/problems/remove-nth-node-from-end-of-list/)]]
主要是要走到前一个节点

```c++
ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode dummy(0,head);
    ListNode* p0 = &dummy;
    for (int i = 0; i < n; i++) {
        p0 = p0->next;
    }
    ListNode* cur = &dummy;
    while (p0->next!=nullptr) {
        cur = cur->next;
        p0 = p0->next;
    }
    ListNode* temp = cur->next;
    cur->next = cur->next->next;
    delete temp;
    return dummy.next;
}
```


# ==[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)==
[[链表#[24. 两两交换链表中的节点](https //leetcode.cn/problems/swap-nodes-in-pairs/)]]
注意这个while的判断条件
```java
public ListNode swapPairs(ListNode head) {  
    ListNode dummy = new ListNode(0);  
    dummy.next = head;  
    ListNode prev = null, curr = head;  
    ListNode before = dummy;  
    while (curr != null && curr.next != null) {  
        for(int i=0;i<2;++i){  
             ListNode next = curr.next;  
             curr.next = prev;  
             prev = curr;  
             curr = next;  
        }  
        before.next.next = curr;  
        ListNode temp = before.next;  
        before.next = prev;  
        before = temp;  
  
    }  
    return dummy.next;  
}
```

# ==[25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)==
[[链表#[25. K 个一组翻转链表](https //leetcode.cn/problems/reverse-nodes-in-k-group/)]]
```java
public ListNode reverseKGroup(ListNode head, int k) {  
    ListNode dummy = new ListNode(0);  
    dummy.next = head;  
    ListNode cur = head;  
    int count = 0;  
    while (cur != null) {  
        ++count;  
        cur = cur.next;  
    }  
    cur = head;  
    ListNode p0 = dummy, pre = null,next = null;  
    for (int i = k; i <= count ; i+=k) {  
        for(int j=0;j<k;++j){  
            next = cur.next;  
            cur.next = pre;  
            pre = cur;  
            cur = next;  
        }  
        p0.next.next = cur;  
        ListNode temp = p0.next;  
        p0.next = pre;  
        p0 = temp;  
    }  
    return dummy.next;  
}
```
# ==[138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)==
## 解法1
而本题中因为随机指针的存在，当我们拷贝节点时，「当前节点的随机指针指向的节点」可能还没创建，因此我们需要变换思路。一个可行方案是，我们利用回溯的方式，让每个节点的拷贝操作相互独立。对于当前节点，我们首先要进行拷贝，然后我们进行「当前节点的后继节点」和「当前节点的随机指针指向的节点」拷贝，拷贝完成后将创建的新节点的指针返回，即可完成当前节点的两指针的赋值。

具体地，我们用哈希表记录每一个节点对应新节点的创建情况。遍历该链表的过程中，我们检查「当前节点的后继节点」和「当前节点的随机指针指向的节点」的创建情况。如果这两个节点中的任何一个节点的新节点没有被创建，我们都立刻递归地进行创建。当我们拷贝完成，回溯到当前层时，我们即可完成当前节点的指针赋值。注意一个节点可能被多个其他节点指向，因此我们可能递归地多次尝试拷贝某个节点，为了防止重复拷贝，我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，我们可以直接从哈希表中取出拷贝后的节点的指针并返回即可。

在实际代码中，我们需要特别判断给定节点为空节点的情况。

```c++
class Solution {
public:
    unordered_map<Node*, Node*> cachedNode;

    Node* copyRandomList(Node* head) {
        if (head == nullptr) {
            return nullptr;
        }
        if (!cachedNode.count(head)) {
            Node* headNew = new Node(head->val);
            cachedNode[head] = headNew;
            headNew->next = copyRandomList(head->next);
            headNew->random = copyRandomList(head->random);
        }
        return cachedNode[head];
    }
};
```

## 解法2



![[Pasted image 20250311103137.png]]

```c++
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (head == nullptr) {
            return nullptr;
        }

        // 复制每个节点，把新节点直接插到原节点的后面
        for (Node* cur = head; cur; cur = cur->next->next) {
            cur->next = new Node(cur->val, cur->next, nullptr);
        }

        // 遍历交错链表中的原链表节点
        for (Node* cur = head; cur; cur = cur->next->next) {
            if (cur->random) {
                // 要复制的 random 是 cur->random 的下一个节点
                cur->next->random = cur->random->next;
            }
        }

        // 把交错链表分离成两个链表
        Node* new_head = head->next;
        Node* cur = head;
        for (; cur->next->next; cur = cur->next) {
            Node* copy = cur->next;
            cur->next = copy->next; // 恢复原节点的 next
            copy->next = copy->next->next; // 设置新节点的 next
        }
        cur->next = nullptr; // 恢复原节点的 next
        return new_head;
    }
};
```

## 附加题 [328. 奇偶链表](https://leetcode.cn/problems/odd-even-linked-list/)
学习两个互相串连的连表的连接思路
```java
public ListNode oddEvenList(ListNode head) {  
    if (head == null || head.next == null) {  
        return head;  
    }  
    ListNode odd = head;  
    ListNode even = head.next;  
    ListNode evenHead = even;  
    while (even!=null && even.next != null ) {  
        odd.next = even.next;  
        even.next = even.next.next;  
        even = even.next;  
        odd = odd.next;  
    }  
    odd.next = evenHead;  
    return head;  
}
```
# [148. 排序链表](https://leetcode.cn/problems/sort-list/)

![[Pasted image 20250311105413.png]]
```c++
// 归并排序  
ListNode* getMid(ListNode* head) {  
    ListNode* slow = head, *fast = head,*prev = nullptr;  
    while (fast != nullptr && fast->next != nullptr) {  
        prev = slow;  
        slow = slow->next;  
        fast = fast->next->next;  
    }  
    prev->next = nullptr;  
    return slow;  
}  
ListNode* merge2Lists(ListNode* list1, ListNode* list2) {  
    ListNode dummy(0);  
    ListNode* p0 = &dummy;  
    while (list1 != nullptr && list2 != nullptr) {  
        if (list1->val < list2->val) {  
            p0->next = list1;  
            list1 = list1->next;  
        }else {  
            p0->next = list2;  
            list2 = list2->next;  
        }  
        p0 = p0->next;  
    }  
    if (list1 == nullptr) {  
        p0->next = list2;  
    }  
    if (list2 == nullptr) {  
        p0->next = list1;  
    }  
    return dummy.next;  
}  
ListNode* sortList(ListNode* head) {  
    if (head == nullptr || head->next == nullptr) {return head;}  
    ListNode* mid = getMid(head);  
    head = sortList(head);  
    mid = sortList(mid);  
    return merge2Lists(head,mid);;  
}
```
# ==[23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)==

## 方法一：最小堆
合并后的第一个节点 first，一定是某个链表的头节点（因为链表已按升序排列）。

合并后的第二个节点，可能是某个链表的头节点，也可能是 first 的下一个节点。

例如有三个链表 1->2->5, 3->4->6, 4->5->6，找到第一个节点 1 之后，第二个节点不是另一个链表的头节点，而是节点 1 的下一个节点 2。

按照这个过程继续思考，每当我们找到一个节点值最小的节点 x，就把节点 x.next 加入「可能是最小节点」的集合中。

因此，我们需要一个数据结构，它支持：
	从数据结构中找到并移除最小节点。
	插入节点。
	这可以用最小堆实现。初始把所有链表的头节点入堆，然后不断弹出堆中最小节点 x，如果 x.next 不为空就加入堆中。循环直到堆为空。把弹出的节点按顺序拼接起来，就得到了答案

```c++
ListNode* mergeKLists(vector<ListNode*>& lists) {  
    ListNode dummy(0);  
    ListNode* p0 = &dummy;  
    auto cmp = [](ListNode* a, ListNode* b) {  
        return a->val > b->val;  
    };  
    priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq(cmp);  
      
    for (auto list : lists) {  
        if (list != nullptr) {  
            pq.push(list);  
        }  
    }  
    while (pq.empty() == false) {  
        ListNode* cur = pq.top();  
        p0->next = cur;  
        pq.pop();  
        if (cur->next != nullptr) {  
            pq.push(cur->next);  
        }  
        p0 = p0->next;  
    }  
    return dummy.next;  
}
```
## 方法二： 分治

暴力做法是，按照  [[Hot100#[21. 合并两个有序链表](https //leetcode.cn/problems/merge-two-sorted-lists/)|21. 合并两个有序链表]] 的 题解思路，先合并前两个链表，再把得到的新链表和第三个链表合并，再和第四个链表合并，依此类推。

但是这种做法，平均每个节点会参与到 O(k) 次合并中（用 (1+2+⋯+k)/k 粗略估计），所以总的时间复杂度为 O(nk)。

一个巧妙的思路是，把 lists 一分为二（尽量均分），先合并前一半的链表，再合并后一半的链表，然后把这两个链表合并成最终的链表。如何合并前一半的链表呢？我们可以继续一分为二。如此分下去直到只有一个链表，此时无需合并。

我们可以写一个递归来完成上述逻辑，如果你对递归头晕，请看【基础算法精讲 09】。

按照一分为二再合并的逻辑，递归像是在后序遍历一棵平衡二叉树。由于平衡树的高度是 O(logk)，所以每个链表节点只会出现在 O(logk) 次合并中！这样就做到了更快的 O(nlogk) 时间。
# ==[146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)==

有首尾相连的双向链表管理顺序和删除问题，用哈希表让查找时间变成O(1)，使用dummy哨兵避免头节点为空的情况（一开始dummy要指向自己，这样才可以保证最后一个节点指向头节点，这样可以通过dummy获得尾部节点），并且获得头节点，方便插入。主要实现Remove函数，Push_Front函数，get_node函数
![](https://pic.leetcode.cn/1696039105-PSyHej-146-3-c.png)
```c++

```


## 相似题目：[460. LFU 缓存](https://leetcode.cn/problems/lfu-cache/)
从一捆书变成多捆书
用map存储多捆书的开头（dummy）
```c++
class Node {
public:
    int key;
    int value;
    int freq = 1; // 新书只读了一次
    Node* prev;
    Node* next;

    Node(int k = 0, int v = 0) : key(k), value(v) {}
};

class LFUCache {
private:
    int min_freq;
    int capacity;
    unordered_map<int, Node*> key_to_node;
    unordered_map<int, Node*> freq_to_dummy;

    Node* get_node(int key) {
        auto it = key_to_node.find(key);
        if (it == key_to_node.end()) { // 没有这本书
            return nullptr;
        }
        Node* node = it->second; // 有这本书
        remove(node); // 把这本书抽出来
        Node* dummy = freq_to_dummy[node->freq];
        if (dummy->prev == dummy) { // 抽出来后，这摞书是空的
            freq_to_dummy.erase(node->freq); // 移除空链表
            delete dummy; // 释放内存
            if (min_freq == node->freq) { // 这摞书是最左边的
                min_freq++;
            }
        }
        push_front(++node->freq, node); // 放在右边这摞书的最上面
        return node;
    }

    // 创建一个新的双向链表
    Node* new_list() {
        Node* dummy = new Node(); // 哨兵节点
        dummy->prev = dummy;
        dummy->next = dummy;
        return dummy;
    }

    // 在链表头添加一个节点（把一本书放在最上面）
    void push_front(int freq, Node* x) {
        auto it = freq_to_dummy.find(freq);
        if (it == freq_to_dummy.end()) { // 这摞书是空的
            it = freq_to_dummy.emplace(freq, new_list()).first;
        }
        Node* dummy = it->second;
        x->prev = dummy;
        x->next = dummy->next;
        x->prev->next = x;
        x->next->prev = x;
    }

    // 删除一个节点（抽出一本书）
    void remove(Node* x) {
        x->prev->next = x->next;
        x->next->prev = x->prev;
    }

public:
    LFUCache(int capacity) : capacity(capacity) {}

    int get(int key) {
        Node* node = get_node(key);
        return node ? node->value : -1;
    }

    void put(int key, int value) {
        Node* node = get_node(key);
        if (node) { // 有这本书
            node->value = value; // 更新 value
            return;
        }
        if (key_to_node.size() == capacity) { // 书太多了
            Node* dummy = freq_to_dummy[min_freq];
            Node* back_node = dummy->prev; // 最左边那摞书的最下面的书
            key_to_node.erase(back_node->key);
            remove(back_node); // 移除
            delete back_node; // 释放内存
            if (dummy->prev == dummy) { // 这摞书是空的
                freq_to_dummy.erase(min_freq); // 移除空链表
                delete dummy; // 释放内存
            }
        }
        key_to_node[key] = node = new Node(key, value); // 新书
        push_front(1, node); // 放在「看过 1 次」的最上面
        min_freq = 1;
    }
};
```
# [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)
懒得写了
[[二叉树#[二叉树的迭代遍历](https //programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html %E6%80%9D%E8%B7%AF)]]

# [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
[[二叉树#[104. 二叉树的最大深度](https //leetcode.cn/problems/maximum-depth-of-binary-tree/)]]
```java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
```


# [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)
[[二叉树#[226. 翻转二叉树](https //leetcode.cn/problems/invert-binary-tree/)]]
左子树变右子树
```java
public TreeNode invertTree(TreeNode root) {  
    if (root == null) return null;  
    TreeNode left =invertTree(root.left);  
    TreeNode right = invertTree(root.right);  
    root.left = right;  
    root.right = left;  
    return root;  
}
```


# [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)
[[二叉树#[101. 对称二叉树](https //leetcode.cn/problems/symmetric-tree/)]]
往左往右走
```java
public boolean iS(TreeNode left, TreeNode right) {  
    if (left == null && right == null) return true;  
    else if (left == null || right == null) return false;  
    if (left.val != right.val) return false;  
    return iS(left.left, right.right) && iS(left.right, right.left);  
}  
public boolean isSymmetric(TreeNode root) {  
    if (root == null) return true;  
    return iS(root.left, root.right);  
}
```

# ==[543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)==

# [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

[[二叉树#[102. 二叉树的层序遍历](https //leetcode.cn/problems/binary-tree-level-order-traversal/)]]

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ret = new ArrayList<List<Integer>>();
        if (root == null) {
            return ret;
        }

        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            List<Integer> level = new ArrayList<Integer>();
            int currentLevelSize = queue.size();
            for (int i = 1; i <= currentLevelSize; ++i) {
                TreeNode node = queue.poll();
                level.add(node.val);
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            ret.add(level);
        }
        
        return ret;
    }
}
```

# [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

[[二叉树#[108. 将有序数组转换为二叉搜索树](https //leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)]]

```java
    public TreeNode sATB(int[] nums,int left,int right) {
        if(left > right) return null;
        int mid= left + (right - left)/2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = sATB(nums,left,mid-1);
        root.right = sATB(nums,mid+1,right);
        return root;
    }
    public TreeNode sortedArrayToBST(int[] nums) {
        return sATB(nums,0,nums.length-1);
    }
```




#  [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)
[[二叉树#[98. 验证二叉搜索树](https //leetcode.cn/problems/validate-binary-search-tree/)]]
```java
TreeNode preNode=null;  
public boolean isValidBST(TreeNode root) {  
    if (root == null) return true;  
    boolean left = isValidBST(root.left);  
    if(preNode ==null) preNode=root;  
    else {  
        if(root.val<=preNode.val) return false;  
        preNode=root;  
    }  
    boolean right = isValidBST(root.right);  
    return left && right;  
}
```


# [230. 二叉搜索树中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

[[二叉树#[230. 二叉搜索树中第 K 小的元素](https //leetcode.cn/problems/kth-smallest-element-in-a-bst/)]]
```java
class Solution {
    private int k;

    public int kthSmallest(TreeNode root, int k) {
        this.k = k;
        return dfs(root);
    }

    private int dfs(TreeNode node) {
        if (node == null) {
            return -1; // 题目保证节点值非负，用 -1 表示没有找到
        }
        int leftRes = dfs(node.left);
        if (leftRes != -1) { // 答案在左子树中
            return leftRes;
        }
        if (--k == 0) { // 答案就是当前节点
            return node.val;
        }
        return dfs(node.right); // 右子树会返回答案或者 -1
    }
}
```

# [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

[[二叉树#[199. 二叉树的右视图](https //leetcode.cn/problems/binary-tree-right-side-view/)]]
也可以用层序遍历做
```java
    int maxLevel=0;
    public void rSV(TreeNode root,List<Integer> res, int k) {
        if(root == null) return;
        if (maxLevel == k) {
            res.add(root.val);
            maxLevel++;
        }
        rSV(root.right,res,k+1);
        rSV(root.left,res,k+1);
    }
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        rSV(root,res,0);
        return res;
    }
```

# [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

观察顺序，其实是要最遍历右左中->才可以输出中左右的结果（因为递归模仿了栈的行为），所以这样写
```java
TreeNode preNode2=null;  
public void flatten(TreeNode root) {  
    if (root == null) return;  
    flatten(root.right);  
    flatten(root.left);  
    root.left = null;  
    root.right = preNode2;  
    preNode2 = root;  
}
```


# [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

[[二叉树#[105. 从前序与中序遍历序列构造二叉树](https //leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)]]

注意这个范围怎么定义

```java
Map<Integer,Integer> map=new HashMap<>();  
public TreeNode bT(int[] preorder, int[] inorder, int pstart, int pend,int istart,int iend) {  
    if (pstart > pend) return null;  
    if (pstart == pend) return new TreeNode(preorder[pstart]);  
    int rootVal = preorder[pstart];  
    int index = map.get(rootVal);  
    int range = index - istart;  
    TreeNode root = new TreeNode(rootVal);  
    root.left = bT(preorder,inorder,pstart+1,pstart+range,istart,index-1);  
    root.right = bT(preorder,inorder,pstart+range+1,pend,index+1,iend);  
    return root;  
}  
public TreeNode buildTree(int[] preorder, int[] inorder) {  
    for(int i =0;i<inorder.length;i++) {  
        map.put(inorder[i],i);  
    }  
    return bT(preorder,inorder,0,preorder.length-1,0,inorder.length-1);  
}
```

# ==[437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)==


# ==[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)==
[[二叉树#[236. 二叉树的最近公共祖先](https //leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)]]
分情况讨论

```c++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {  
    if (root == nullptr || root == p || root == q) return root;  
    TreeNode* left = lowestCommonAncestor(root->left, p, q);  
    TreeNode* right = lowestCommonAncestor(root->right, p, q);  
    if (left == nullptr && right == nullptr) {  
        return nullptr;  
    }else if (left != nullptr && right == nullptr) {  
        return left;  
    }else if (left == nullptr && right != nullptr) {  
        return right;  
    }else {  
        return root;  
    }  
}
```

# ==[124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)==



# [46. 全排列](https://leetcode.cn/problems/permutations/)

[[回溯#[46. 全排列](https //leetcode.cn/problems/permutations/)]]

```java
public void bT(List<List<Integer>> res, List<Integer> path, HashSet<Integer> set, int[] nums) {  
    if (path.size() == nums.length) {  
        res.add(new ArrayList<>(path)); // 确保加入的是 `path` 的副本  
        return;  // 这里需要 return，否则会继续执行循环  
    }  
  
    for (int i = 0; i < nums.length; i++) {  
        if (set.contains(nums[i])) continue; // 如果当前数字已被使用，则跳过  
  
        set.add(nums[i]);  
        path.add(nums[i]);  
  
        bT(res, path, set, nums); // 递归  
  
        path.remove(path.size() - 1); // 回溯，移除最后一个添加的元素  
        set.remove(nums[i]); // 这里要用 `nums[i]` 而不是 `path.size()-1`    }  
}  
  
public List<List<Integer>> permute(int[] nums) {  
    List<List<Integer>> res = new ArrayList<>();  
    List<Integer> path = new ArrayList<>();  
    HashSet<Integer> set = new HashSet<>();  
  
    if (nums == null || nums.length == 0) return res;  
  
    bT(res, path, set, nums);  
    return res;  
}
```


# [78. 子集](https://leetcode.cn/problems/subsets/)

[[回溯#[78. 子集](https //leetcode.cn/problems/subsets/)]]

```java
public void bT2(List<List<Integer>> res, List<Integer> path, int[] nums,int k) {  
    res.add(new ArrayList<>(path));  
  
    for (int i = k; i < nums.length; i++) {  
        path.add(nums[i]);  
        bT2(res, path, nums, i+1);  
        path.remove(path.size() - 1);  
    }  
}  
public List<List<Integer>> subsets(int[] nums) {  
    List<List<Integer>> res = new ArrayList<>();  
    List<Integer> path = new ArrayList<>();  
    if (nums == null || nums.length == 0) return res;  
    bT2(res, path, nums, 0);  
    return res;  
}
```


#  [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)
[[回溯#[17. 电话号码的字母组合](https //leetcode.cn/problems/letter-combinations-of-a-phone-number/)]]

```java
class Solution {
    private static final String[] MAPPING = new String[]{"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};

    private final List<String> ans = new ArrayList<>();
    private char[] digits;
    private char[] path;

    public List<String> letterCombinations(String digits) {
        int n = digits.length();
        if (n == 0) {
            return List.of();
        }
        this.digits = digits.toCharArray();
        path = new char[n]; // 注意 path 长度一开始就是 n，不是空数组
        dfs(0);
        return ans;
    }

    private void dfs(int i) {
        if (i == digits.length) {
            ans.add(new String(path));
            return;
        }
        for (char c : MAPPING[digits[i] - '0'].toCharArray()) {
            path[i] = c; // 直接覆盖
            dfs(i + 1);
        }
    }
}
```



# [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

[[回溯#[39. 组合总和](https //leetcode.cn/problems/combination-sum/)]]
```java
public void  bT3(List<List<Integer>> res, List<Integer> path, int[] nums,int k, int sum, int target) {  
    if(sum == target) {  
        res.add(new ArrayList<>(path));  
    }if (sum > target) return;  
      
    for (int i = k; i < nums.length; i++) {  
        path.add(nums[i]);  
        sum += nums[i];  
        bT3(res, path, nums, i, sum, target);  
        path.remove(path.size() - 1);  
        sum -= nums[i];  
    }  
}  
public List<List<Integer>> combinationSum(int[] candidates, int target) {  
    List<List<Integer>> res = new ArrayList<>();  
    List<Integer> path = new ArrayList<>();  
    bT3(res, path, candidates, 0, 0, target);  
    return res;  
}
```

# [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

[[回溯#[22. 括号生成](https //leetcode.cn/problems/generate-parentheses/)]]
考虑每个位置选or不选
```java
public void bT4(List<String> res, char[] path, int left, int right,int i,int n) {  
    if(left + right == 2 * n) res.add(new String(path));  
  
    if (left > right ) {  
        path[i] = ')';  
        bT4(res, path, left, right + 1, i+1, n);  
    }  
    if (left < n) {  
        path[i] = '(';  
        bT4(res, path, left+1, right, i+1, n);  
    }  
  
}  
public List<String> generateParenthesis(int n) {  
    char[] c = new char[2 * n];  
    List<String> res = new ArrayList<>();  
    bT4(res, c, 0, 0, 0, n);  
    return  res;  
}
```

# ==[79. 单词搜索](https://leetcode.cn/problems/word-search/)==

# [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

[[回溯#[131. 分割回文串](https //leetcode.cn/problems/palindrome-partitioning/)]]
之前写的答案会好点
```c++
bool isHuiwen(string& str) {  
    int left = 0, right = str.size() - 1;  
    while (left < right) {  
        if (str[left++] != str[right--]) {  
            return false;  
        }  
    }  
    return true;  
}  
void bT(vector<vector<string>>& res, vector<string>& strs, string& s, int k) {  
    if (k == s.size()) {  
        res.push_back(strs);  
        return;  
    }  
    for (int i = k; i < s.size(); i++) {  
        string sub = s.substr(k, i-k+1);  
        if (isHuiwen(sub)) {  
            strs.push_back(sub);  
            bT(res, strs, s, i+1);  
            strs.pop_back();  
        }  
    }  
}  
vector<vector<string>> partition(string s) {  
    vector<vector<string>> res;  
    vector<string> strs;  
    bT(res, strs, s, 0);  
    return res;  
}

```
# [51. N 皇后](https://leetcode.cn/problems/n-queens/)
[[回溯#[51. N 皇后](https //leetcode.cn/problems/n-queens/)]]
0x3f
```c++
class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> ans;
        vector<int> queens(n); // 皇后放在 (r,queens[r])
        vector<int> col(n), diag1(n * 2 - 1), diag2(n * 2 - 1); // vector<int> 效率比 vector<bool> 高
        auto dfs = [&](this auto&& dfs, int r) {
            if (r == n) {
                vector<string> board(n);
                for (int i = 0; i < n; i++) {
                    board[i] = string(queens[i], '.') + 'Q' + string(n - 1 - queens[i], '.');
                }
                ans.push_back(board);
                return;
            }
            // 在 (r,c) 放皇后
            for (int c = 0; c < n; c++) {
                int rc = r - c + n - 1;
                if (!col[c] && !diag1[r + c] && !diag2[rc]) { // 判断能否放皇后
                    queens[r] = c; // 直接覆盖，无需恢复现场
                    col[c] = diag1[r + c] = diag2[rc] = true; // 皇后占用了 c 列和两条斜线
                    dfs(r + 1);
                    col[c] = diag1[r + c] = diag2[rc] = false; // 恢复现场
                }
            }
        };
        dfs(0);
        return ans;
    }
};
```


# [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)
[[二分查找]]
二分，注意分完之后left和right表示的值
```c++
int searchInsert(vector<int>& nums, int target) {  
    int left = 0, right = nums.size() - 1;  
    while (left <= right) {  
        int mid = left + (right - left) / 2;  
        if (nums[mid] == target) {  
            return mid;  
        }else if (nums[mid] < target) {  
            left = mid + 1;  
        }else {  
            right = mid - 1;  
        }  
    }  
    return left;  
}
```


# [74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)

懒得写了，主要就是怎么把二位数组转成一维数组
```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(), n = matrix[0].size();
        int left = -1, right = m * n;
        while (left + 1 < right) {
            int mid = left + (right - left) / 2;
            int x = matrix[mid / n][mid % n];
            if (x == target) {
                return true;
            }
            (x < target ? left : right) = mid;
        }
        return false;
    }
};
```


# [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)
注意最后判断的时候的边界检测，在nums只有1个or0个的时候，left-1和right+1会超出数组边界
[[二分查找#[34. 在排序数组中查找元素的第一个和最后一个位置](https //leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)]]
```c++
vector<int> searchRange(vector<int>& nums, int target) {  
    vector<int> result = {-1, -1};  
    // if (nums.empty()) {return result;}  
    int left = 0, right = nums.size() - 1;  
    // 找两次，分别定位 >= target 和 <= target 的边界  
  
    // 第一次循环：找左边界（即右侧最后一个小于等于 target 的位置+1）  
    while (left <= right) {  
        int mid = left + (right - left) / 2;  
        if (nums[mid] <= target) {  
            left = mid + 1;  
        } else { // nums[mid] > target  
            right = mid - 1;  
        }  
    }  
    // 注意：此时 left 指向第一个大于 target 的位置，  
    // 若 nums[left-1] 等于 target，则该位置即为右边界  
    if (left - 1 >= 0 && nums[left - 1] == target) {  
        result[1] = left - 1;  
    }  
  
    // 第二次循环：找右边界（即左侧最后一个小于 target 的位置）  
    left = 0, right = nums.size() - 1;  
    while (left <= right) {  
        int mid = left + (right - left) / 2;  
        if (nums[mid] < target) {  
            left = mid + 1;  
        } else { // nums[mid] >= target  
            right = mid - 1;  
        }  
    }  
    // 此时 right+1 指向第一个不小于 target 的位置，  
    // 如果 nums[right+1] 等于 target，则该位置就是左边界  
    if (right + 1 < nums.size() && nums[right + 1] == target) {  
        result[0] = right + 1;  
    }  
    return result;  
}
```


# [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)
这个条件判断绕了我半天。。主要就是根据数据，发觉信息
[[二分查找#[33. 搜索旋转排序数组](https //leetcode.cn/problems/search-in-rotated-sorted-array/)]]
```c++
class Solution {  
public:  
    int search(vector<int>& nums, int target) {  
        // 首先判断转了没有  
        bool isS = false;  
        if (nums[0] > nums[nums.size() - 1]) {  
            isS = true;  
        }  
        int left = 0, right = nums.size() - 1;  
        while (left <= right) {  
            int mid = left + (right - left) / 2;  
            if (isS == true) {  
                if (nums[mid] == target) {  
                    return mid;  
                }  
                // nums[mid]<= nums[nums.size() - 1],说明mid在右区间，此时nums[mid] > target，一定要往左找  
                else if (nums[mid] <= nums[nums.size() - 1] && nums[mid] > target ) {  
                    right = mid - 1;  
                }  
                //nums[mid]<= nums[nums.size() - 1],说明mid在右区间, 此时nums[0] <= target，说明答案一定在左区间，要往左边找  
                else if (nums[mid] <= nums[nums.size() - 1] && nums[0] <= target ) {  
                    right = mid - 1;  
                }  
                // nums[mid] > nums[nums.size() - 1],说明mid在左区间，此时如果target>=nums[0]并且target<nums[mid]，说明答案在左边 就要往左找  
                else if (nums[mid] > nums[nums.size() - 1] && target >= nums[0] && target < nums[mid]) {  
                    right = mid - 1;  
                }else {  
                    left = mid + 1;  
                }  
            }else {  
                if (nums[mid] == target) {  
                    return mid;  
                }else if (nums[mid] < target) {  
                    left = mid + 1;  
                }else if (nums[mid] > target) {  
                    right = mid - 1;  
                }  
  
            }  
        }  
        return -1;  
    }  
};
```



# [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)
[[二分查找#[153. 寻找旋转排序数组中的最小值](https //leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)]]

同理注意越界
```c++
int findMin(vector<int>& nums) {  
    int left = 0, right = nums.size() - 1;  
    if (nums[left] < nums[right]) {  
        return nums[left];  
    }  
    // left表示left左边的是左区间，right表示right右边的是右区间  
    while (left <= right) {  
        int mid = left + (right - left) / 2;  
        // 在左区间  
        if (nums[mid] >= nums[0]) {  
            left = mid + 1;  
        }else if (nums[mid] < nums[0]) {  
            right = mid - 1;  
        }  
    }  
    return right+1<nums.size() ?nums[right+1] : nums[right];  
}
```


# [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)


# [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)
[[栈和队列#[20. 有效的括号](https //leetcode.cn/problems/valid-parentheses/)]]

```c++
bool isValid(string s) {  
    stack<char> st;  
    for (int i = 0; i < s.size(); i++) {  
        if (s[i] =='(') st.push(')');  
        else if (s[i] =='{') st.push('}');  
        else if (s[i] =='[') st.push(']');  
        else {  
            if (st.empty() || st.top() != s[i]) return false;  
            st.pop();  
        }  
    }  
    return st.empty();  
}
```

# [155. 最小栈](https://leetcode.cn/problems/min-stack/)

算法流程：

push() 方法： 每当push()新值进来时，如果 小于等于 min_stack 栈顶值，则一起 push() 到 min_stack，即更新了栈顶最小值；

pop() 方法： 判断将 pop() 出去的元素值是否是 min_stack 栈顶元素值（即最小值），如果是则将 min_stack 栈顶元素一起 pop()，这样可以保证 min_stack 栈顶元素始终是 stack 中的最小值。

getMin()方法： 返回 min_stack 栈顶即可。

min_stack 作用分析：
min_stack 等价于遍历 stack所有元素，把升序的数字都删除掉，留下一个从栈底到栈顶降序的栈。
相当于给 stack 中的降序元素做了标记，每当 pop() 这些降序元素，min_stack 会将相应的栈顶元素 pop() 出去，保证其栈顶元素始终是 stack 中的最小元素。

```c++
class MinStack {  
public:  
    stack<int> s;  
    stack<int> minStack;  
    MinStack(){  
    }  
  
    void push(int val) {  
        s.push(val);  
        if (minStack.empty() || val <= minStack.top()) {  
            minStack.push(val);  
        }  
    }  
  
    void pop() {  
        int top = s.top();  
        s.pop();  
        if (top == minStack.top()) {  
            minStack.pop();  
        }  
    }  
  
    int top() {  
        return s.top();  
    }  
  
    int getMin() {  
        return minStack.top();  
    }  
};
```
# [394. 字符串解码](https://leetcode.cn/problems/decode-string/)

# [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

# [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)




# [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)
用快排的思维解决

```c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        return quickSelect(nums, k);
    }
    
private:
    int quickSelect(vector<int>& nums, int k) {
        // 随机选择基准数
        int pivot = nums[rand() % nums.size()];
        // 将大于、小于、等于 pivot 的元素划分至 big, small, equal 中
        vector<int> big, equal, small;
        for (int num : nums) {
            if (num > pivot)
                big.push_back(num);
            else if (num < pivot)
                small.push_back(num);
            else
                equal.push_back(num);
        }
        // 第 k 大元素在 big 中，递归划分
        if (k <= big.size())
            return quickSelect(big, k);
        // 第 k 大元素在 small 中，递归划分
        if (nums.size() - small.size() < k)
            return quickSelect(small, k - nums.size() + small.size());
        // 第 k 大元素在 equal 中，直接返回 pivot
        return pivot;
    }
};
```
# [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)
前K个大都用堆来解决
```c++
  
class Solution {  
public:  
    // 小顶堆  
    class mycomparison {  
    public:  
        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {  
            return lhs.second > rhs.second;  
        }  
    };  
    vector<int> topKFrequent(vector<int>& nums, int k) {  
        // 要统计元素出现频率  
        unordered_map<int, int> map; // map<nums[i],对应出现的次数>  
        for (int i = 0; i < nums.size(); i++) {  
            map[nums[i]]++;  
        }  
  
        // 对频率排序  
        // 定义一个小顶堆，大小为k  
        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;  
  
        // 用固定大小为k的小顶堆，扫面所有频率的数值  
        for (unordered_map<int, int>::iterator it = map.begin(); it != map.end(); it++) {  
            pri_que.push(*it);  
            if (pri_que.size() > k) { // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k  
                pri_que.pop();  
            }  
        }  
  
        // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组  
        vector<int> result(k);  
        for (int i = k - 1; i >= 0; i--) {  
            result[i] = pri_que.top().first;  
            pri_que.pop();  
        }  
        return result;  
  
    }  
};
```

# [295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/)

中位数把这 6 个数均分成了左右两部分，一边是 left=[1,2,3]，另一边是 right=[4,5,6]。我们要计算的中位数，就来自 left 中的最大值，以及 right 中的最小值。

随着 addNum 不断地添加数字，我们需要：

保证 left 的大小和 right 的大小尽量相等。==规定：在有奇数个数时，left 比 right 多 1 个数。==
保证 left 的所有元素都小于等于 right 的所有元素。
只要时时刻刻满足以上两个要求（满足中位数的定义），我们就可以用 left 中的最大值以及 right 中的最小值计算中位数。

分类讨论：

如果当前 left 的大小和 right 的大小相等：
	- 如果添加的数字 num 比较大，比如添加 7，那么把 7 加到 right 中。现在 left 比 right 少 1 个数，不符合前文的规定，所以必须把 right 的最小值从 right 中去掉，添加到 left 中。如此操作后，可以保证 left 的所有元素都小于等于 right 的所有元素。
	- 如果添加的数字 num 比较小，比如添加 0，那么把 0 加到 left 中。
	- 这两种情况可以合并：无论 num 是大是小，都可以先把 num 加到 right 中，然后把 right 的最小值从 right 中去掉，并添加到 left 中。

如果当前 left 比 right 多 1 个数：
	- 如果添加的数字 num 比较大，比如添加 7，那么把 7 加到 right 中。
	- 如果添加的数字 num 比较小，比如添加 0，那么把 0 加到 left 中。现在 left 比 right 多 2 个数，不符合前文的规定，所以必须把 left 的最大值从 left 中去掉，添加到 right 中。如此操作后，可以保证 left 的所有元素都小于等于 right 的所有元素。
	- 这两种情况可以合并：无论 num 是大是小，都可以先把 num 加到 left 中，然后把 left 的最大值从 left 中去掉，并添加到 right 中。

```c++
class MedianFinder {
    priority_queue<int> left; // 最大堆
    priority_queue<int, vector<int>, greater<>> right; // 最小堆

public:
    void addNum(int num) {
        if (left.size() == right.size()) {
            right.push(num);
            left.push(right.top());
            right.pop();
        } else {
            left.push(num);
            right.push(left.top());
            left.pop();
        }
    }

    double findMedian() {
        if (left.size() > right.size()) {
            return left.top();
        }
        return (left.top() + right.top()) / 2.0;
    }
};
```
# [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)
从左到右枚举卖出价格 prices[i]，那么要想获得最大利润，我们需要知道第 i 天之前，股票价格的最小值是什么，也就是从 prices[0] 到 prices[i−1] 的最小值，把它作为买入价格，这可以用一个变量 minPrice 维护。

请注意，minPrice 维护的是 prices[i] 左侧元素的最小值。

由于只能买卖一次，所以在遍历中，维护 prices[i]−minPrice 的最大值，就是答案。

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int ans = 0;
        int min_price = prices[0];
        for (int p : prices) {
            ans = max(ans, p - min_price);
            min_price = min(min_price, p);
        }
        return ans;
    }
};
```


# [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)
[[贪心#[55. 跳跃游戏](https //leetcode.cn/problems/jump-game/)]]

```c++
bool canJump(vector<int>& nums) {  
    int maxRange = 0;  
    for (int i = 0; i <= maxRange; i++) {  
        maxRange = max(maxRange,i+nums[i]);  
        if (maxRange >= nums.size()-1) {return true;}  
    }  
    return maxRange >= nums.size()-1;  
}
```

## 相似题目：
[2580. 统计将重叠区间合并成组的方案数](https://leetcode.cn/problems/count-ways-to-group-overlapping-ranges/)
[2963. 统计好分割方案的数目](https://leetcode.cn/problems/count-the-number-of-good-partitions/)
[2584. 分割数组使乘积互质](https://leetcode.cn/problems/split-the-array-to-make-coprime-products/)
[1024. 视频拼接](https://leetcode.cn/problems/video-stitching/)
[1326. 灌溉花园的最少水龙头数目](https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/)
# [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

[看看0x3f的题解](https://leetcode.cn/problems/jump-game-ii/solutions/)，感觉说得挺好的
```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        int ans = 0;
        int cur_right = 0; // 已建造的桥的右端点
        int next_right = 0; // 下一座桥的右端点的最大值
        for (int i = 0; i + 1 < nums.size(); i++) {
            // 遍历的过程中，记录下一座桥的最远点
            next_right = max(next_right, i + nums[i]);
            if (i == cur_right) { // 无路可走，必须建桥
                cur_right = next_right; // 建桥后，最远可以到达 next_right
                ans++;
            }
        }
        return ans;
    }
};
```


# [763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)
也可以堪称合并区间

```c++
vector<int> partitionLabels(string s) {  
    int n[26];  
    for (int i = 0; i < s.size(); i++) {  
        n[s[i]-'a'] = i;  
    }  
    vector<int> result;  
    int left = 0;  
    int right = 0;  
    for (int i = 0; i < s.size(); i++) {  
        right = max(right, n[s[i]-'a']);  
        if (i == right) {  
            result.push_back(i-left + 1);  
            left = i+1;  
        }  
    }  
    return result;  
}
```


