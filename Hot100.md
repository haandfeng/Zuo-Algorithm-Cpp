# [1. 两数之和](https://leetcode.cn/problems/two-sum/)
[[哈希表#[1. 两数之和](https //leetcode.cn/problems/two-sum/)]]
用hash表
```c++
vector<int> twoSum(vector<int>& nums, int target) {  
    unordered_map<int, int> hashtable;  
    for (int i = 0; i < nums.size(); ++i) {  
        auto it = hashtable.find(target - nums[i]);  
        if (it != hashtable.end()) {  
            return {it->second, i};  
        }  
        hashtable[nums[i]] = i;  
    }  
    return {};  
}
```

# [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

注意到，如果把 aab,aba,baa 按照字母从小到大排序，我们可以得到同一个字符串 aab。
而对于每种字母出现次数不同于 aab 的字符串，例如 abb 和 bab，排序后为 abb，不等于 aab。
==所以当且仅当两个字符串排序后一样，这两个字符串才能分到同一组。== 相同点
根据这一点，我们可以用哈希表来分组，把排序后的字符串当作 key，原字符串组成的列表（即答案）当作 value。

```c++
vector<vector<string>> groupAnagrams(vector<string>& strs) {  
    unordered_map<string, vector<string>> m;  
    for (string& s : strs) {  
        string sorted_s = s;  
        ranges::sort(sorted_s);  
        m[sorted_s].push_back(s); // sorted_s 相同的字符串分到同一组  
    }  
  
    vector<vector<string>> ans;  
    ans.reserve(m.size()); // 预分配空间  
    for (auto& [_, value] : m) {  
        ans.push_back(value);  
    }  
    return ans;
}
```


# [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

我们考虑枚举数组中的每个数 x，考虑以其为起点，不断尝试匹配 x+1,x+2,⋯ 是否存在，假设最长匹配到了 x+y，那么以 x 为起点的最长连续序列即为 x,x+1,x+2,⋯,x+y，其长度为 y+1，我们不断枚举并更新答案即可。

对于匹配的过程，暴力的方法是 O(n) 遍历数组去看是否存在这个数，但其实更高效的方法是用一个哈希表存储数组中的数，这样查看一个数是否存在即能优化至 O(1) 的时间复杂度。

仅仅是这样我们的算法时间复杂度最坏情况下还是会达到 O(n 
2
 )（即外层需要枚举 O(n) 个数，内层需要暴力匹配 O(n) 次），无法满足题目的要求。但仔细分析这个过程，我们会发现其中执行了很多不必要的枚举，如果已知有一个 x,x+1,x+2,⋯,x+y 的连续序列，而我们却重新从 x+1，x+2 或者是 x+y 处开始尝试匹配，那么得到的结果肯定不会优于枚举 x 为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可。

那么怎么判断是否跳过呢？由于我们要枚举的数 x 一定是在数组中不存在前驱数 x−1 的，不然按照上面的分析我们会从 x−1 开始尝试匹配，因此我们每次在哈希表中检查是否存在 x−1 即能判断是否需要跳过了。


```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> num_set;
        for (const int& num : nums) {
            num_set.insert(num);
        }

        int longestStreak = 0;

        for (const int& num : num_set) {
            if (!num_set.count(num - 1)) {
                int currentNum = num;
                int currentStreak = 1;

                while (num_set.count(currentNum + 1)) {
                    currentNum += 1;
                    currentStreak += 1;
                }

                longestStreak = max(longestStreak, currentStreak);
            }
        }

        return longestStreak;           
    }
};
```


# [283. 移动零](https://leetcode.cn/problems/move-zeroes/)
把 0 视作空位。我们要把所有非零元素都移到数组左边的空位上，并保证非零元素的顺序不变。

例如 nums=[0,0,1,2]，把 1 放到最左边的空位上，数组变成 [1​, 0, 0, 2]。注意 1 移动过去后，在原来 1 的位置又产生了一个新的空位。也就是说，我们交换了 nums[0]=0 和nums[2]=1 这两个数。

为了保证非零元素的顺序不变，我们需要维护最左边的空位的位置（下标）。

![[Pasted image 20250305163349.png]]


```c++
void moveZeroes(vector<int>& nums) {  
    int i0 = 0;  
    for (int& x : nums) { // 注意 x 是引用  
        if (x) {  
            swap(x, nums[i0]);  
            i0++;  
        }  
    }  
}
```


# [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)
[[双向双指针#[11. 盛最多水的容器](https //leetcode.cn/problems/container-with-most-water/)]]

如果要找到要容量更大的，说明移动的时候要找到更长的线，木桶效应，靠短板决定，所以要更新短板
```c++
int maxArea(vector<int>& height) {  
    int ans = 0,left=0,right =height.size()-1;  
    while (left < right) {  
        ans = max((right-left)*min(height[left],height[right]), ans);  
        if (height[left] >= height[right]) {--right;}  
        else {++left;}  
    }  
    return ans;  
}
```


# [15. 三数之和](https://leetcode.cn/problems/3sum/)
[[双向双指针#[15. 三数之和](https //leetcode.cn/problems/3sum/)]]
两数之和的变种，先确定一个数，然后写两数之和的代码
注意去重
没有做优化，优化看连接
```c++
vector<vector<int>> threeSum(vector<int>& nums) {  
    vector<vector<int>> ans;  
    sort(nums.begin(), nums.end());  
    for (int i = 0; i < nums.size(); i++) {  
        if (i > 0 && nums[i] == nums[i-1]) {continue;}  
        int target = -nums[i];  
        int left = i + 1, right = nums.size() - 1;  
        while (left < right) {  
            if (nums[left] + nums[right] == target) {  
                ans.push_back({nums[i],nums[left],nums[right]});  
                ++left;  
                while (left < right && nums[left] == nums[left-1]) {++left;}  
            }else if (nums[left] + nums[right] > target) {  
                --right;  
            }else {  
                ++left;  
            }  
        }  
    }  
    return ans;  
}
```


# [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)
[[双向双指针#[42. 接雨水](https //leetcode.cn/problems/trapping-rain-water/)]]
一个单位能接到水的容量是往左看和往右看的木板的最小值-自己的高度
前缀最大值和后缀最大值

# [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

[[滑动窗口(同向双指针)#[3. 无重复字符的最长子串](https //leetcode.cn/problems/longest-substring-without-repeating-characters/)]]

# [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)


# [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)
## 前置：[303. 区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/)
为方便描述，把 nums 记作 a。
对于数组 a，定义它的前缀和
	s [0] = 0 
	s [1] = a[0]
	s [2] = a[0]+a[1]
	.......
![[Pasted image 20250307155115.png]]


问：为什么要定义 s[0]=0，这样做有什么好处？

答：如果 left=0，要计算的子数组是一个前缀（从 a[0] 到 a[right]），我们要用 s[right+1] 减去 s[0]。如果不定义 s[0]=0，就必须特判 left=0 的情况了（读者可以试试）。通过定义 s[0]=0，任意子数组（包括前缀）都可以表示为两个前缀和的差。此外，如果 a 是空数组，定义 s[0]=0 的写法是可以兼容这种情况的

```c++
class NumArray {
    vector<int> s;
public:
    NumArray(vector<int> &nums) {
        s.resize(nums.size() + 1);
        for (int i = 0; i < nums.size(); i++) {
            s[i + 1] = s[i] + nums[i];
        }
    }

    int sumRange(int left, int right) {
        return s[right + 1] - s[left];
    }
};
```

# [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)


# [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

# [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

[[贪心#[53. 最大子数组和](https //leetcode.cn/problems/maximum-subarray/)]]
我用贪心做的，但其实可以用前缀和or动态规划来做，可以做做
[灵茶山艾府讲解和扩展题](https://leetcode.cn/problems/maximum-subarray/solutions/2533977/qian-zhui-he-zuo-fa-ben-zhi-shi-mai-mai-abu71/?envType=study-plan-v2&envId=top-100-liked)

```c++
int maxSubArray(vector<int>& nums) {  
    int  right = 0,temp = 0;  
    long long ans = LLONG_MIN;  
    while (right < nums.size()) {  
        if (temp >= 0) {  
            temp += nums[right];  
            ans = ans > temp ? ans : temp;  
        }else {  
            temp = 0;  
            temp += nums[right];  
            ans = ans > temp ? ans : temp;  
        }  
        ++right;  
    }  
    return ans;  
}
```


# [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)


# [189. 轮转数组](https://leetcode.cn/problems/rotate-array/)


# [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)



# [41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)


# [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

# [73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

```c++
void setZeroes(vector<vector<int>>& matrix) {  
    int m = matrix.size(), n = matrix[0].size();  
    vector<int> row(m,0), col(n,0);  
    for (int i = 0; i < m; i++) {  
        for (int j = 0; j < n; j++) {  
            if (matrix[i][j] == 0) {  
                row[i] = 1;  
                col[j] = 1;  
            }  
        }  
    }  
    for (int i = 0; i < m; i++) {  
        if (row[i]) { for (int j = 0; j < n; j++) matrix[i][j] = 0;}  
    }  
    for (int j = 0; j < n; j++) {  
        if (col[j]) { for (int i = 0; i < m; i++) matrix[i][j] = 0;}  
    }  
}
```

#  [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)
不要用卡尔的思路
[[双向双指针#[LCR 146. 螺旋遍历二维数组](https //leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)/ [54. 螺旋矩阵](https //leetcode.cn/problems/spiral-matrix/)]]
```c++
vector<int> spiralOrder(vector<vector<int>>& matrix) {  
    int m = matrix.size(), n = matrix[0].size();  
    int up = 0, down = m-1, left = 0, right = n-1;  
    vector<int> ans;  
    while (true) {  
        for (int i = left; i <= right; i++) {  
            ans.push_back(matrix[up][i]);  
        }  
        if (++up > down) {break;}  
        for (int i = up; i <= down; i++) {  
            ans.push_back(matrix[i][right]);  
        }  
        if (--right<left){break;}  
        for (int i = right; i >= left; i--) {  
            ans.push_back(matrix[down][i]);  
        }  
        if (--down<up){break;}  
        for (int i = down; i >= up; i--) {  
            ans.push_back(matrix[i][left]);  
        }  
        if (++left>right){break;}  
    }  
    return ans;  
}
```

# [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

对于矩阵中的第一行而言，在旋转后，它出现在倒数第一列的位置：
并且，第一行的第 x 个元素在旋转后恰好是倒数第一列的第 x 个元素。

对于矩阵中的第二行而言，在旋转后，它出现在倒数第二列的位置：

对于矩阵中的第三行和第四行同理。这样我们可以得到规律：

对于矩阵中第 i 行的第 j 个元素，在旋转后，它出现在倒数第 i 列的第 j 个位置。
由于矩阵中的行列从 0 开始计数，因此对于矩阵中的元素 matrix\[row]\[col]，在旋转后，它的新位置为 matrix \[col]\[n−row−1]。n是matrix的size
$$
\text{matrix}_{new}[\text{col}][n - \text{row} - 1] = \text{matrix}[\text{row}][\text{col}]
$$


我们还可以另辟蹊径，用翻转操作代替旋转操作。
![[Pasted image 20250308203354.png]]


# [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

![](https://pic.leetcode-cn.com/6584ea93812d27112043d203ea90e4b0950117d45e0452d0c630fcb247fbc4af-Picture1.png)

# [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)
将前序遍历反过来遍历，那么第一次访问的就是前序遍历中最后一个节点。那么可以调整最后一个节点，再将最后一个节点保存到pre里，再调整倒数第二个节点，将它的右子树设置为pre，再调整倒数第三个节点，依次类推直到调整完毕。和反转链表的递归思路是一样的。
```c++
class Solution {
public:
    TreeNode* preNode;
    void flatten(TreeNode* root) {
        if (root == NULL) return;
        flatten(root->right);
        flatten(root->left);
        root->left = NULL;
        root->right = preNode;
        preNode = root;
    }
};
```
# [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

[灵神解法](https://leetcode.cn/problems/intersection-of-two-linked-lists/solutions/2958778/tu-jie-yi-zhang-tu-miao-dong-xiang-jiao-m6tg1/?envType=study-plan-v2&envId=top-100-liked)


# [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)
[[链表#[206. 反转链表](https //leetcode.cn/problems/reverse-linked-list/)]]

```c++
ListNode* reverseList(ListNode* head) {  
    ListNode* prev = nullptr;  
    ListNode* next = nullptr;  
    ListNode* curr = head;  
    while (curr != nullptr) {  
        next = curr->next;  
        curr->next = prev;  
        prev = curr;  
        curr = next;  
    }  
    return prev;  
}
```


# [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)
[[链表#[234. 回文链表](https //leetcode.cn/problems/palindrome-linked-list/)]]

```c++
ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* next = nullptr;
    ListNode* curr = head;
    while (curr != nullptr) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}


bool isPalindrome(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
    }
    ListNode* mid = reverseList(slow);
    slow = head;
    while (mid != nullptr) {
        if (mid->val != slow->val) {return false;}
        slow = slow->next;
        mid = mid->next;
    }
    return true;
}
```


# [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)
[[链表#[141. 环形链表](https //leetcode.cn/problems/linked-list-cycle/)]]

```c++
bool hasCycle(ListNode *head) {  
    ListNode* slow = head;  
    ListNode* fast = head;  
    while (fast != nullptr && fast->next != nullptr) {  
        slow = slow->next;  
        fast = fast->next->next;  
        if (slow == fast) {  
            return true;  
        }  
    }  
    return false;  
}
```


# [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)
[[链表#[142. 环形链表 II](https //leetcode.cn/problems/linked-list-cycle-ii/)]]


# [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)
用一个dummy node把他们穿在一起

```c++
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {  
    ListNode dummy (0);  
    // ListNode dummy2 (0,list2);  
    if (list1 == nullptr ) {  
        return list2;  
    }  
    if (list2 == nullptr ) {  
        return list1;  
    }  
    ListNode* p0 = &dummy;  
    ListNode* p1 = list1;  
    ListNode* p2 = list2;  
    while (p1 != nullptr && p2 != nullptr) {  
        ListNode* temp =nullptr;  
        if (p1->val <= p2->val) {  
            p0->next = p1;  
            p1 = p1->next;  
            p0 = p0->next;  
        }else {  
            p0->next = p2;  
            p2 = p2->next;  
            p0 = p0->next;  
        }  
    }  
    if (p1 == nullptr) {  
        p0->next = p2;  
    }  
    if (p2 == nullptr) {  
        p0->next = p1;  
    }  
    return dummy.next;  
  
}
```


# [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

[[链表#[445. 两数相加 II](https //leetcode.cn/problems/add-two-numbers-ii/)]]
```c++
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {  
    if (l1 == nullptr || l2 == nullptr) {  
        return l1 == nullptr ? l2 : l1;  
    }  
    int carry = 0;  
    ListNode* p1 = l1;  
    ListNode* p2 = l2;  
    ListNode* prev1 = nullptr;  
    while (p1 != nullptr && p2 != nullptr) {  
        int sum = p1->val + p2->val+carry;  
        carry = sum / 10;  
        sum = sum % 10;  
        p1->val = sum;  
        prev1 = p1;  
        p1 = p1->next;  
        p2 = p2->next;  
    }  
    if (p1 == nullptr && p2 == nullptr) {  
        if (carry == 1) {  
            prev1->next = new ListNode(1);  
        }  
    }  
    else if (p1 == nullptr && p2 != nullptr) {  
        p1 = prev1;  
        while (p2 != nullptr) {  
            int sum = p2->val + carry;  
            carry = sum / 10;  
            sum = sum % 10;  
            p2->val = sum;  
            p1->next= p2;  
            p1= p1->next;  
            p2 = p2->next;  
        }  
        if (carry == 1) {  
            p1->next = new ListNode(1);  
        }  
    }else if (p1 != nullptr && p2 == nullptr) {  
        while (p1 != nullptr) {  
            int sum = p1->val + carry;  
            carry = sum / 10;  
            sum = sum % 10;  
            p1->val = sum;  
            prev1 = p1;  
            p1 = p1->next;  
        }  
        if (carry == 1) {  
            prev1->next = new ListNode(1);  
        }  
    }  
    return l1;  
}
```

# [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)
[[链表#[19. 删除链表的倒数第 N 个结点](https //leetcode.cn/problems/remove-nth-node-from-end-of-list/)]]
主要是要走到前一个节点

```c++
ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode dummy(0,head);
    ListNode* p0 = &dummy;
    for (int i = 0; i < n; i++) {
        p0 = p0->next;
    }
    ListNode* cur = &dummy;
    while (p0->next!=nullptr) {
        cur = cur->next;
        p0 = p0->next;
    }
    ListNode* temp = cur->next;
    cur->next = cur->next->next;
    delete temp;
    return dummy.next;
}
```


# ==[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)==
[[链表#[24. 两两交换链表中的节点](https //leetcode.cn/problems/swap-nodes-in-pairs/)]]


# ==[25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)==

# ==[138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)==
## 解法1
而本题中因为随机指针的存在，当我们拷贝节点时，「当前节点的随机指针指向的节点」可能还没创建，因此我们需要变换思路。一个可行方案是，我们利用回溯的方式，让每个节点的拷贝操作相互独立。对于当前节点，我们首先要进行拷贝，然后我们进行「当前节点的后继节点」和「当前节点的随机指针指向的节点」拷贝，拷贝完成后将创建的新节点的指针返回，即可完成当前节点的两指针的赋值。

具体地，我们用哈希表记录每一个节点对应新节点的创建情况。遍历该链表的过程中，我们检查「当前节点的后继节点」和「当前节点的随机指针指向的节点」的创建情况。如果这两个节点中的任何一个节点的新节点没有被创建，我们都立刻递归地进行创建。当我们拷贝完成，回溯到当前层时，我们即可完成当前节点的指针赋值。注意一个节点可能被多个其他节点指向，因此我们可能递归地多次尝试拷贝某个节点，为了防止重复拷贝，我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，我们可以直接从哈希表中取出拷贝后的节点的指针并返回即可。

在实际代码中，我们需要特别判断给定节点为空节点的情况。

```c++
class Solution {
public:
    unordered_map<Node*, Node*> cachedNode;

    Node* copyRandomList(Node* head) {
        if (head == nullptr) {
            return nullptr;
        }
        if (!cachedNode.count(head)) {
            Node* headNew = new Node(head->val);
            cachedNode[head] = headNew;
            headNew->next = copyRandomList(head->next);
            headNew->random = copyRandomList(head->random);
        }
        return cachedNode[head];
    }
};
```

## 解法2



![[Pasted image 20250311103137.png]]

```c++
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (head == nullptr) {
            return nullptr;
        }

        // 复制每个节点，把新节点直接插到原节点的后面
        for (Node* cur = head; cur; cur = cur->next->next) {
            cur->next = new Node(cur->val, cur->next, nullptr);
        }

        // 遍历交错链表中的原链表节点
        for (Node* cur = head; cur; cur = cur->next->next) {
            if (cur->random) {
                // 要复制的 random 是 cur->random 的下一个节点
                cur->next->random = cur->random->next;
            }
        }

        // 把交错链表分离成两个链表
        Node* new_head = head->next;
        Node* cur = head;
        for (; cur->next->next; cur = cur->next) {
            Node* copy = cur->next;
            cur->next = copy->next; // 恢复原节点的 next
            copy->next = copy->next->next; // 设置新节点的 next
        }
        cur->next = nullptr; // 恢复原节点的 next
        return new_head;
    }
};
```

## 附加题 [328. 奇偶链表](https://leetcode.cn/problems/odd-even-linked-list/)


# [148. 排序链表](https://leetcode.cn/problems/sort-list/)

![[Pasted image 20250311105413.png]]
```c++
// 归并排序  
ListNode* getMid(ListNode* head) {  
    ListNode* slow = head, *fast = head,*prev = nullptr;  
    while (fast != nullptr && fast->next != nullptr) {  
        prev = slow;  
        slow = slow->next;  
        fast = fast->next->next;  
    }  
    prev->next = nullptr;  
    return slow;  
}  
ListNode* merge2Lists(ListNode* list1, ListNode* list2) {  
    ListNode dummy(0);  
    ListNode* p0 = &dummy;  
    while (list1 != nullptr && list2 != nullptr) {  
        if (list1->val < list2->val) {  
            p0->next = list1;  
            list1 = list1->next;  
        }else {  
            p0->next = list2;  
            list2 = list2->next;  
        }  
        p0 = p0->next;  
    }  
    if (list1 == nullptr) {  
        p0->next = list2;  
    }  
    if (list2 == nullptr) {  
        p0->next = list1;  
    }  
    return dummy.next;  
}  
ListNode* sortList(ListNode* head) {  
    if (head == nullptr || head->next == nullptr) {return head;}  
    ListNode* mid = getMid(head);  
    head = sortList(head);  
    mid = sortList(mid);  
    return merge2Lists(head,mid);;  
}
```
# ==[23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)==

## 方法一：最小堆
合并后的第一个节点 first，一定是某个链表的头节点（因为链表已按升序排列）。

合并后的第二个节点，可能是某个链表的头节点，也可能是 first 的下一个节点。

例如有三个链表 1->2->5, 3->4->6, 4->5->6，找到第一个节点 1 之后，第二个节点不是另一个链表的头节点，而是节点 1 的下一个节点 2。

按照这个过程继续思考，每当我们找到一个节点值最小的节点 x，就把节点 x.next 加入「可能是最小节点」的集合中。

因此，我们需要一个数据结构，它支持：
	从数据结构中找到并移除最小节点。
	插入节点。
	这可以用最小堆实现。初始把所有链表的头节点入堆，然后不断弹出堆中最小节点 x，如果 x.next 不为空就加入堆中。循环直到堆为空。把弹出的节点按顺序拼接起来，就得到了答案

## 方法二： 分治

暴力做法是，按照  [[Hot100#[21. 合并两个有序链表](https //leetcode.cn/problems/merge-two-sorted-lists/)|21. 合并两个有序链表]] 的 题解思路，先合并前两个链表，再把得到的新链表和第三个链表合并，再和第四个链表合并，依此类推。

但是这种做法，平均每个节点会参与到 O(k) 次合并中（用 (1+2+⋯+k)/k 粗略估计），所以总的时间复杂度为 O(nk)。

一个巧妙的思路是，把 lists 一分为二（尽量均分），先合并前一半的链表，再合并后一半的链表，然后把这两个链表合并成最终的链表。如何合并前一半的链表呢？我们可以继续一分为二。如此分下去直到只有一个链表，此时无需合并。

我们可以写一个递归来完成上述逻辑，如果你对递归头晕，请看【基础算法精讲 09】。

按照一分为二再合并的逻辑，递归像是在后序遍历一棵平衡二叉树。由于平衡树的高度是 O(logk)，所以每个链表节点只会出现在 O(logk) 次合并中！这样就做到了更快的 O(nlogk) 时间。
# ==[146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)==

有首尾相连的双向链表管理顺序和删除问题，用哈希表让查找时间变成O(1)，使用dummy哨兵避免头节点为空的情况（一开始dummy要指向自己，这样才可以保证最后一个节点指向头节点，这样可以通过dummy获得尾部节点），并且获得头节点，方便插入。主要实现Remove函数，Push_Front函数，get_node函数
![](https://pic.leetcode.cn/1696039105-PSyHej-146-3-c.png)
```c++

```

## 相似题目：[460. LFU 缓存](https://leetcode.cn/problems/lfu-cache/)


# [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)
懒得写了
[[二叉树#[二叉树的迭代遍历](https //programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html %E6%80%9D%E8%B7%AF)]]

# [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
[[二叉树#[104. 二叉树的最大深度](https //leetcode.cn/problems/maximum-depth-of-binary-tree/)]]
```java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
```


# [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)
[[二叉树#[226. 翻转二叉树](https //leetcode.cn/problems/invert-binary-tree/)]]
左子树变右子树
```java
public TreeNode invertTree(TreeNode root) {  
    if (root == null) return null;  
    TreeNode left =invertTree(root.left);  
    TreeNode right = invertTree(root.right);  
    root.left = right;  
    root.right = left;  
    return root;  
}
```


# [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)
[[二叉树#[101. 对称二叉树](https //leetcode.cn/problems/symmetric-tree/)]]
往左往右走
```java
public boolean iS(TreeNode left, TreeNode right) {  
    if (left == null && right == null) return true;  
    else if (left == null || right == null) return false;  
    if (left.val != right.val) return false;  
    return iS(left.left, right.right) && iS(left.right, right.left);  
}  
public boolean isSymmetric(TreeNode root) {  
    if (root == null) return true;  
    return iS(root.left, root.right);  
}
```

# ==[543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)==

# [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

[[二叉树#[102. 二叉树的层序遍历](https //leetcode.cn/problems/binary-tree-level-order-traversal/)]]

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ret = new ArrayList<List<Integer>>();
        if (root == null) {
            return ret;
        }

        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            List<Integer> level = new ArrayList<Integer>();
            int currentLevelSize = queue.size();
            for (int i = 1; i <= currentLevelSize; ++i) {
                TreeNode node = queue.poll();
                level.add(node.val);
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            ret.add(level);
        }
        
        return ret;
    }
}
```

# [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

[[二叉树#[108. 将有序数组转换为二叉搜索树](https //leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)]]

```java
    public TreeNode sATB(int[] nums,int left,int right) {
        if(left > right) return null;
        int mid= left + (right - left)/2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = sATB(nums,left,mid-1);
        root.right = sATB(nums,mid+1,right);
        return root;
    }
    public TreeNode sortedArrayToBST(int[] nums) {
        return sATB(nums,0,nums.length-1);
    }
```




#  [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)
[[二叉树#[98. 验证二叉搜索树](https //leetcode.cn/problems/validate-binary-search-tree/)]]
```java
TreeNode preNode=null;  
public boolean isValidBST(TreeNode root) {  
    if (root == null) return true;  
    boolean left = isValidBST(root.left);  
    if(preNode ==null) preNode=root;  
    else {  
        if(root.val<=preNode.val) return false;  
        preNode=root;  
    }  
    boolean right = isValidBST(root.right);  
    return left && right;  
}
```


# [230. 二叉搜索树中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

[[二叉树#[230. 二叉搜索树中第 K 小的元素](https //leetcode.cn/problems/kth-smallest-element-in-a-bst/)]]
```java
class Solution {
    private int k;

    public int kthSmallest(TreeNode root, int k) {
        this.k = k;
        return dfs(root);
    }

    private int dfs(TreeNode node) {
        if (node == null) {
            return -1; // 题目保证节点值非负，用 -1 表示没有找到
        }
        int leftRes = dfs(node.left);
        if (leftRes != -1) { // 答案在左子树中
            return leftRes;
        }
        if (--k == 0) { // 答案就是当前节点
            return node.val;
        }
        return dfs(node.right); // 右子树会返回答案或者 -1
    }
}
```

# [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

[[二叉树#[199. 二叉树的右视图](https //leetcode.cn/problems/binary-tree-right-side-view/)]]
也可以用层序遍历做
```java
    int maxLevel=0;
    public void rSV(TreeNode root,List<Integer> res, int k) {
        if(root == null) return;
        if (maxLevel == k) {
            res.add(root.val);
            maxLevel++;
        }
        rSV(root.right,res,k+1);
        rSV(root.left,res,k+1);
    }
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        rSV(root,res,0);
        return res;
    }
```

# [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

观察顺序，其实是要最遍历右左中->才可以输出中左右的结果（因为递归模仿了栈的行为），所以这样写
```java
TreeNode preNode2=null;  
public void flatten(TreeNode root) {  
    if (root == null) return;  
    flatten(root.right);  
    flatten(root.left);  
    root.left = null;  
    root.right = preNode2;  
    preNode2 = root;  
}
```


# [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

[[二叉树#[105. 从前序与中序遍历序列构造二叉树](https //leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)]]

注意这个范围怎么定义

```java
Map<Integer,Integer> map=new HashMap<>();  
public TreeNode bT(int[] preorder, int[] inorder, int pstart, int pend,int istart,int iend) {  
    if (pstart > pend) return null;  
    if (pstart == pend) return new TreeNode(preorder[pstart]);  
    int rootVal = preorder[pstart];  
    int index = map.get(rootVal);  
    int range = index - istart;  
    TreeNode root = new TreeNode(rootVal);  
    root.left = bT(preorder,inorder,pstart+1,pstart+range,istart,index-1);  
    root.right = bT(preorder,inorder,pstart+range+1,pend,index+1,iend);  
    return root;  
}  
public TreeNode buildTree(int[] preorder, int[] inorder) {  
    for(int i =0;i<inorder.length;i++) {  
        map.put(inorder[i],i);  
    }  
    return bT(preorder,inorder,0,preorder.length-1,0,inorder.length-1);  
}
```

# ==[437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)==


# ==[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)==
[[二叉树#[236. 二叉树的最近公共祖先](https //leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)]]
分情况讨论

```c++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {  
    if (root == nullptr || root == p || root == q) return root;  
    TreeNode* left = lowestCommonAncestor(root->left, p, q);  
    TreeNode* right = lowestCommonAncestor(root->right, p, q);  
    if (left == nullptr && right == nullptr) {  
        return nullptr;  
    }else if (left != nullptr && right == nullptr) {  
        return left;  
    }else if (left == nullptr && right != nullptr) {  
        return right;  
    }else {  
        return root;  
    }  
}
```

# [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)


# [46. 全排列](https://leetcode.cn/problems/permutations/)

[[回溯#[46. 全排列](https //leetcode.cn/problems/permutations/)]]

```java
public void bT(List<List<Integer>> res, List<Integer> path, HashSet<Integer> set, int[] nums) {  
    if (path.size() == nums.length) {  
        res.add(new ArrayList<>(path)); // 确保加入的是 `path` 的副本  
        return;  // 这里需要 return，否则会继续执行循环  
    }  
  
    for (int i = 0; i < nums.length; i++) {  
        if (set.contains(nums[i])) continue; // 如果当前数字已被使用，则跳过  
  
        set.add(nums[i]);  
        path.add(nums[i]);  
  
        bT(res, path, set, nums); // 递归  
  
        path.remove(path.size() - 1); // 回溯，移除最后一个添加的元素  
        set.remove(nums[i]); // 这里要用 `nums[i]` 而不是 `path.size()-1`    }  
}  
  
public List<List<Integer>> permute(int[] nums) {  
    List<List<Integer>> res = new ArrayList<>();  
    List<Integer> path = new ArrayList<>();  
    HashSet<Integer> set = new HashSet<>();  
  
    if (nums == null || nums.length == 0) return res;  
  
    bT(res, path, set, nums);  
    return res;  
}
```


# [78. 子集](https://leetcode.cn/problems/subsets/)

[[回溯#[78. 子集](https //leetcode.cn/problems/subsets/)]]

```java
public void bT2(List<List<Integer>> res, List<Integer> path, int[] nums,int k) {  
    res.add(new ArrayList<>(path));  
  
    for (int i = k; i < nums.length; i++) {  
        path.add(nums[i]);  
        bT2(res, path, nums, i+1);  
        path.remove(path.size() - 1);  
    }  
}  
public List<List<Integer>> subsets(int[] nums) {  
    List<List<Integer>> res = new ArrayList<>();  
    List<Integer> path = new ArrayList<>();  
    if (nums == null || nums.length == 0) return res;  
    bT2(res, path, nums, 0);  
    return res;  
}
```


#  [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)
[[回溯#[17. 电话号码的字母组合](https //leetcode.cn/problems/letter-combinations-of-a-phone-number/)]]

```java
class Solution {
    private static final String[] MAPPING = new String[]{"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};

    private final List<String> ans = new ArrayList<>();
    private char[] digits;
    private char[] path;

    public List<String> letterCombinations(String digits) {
        int n = digits.length();
        if (n == 0) {
            return List.of();
        }
        this.digits = digits.toCharArray();
        path = new char[n]; // 注意 path 长度一开始就是 n，不是空数组
        dfs(0);
        return ans;
    }

    private void dfs(int i) {
        if (i == digits.length) {
            ans.add(new String(path));
            return;
        }
        for (char c : MAPPING[digits[i] - '0'].toCharArray()) {
            path[i] = c; // 直接覆盖
            dfs(i + 1);
        }
    }
}
```



# [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

[[回溯#[39. 组合总和](https //leetcode.cn/problems/combination-sum/)]]
```java
public void  bT3(List<List<Integer>> res, List<Integer> path, int[] nums,int k, int sum, int target) {  
    if(sum == target) {  
        res.add(new ArrayList<>(path));  
    }if (sum > target) return;  
      
    for (int i = k; i < nums.length; i++) {  
        path.add(nums[i]);  
        sum += nums[i];  
        bT3(res, path, nums, i, sum, target);  
        path.remove(path.size() - 1);  
        sum -= nums[i];  
    }  
}  
public List<List<Integer>> combinationSum(int[] candidates, int target) {  
    List<List<Integer>> res = new ArrayList<>();  
    List<Integer> path = new ArrayList<>();  
    bT3(res, path, candidates, 0, 0, target);  
    return res;  
}
```

# [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

[[回溯#[22. 括号生成](https //leetcode.cn/problems/generate-parentheses/)]]
考虑每个位置选or不选
```java
public void bT4(List<String> res, char[] path, int left, int right,int i,int n) {  
    if(left + right == 2 * n) res.add(new String(path));  
  
    if (left > right ) {  
        path[i] = ')';  
        bT4(res, path, left, right + 1, i+1, n);  
    }  
    if (left < n) {  
        path[i] = '(';  
        bT4(res, path, left+1, right, i+1, n);  
    }  
  
}  
public List<String> generateParenthesis(int n) {  
    char[] c = new char[2 * n];  
    List<String> res = new ArrayList<>();  
    bT4(res, c, 0, 0, 0, n);  
    return  res;  
}
```

# ==[79. 单词搜索](https://leetcode.cn/problems/word-search/)==

# [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

[[回溯#[131. 分割回文串](https //leetcode.cn/problems/palindrome-partitioning/)]]
之前写的答案会好点
```c++
bool isHuiwen(string& str) {  
    int left = 0, right = str.size() - 1;  
    while (left < right) {  
        if (str[left++] != str[right--]) {  
            return false;  
        }  
    }  
    return true;  
}  
void bT(vector<vector<string>>& res, vector<string>& strs, string& s, int k) {  
    if (k == s.size()) {  
        res.push_back(strs);  
        return;  
    }  
    for (int i = k; i < s.size(); i++) {  
        string sub = s.substr(k, i-k+1);  
        if (isHuiwen(sub)) {  
            strs.push_back(sub);  
            bT(res, strs, s, i+1);  
            strs.pop_back();  
        }  
    }  
}  
vector<vector<string>> partition(string s) {  
    vector<vector<string>> res;  
    vector<string> strs;  
    bT(res, strs, s, 0);  
    return res;  
}

```
# [51. N 皇后](https://leetcode.cn/problems/n-queens/)


[[回溯#[51. N 皇后](https //leetcode.cn/problems/n-queens/)]]
0x3f
```c++
class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> ans;
        vector<int> queens(n); // 皇后放在 (r,queens[r])
        vector<int> col(n), diag1(n * 2 - 1), diag2(n * 2 - 1); // vector<int> 效率比 vector<bool> 高
        auto dfs = [&](this auto&& dfs, int r) {
            if (r == n) {
                vector<string> board(n);
                for (int i = 0; i < n; i++) {
                    board[i] = string(queens[i], '.') + 'Q' + string(n - 1 - queens[i], '.');
                }
                ans.push_back(board);
                return;
            }
            // 在 (r,c) 放皇后
            for (int c = 0; c < n; c++) {
                int rc = r - c + n - 1;
                if (!col[c] && !diag1[r + c] && !diag2[rc]) { // 判断能否放皇后
                    queens[r] = c; // 直接覆盖，无需恢复现场
                    col[c] = diag1[r + c] = diag2[rc] = true; // 皇后占用了 c 列和两条斜线
                    dfs(r + 1);
                    col[c] = diag1[r + c] = diag2[rc] = false; // 恢复现场
                }
            }
        };
        dfs(0);
        return ans;
    }
};
```


# [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

