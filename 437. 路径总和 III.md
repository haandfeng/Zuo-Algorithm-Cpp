# [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)
如果二叉树是一条链，本题就和G560.和为K的子数组 完全一样了：统计有多少个非空连续子数组的元素和恰好等于 targetSum。所以你必须先弄明白560题（特殊情况），再来做本题（一般情况）。560 题的做法见 我的题解。

![[Pasted image 20251219194408.png]]
我们要解决的问题是：DFS 遍历这棵树，遍历到节点 node 时，假设 node 是路径的终点，那么有多少个起点，满足起点到终点 node 的路径总和恰好等于 targetSum？

和 560 题一样的套路：一边遍历二叉树，一边用哈希表 cnt 统计前缀和（从根节点开始的路径和）的出现次数。设从根到终点 node 的路径和为 s，那么起点的个数就是 cnt[s−targetSum]，加入答案。对比 560 题，我们在枚举子数组的右端点（终点），统计有多少个左端点（起点），做法完全一致

```java
class Solution {
    int count = 0;
    int k;
    HashMap<Long, Integer> h = new HashMap();
    
    public void preorder(TreeNode node, long currSum) {
        if (node == null)
            return;
        
        // The current prefix sum
        currSum += node.val;

        // Here is the sum we're looking for
        if (currSum == k)
            count++;
        
        // The number of times the curr_sum − k has occurred already, 
        // determines the number of times a path with sum k 
        // has occurred up to the current node
        count += h.getOrDefault(currSum - k, 0);
        
        //Add the current sum into the hashmap
        // to use it during the child node's processing
        h.put(currSum, h.getOrDefault(currSum, 0) + 1);

        // Process the left subtree
        preorder(node.left, currSum);

        // Process the right subtree
        preorder(node.right, currSum);

        // Remove the current sum from the hashmap
        // in order not to use it during 
        // the parallel subtree processing
        h.put(currSum, h.get(currSum) - 1);
    }    
            
    public int pathSum(TreeNode root, int sum) {
        k = sum;
        preorder(root, 0L);
        return count;
    }

```
# [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)


这道问题可以转化为，s中有多少对下标(i,j)满足 s[j] - s[i] = k (i < j)
即统计有多少个 s[i] = s[j] - k
用哈希表保存 s[i]的值和他出现的频率，就可以快速找到 有多少个s[i] = s[j] - k



所以：

枚举当前的前缀和 s[j]，看看曾经有多少个前缀和等于 s[j]−k（配对）。每当我们在左边找到一个值等于 s[j]−k 的前缀和，就找到了一个和为 k 的子数组（因为 s[j]−(s[j]−k)=k）。

比如 s[j]=2，那么 s[i]=s[j]−k=2−1=1，我们要找的是 j 左边有多少个 s[i]=1。在上面的例子中，遍历到 s[4]=2 时，我们知道左边有 2 个 s[i]=1，所以新找到了 2 个和为 1 的子数组。


```java
    class Solution {
        public int subarraySum(int[] nums, int k) {
            Map<Integer, Integer> cnt = new HashMap<>(nums.length,1);
            int s = 0;
            int ret = 0;
            cnt.put(0, 1);
            for(int i = 0 ; i< nums.length; ++i){
                s += nums[i];
                ret += cnt.getOrDefault(s - k, 0);  
                cnt.merge(s, 1, Integer::sum); // cnt[s]++
            
            }

            return ret;
        }
    }
```

这样保证：
	•	cnt 里只包含：
	•	当前位置 之前 的前缀和
	•	不会把当前前缀和拿来和自己配对
	•	k = 0、有负数、全 0 数组等情况都能正确处理
