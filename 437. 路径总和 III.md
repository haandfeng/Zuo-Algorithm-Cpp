# [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)




# [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)


这道问题可以转化为，s中有多少对下标(i,j)满足 s[j] - s[i] = k (i < j)
即统计有多少个 s[i] = s[j] - k
用哈希表保存 s[i]的值和他出现的频率，就可以快速找到 有多少个s[i] = s[j] - k



所以：

枚举当前的前缀和 s[j]，看看曾经有多少个前缀和等于 s[j]−k（配对）。每当我们在左边找到一个值等于 s[j]−k 的前缀和，就找到了一个和为 k 的子数组（因为 s[j]−(s[j]−k)=k）。

比如 s[j]=2，那么 s[i]=s[j]−k=2−1=1，我们要找的是 j 左边有多少个 s[i]=1。在上面的例子中，遍历到 s[4]=2 时，我们知道左边有 2 个 s[i]=1，所以新找到了 2 个和为 1 的子数组。




这样保证：
	•	cnt 里只包含：
	•	当前位置 之前 的前缀和
	•	不会把当前前缀和拿来和自己配对
	•	k = 0、有负数、全 0 数组等情况都能正确处理
